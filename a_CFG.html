
<!--
INTERFACE FIXES:
Template tables: ARIA grid w/ keyboard navigation
Template tables: screenreader compatibility
Make output boxes aria-live="polite"
Input box ARIA
Disclosure pattern for More/Less
Resizing trees in subwindows
Resizing trees with appropriate minimum height
Pressing "delete" on S will clear all children?
 -> maybe will clear label to '...'?
Minor input box UI around line-breaks (also, final space in output boxes)
UI box need to lock after completing (and load locked state correctly)
Add outlines for labels that need to be filled? -> An underling might work nicely
-->

<!--
LOADING BUGS:
Make sure that all enabling and disabling of buttons is appropriate
Make sure that input box 'editing' is appropriate
Something with input box loading and cursors
Once saw "continue" button before answering "Identifying bad rules"
-->


<!--
CONTENT FIXES:
Need menu for skipping around
"Generate all strings" retooling
-->


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Context-Free Grammars</title>
</head>
<body>

<style>
body {
  font-family: "gill sans mt", "gill sans", sans-serif;
  font-size: 20px;
  max-width: 33em;
  line-height: 1.3;
  background-color: white;
  color: black;
}
button {
  font-family: "gill sans mt", "gill sans",sans-serif;
  font-size: 20px;
}
input {
  font-family: "gill sans mt", "gill sans",sans-serif;
  font-size: 20px;
}
.input-cursor {
    background: black;
    position: absolute;
    height: 1.2em;
}
@keyframes blink {
    50% { opacity: 0; }
}
.dark-mode {
    background-color: black;
    color: white;
}
a:link { color: #0000EE; }
a:visited { color: #551A8B; }
.dark-mode a:link { color: lightskyblue; }
.dark-mode a:visited { color: plum; }
button {border-radius: .2em; border: 1px solid #888888;}
.dark-mode button { color: white; background-color: #333333; }
.dark-mode button:hover { background-color: #555555; }
.dark-mode button:active { background-color: black; }
.dark-mode button:disabled, .dark-mode button[disabled] {color: #888888; background-color: #222222;}
.dark-mode .drawn-box {background-color: #333333;}
.invert-color { color:white; } 
.dark-mode .invert-color { color:black; }
.selection-color { color: #005AA3; }
.dark-mode .selection-color { color: #249CFF; }
.grayed-out { color: #595959; }
.dark-mode .grayed-out { color: #969696; }
svg {fill:currentColor;}
main { padding-top:3rem; margin-left: 3em; margin-right: 3em; padding-bottom:10rem; }

.progress-bar { display: flex; gap: .2em; margin-top: .3em;}
.progress-block { display: flex; border-radius: .5em; overflow: hidden; }
.progress-section { height: 1em; border-right: .1em solid white; }
.dark-mode .progress-section { height: 1em; border-right: .1em solid black; }
.complete-block { background-color: green; }
.complete-section { background-color: lightgreen; }
.incomplete-section { background-color: lightgray; }
</style>

<script type="text/javascript">
const sectionRedraws = new Map();
const sectionStarts = new Map();
var state = ['frontmatter','intro'];
var progressBarChunks = [[1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,2,1,3,2],[3,2,3,3,3]]
var drawn = false;
</script>


<header id='banner' style="position: fixed; border-style:solid; width:98%; z-index:2; padding:.3em">
<button onclick="
    localStorage.setItem('outerState',state.toString());
    localStorage.setItem('innerState',getSectionStates().toString());
">Save</button>
<button onclick="
    const saveFile = localStorage.getItem('outerState');
    if (saveFile != null) {
        state = localStorage.getItem('outerState').split(',');
        arrangeSections();
        putSectionStates(localStorage.getItem('innerState').split(','));
        startSections();
        redrawSections();
        window.scrollTo(0, document.body.scrollHeight);
    } 
">Load</button>
<button onclick="
if (document.body.className == '') {
    document.body.className = 'dark-mode';
} else {
    document.body.className = '';
}
">Toggle night mode</button>
<span id='banner-out' style='display:none'>Test</span>
<div class="progress-bar" id="progressBar"></div>
</header>

<script type="text/javascript">
document.getElementById('banner').style.backgroundColor = 'inherit';
</script>

<main id="main">
<section id="frontmatter" data-state="">
<h1>Context-Free Grammars</h1>
</section>


<section id="intro" data-state="" data-initial-state="">
<script type="text/javascript">
function introRedraw(sectionState) {
  if (sectionState == "X") {
    document.getElementById('intro-continue').style.display = 'none';
  } else {
    document.getElementById('intro-continue').style.display = 'block';
  }
}
sectionRedraws.set('intro',introRedraw);
</script>

<h2>Introduction</h2>
<p>This activity motivates, defines, and explores <em>Context-Free Grammars</em>, or CFGs.</p>
<p>A CFG is a <em>formal model</em> of syntax. When I say <em>formal</em>, think of formal laws. Formal laws are specific and explicit, and can be fully written down. Something formal may be studied in math, or coded on a computer. When I say <em>model</em>, think of a model airplane. Model airplanes are similar actual airplanes in many ways, and this makes them useful, either for their own sakes or in studying actual airplanes. However, there are also many ways in which model airplanes and actual airplanes are different. When studying or using models, it&rsquo;s important to understand them on their own terms, as well as how they are similar to and differ from reality.</p>
<p>CFGs were defined among other formal models of syntax by Noam Chomsky in the 1950&rsquo;s, building on earlier work in math and linguistics from the first half of the twentieth century.<span class='collapse-note'> In mathematics, Axel Thue and the later but better-known Emil Post had studied what are called <em>rewrite systems</em>, which include CFGs.<span class='collapse-note'> For primary sources, see Thue (1914) (or <a href='https://doi.org/10.48550/arXiv.1308.5858'>Power (2013)</a>&rsquo;s translation) and <a href='https://doi.org/10.2307%2F2371809'>Post (1943)</a>. Chomsky knew of this work through Rosenbloom (1950)&rsquo;s textbook on logic.</span> In linguistics, older ideas about syntax were formed into a new theory of <em>immediate constituent analysis</em> by American structural linguists including Leonard Bloomfield (who came up with the name) and Zellig Harris.<span class='collapse-note'> <a href='https://press.uchicago.edu/ucp/books/book/chicago/L/bo3636364.html'>Bloomfield (1933)</a> and <a href='https://archive.org/details/methodsinstructu0000harr/'>Harris (1951)</a> are two field-defining books that explore this theory in detail.</span> Noam Chomsky built upon both of these fields in his work in the 1950&rsquo;s, culminating in his 1956 paper &ldquo;<a href='https://doi.org/10.1109/TIT.1956.1056813'>Three Models for the Description of Language</a>&rdquo; and his 1959 paper &ldquo;<a href='https://doi.org/10.1016/S0019-9958(59)90362-6'>On Certain Formal Properties of Grammars</a>&rdquo;. In his later paper, CFGs are explicitly defined (there, called a &ldquo;Type 2&rdquo; grammar)</span> (Here and throughout the activity, you can press a button containing a bracketed word like &ldquo;More&rdquo;, &ldquo;Controls&rdquo;, &ldquo;Rules&rdquo;, or &ldquo;Hint&rdquo; to display further information.) Even at the time, the limitations of CFGs as a model of syntax were clear, and those limitations were used to motivate other, more powerful models. However, CFGs provide a useful balance of simplicity and power, and are a great starting-point to understand other models. Today, CFGs continue to be applied in formal logic, in programming languages, and in natural language processing.</p>
<p>To complete this activity, you will learn about and apply CFGs. You will be asked small comprehension questions to check your understanding along the way; you only get one chance to answer each of these questions, and if you get them wrong, you should read the following explanations to make sure that you understand why. You will also be asked to perform other tasks and answer more open-ended questions; for these, you will not be able to continue until you&rsquo;ve answered the questions correctly and shouldn&rsquo;t hesitate to submit partial or incorrect answers in order to receive feedback which can help you find the correct answer.</p>
<button id="intro-continue" onclick="parentSection(this).dataset.state='X'; state.push('basicTemplate'); redrawSections();">Begin</button>

</section>

<section id="basicTemplate" data-state="" data-initial-state="">
<script type="text/javascript">
function basicTemplateRedraw(sectionState) {
  if (sectionState.length > 2 && sectionState.charAt(0)!="X") {
    document.getElementById('basicTemplate-button').style.display = 'block';
  } else {
    document.getElementById('basicTemplate-button').style.display = 'none';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('basicTemplate',basicTemplateRedraw);
</script>
<h2>What is a CFG?</h2>
<p>I won&rsquo;t tell you what a CFG is right away. Instead, you&rsquo;ll start out with a very simple template, or form to fill out, that will slowly be expanded until it reflects the full richness of a CFG. You won&rsquo;t need to remember the specific details of these intermediate steps in the long run: Focus on the intuitions and motivations for the whole process.</p>

<h3>The basic template</h3>
<p>There are three members of the Alves family: Andy, Alex, and Ari. We know that one of them went on a trip to the library and checked something out. The library only has magazines, books, and movies.</p>
<p>The following template allows us to report any possible trip. Once you&rsquo;ve selected an option for each of the two blank positions, a full sentence will be generated in the text box below them. For models like these, we call the generated sentence a &ldquo;string&rdquo;; think of words like beads on a string, which are arranged in a line without loops. Depending on the model, a generated string may be a sentence, a phrase, or a word. Generate a few example strings to understand how this template works. Once you&rsquo;ve done so, you can continue.</p>
<div id='two-template'><select name="alves" id="two-template-1" onchange="updateTemplate(this,true)" data-for="output-two-template" autocomplete="off"><option value="empty" selected>NAME</option><option value="andy">Andy</option><option value="alex">Alex</option><option value="ari">Ari</option></select><span> checked out a </span><select name="type" id="two-template-2" onchange="updateTemplate(this,true)" data-for="output-two-template" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie">movie</option></select><span> from the library.</span></div>
<div class='output-box' data-text='' id='output-two-template' data-blanks='two-template-1,two-template-2' data-template='two-template' data-section='basicTemplate'></div>

<button id="basicTemplate-button" onclick="parentSection(this).dataset.state='X'+parentSection(this).dataset.state; state.push('basicTemplateProperties'); redrawSections();">Continue</button>

</section>

<section id="basicTemplateProperties" data-state="" data-initial-state="">
<script type="text/javascript">
function basicTemplatePropertiesRedraw(sectionState) {
  for (let i = 1; i <= 3; i++) {
    if (sectionState.length >= i) {
      if (i < 3) {
        document.getElementById('tpq'+(i+1)).style.display = 'block';
      }
      document.getElementById('tpq'+(i)+'yes').disabled = true;
      document.getElementById('tpq'+(i)+'no').disabled = true;
      document.getElementById('tpq'+(i)+'submit').style.display = 'none';
      if (sectionState.charAt(i-1) == "y") {
        document.getElementById('tpq'+(i)+'yes').checked = true;
        document.getElementById('tpq'+(i)+'yes-out').style.display = 'block';
        document.getElementById('tpq'+(i)+'no-out').style.display = 'none';
      } else {
        document.getElementById('tpq'+(i)+'no').checked = true;
        document.getElementById('tpq'+(i)+'yes-out').style.display = 'none';
        document.getElementById('tpq'+(i)+'no-out').style.display = 'block';
      }
    } else {
      if (i < 3) {
        document.getElementById('tpq'+(i+1)).style.display = 'none';
      }
      document.getElementById('tpq'+(i)+'yes').disabled = false;
      document.getElementById('tpq'+(i)+'no').disabled = false;
      document.getElementById('tpq'+(i)+'yes-out').style.display = 'none';
      document.getElementById('tpq'+(i)+'no-out').style.display = 'none';
      document.getElementById('tpq'+(i)+'submit').style.display = 'inline';
    }
  }
  if (sectionState.length == 3) {
    document.getElementById('basicTemplateProperties-button').style.display = 'block';
  } else {
    document.getElementById('basicTemplateProperties-button').style.display = 'none';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('basicTemplateProperties',basicTemplatePropertiesRedraw);
</script>
<p>This template shares two important properties with CFGs. First, each blank position is filled with something from a fixed and limited list of options. Second, each blank position can be filled independently of the rest of the template. This is where the term &ldquo;context-free&rdquo; comes from: Each choice can be made freely of the context of the rest of the template.</p>


<div id='tpq1'>
<p>Comprehension question: If the above template were modified to include five names of Alves family members (adding cousins Avery and Arthur), would it still follow the above two properties?</p>

<p>(Click [View Template] below to see this template in action)</p>

<div><span class="collapse-note" data-label="View Template">
    
<div id='two-template-five'><select name="alves" id="two-template-five-1" onchange="updateTemplate(this,false)" data-for="output-two-template-five" autocomplete="off"><option value="empty" selected>NAME</option><option value="andy">Andy</option><option value="alex">Alex</option><option value="ari">Ari</option><option value="avery">Avery</option><option value="arthur">Arthur</option></select><span> checked out a </span><select name="type" id="two-template-five-2" onchange="updateTemplate(this,false)" data-for="output-two-template-five" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie">movie</option></select><span> from the library.</span></div>
<div class='output-box' data-text='' id='output-two-template-five' data-blanks='two-template-five-1,two-template-five-2' data-template='two-template-five' data-section='basicTemplateProperties'></div>

</span></div>

<input type="radio" id="tpq1yes" name="tpq1" value="yes">
<label for="tpq1yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="tpq1no" name="tpq1" value="no">
<label for="tpq1no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="tpq1submit" onclick="if(document.getElementById('tpq1yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('tpq1no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}basicTemplatePropertiesRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='tpq1yes-out'>That&rsquo;s right: The list of options for the name would still be fixed and limited. The modified template would still follow the properties.</p>

<p id='tpq1no-out'>That&rsquo;s not right: While the list of options for the name would be larger than the current list, it would still be fixed and limited. The modified template would still follow the properties.</p>

<div id='tpq2'>
<p>Comprehension question: If the above template were modified to let you type in any name for an Alves family member, would it still follow the above two properties?</p>

<div><span class="collapse-note" data-label="View Template">
    
<div id='two-template-fill'><input type="text" id="two-template-fill-1" name="alves" onchange="updateTemplate(this,false)" data-for="output-two-template-fill" size="15"><span> checked out a </span><select name="type" id="two-template-fill-2" onchange="updateTemplate(this,false)" data-for="output-two-template-fill" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie">movie</option></select><span> from the library.</span></div>
<div class='output-box' data-text='' id='output-two-template-fill' data-blanks='two-template-fill-1,two-template-fill-2' data-template='two-template-fill' data-section='basicTemplateProperties'></div>
    
</span></div>

<input type="radio" id="tpq2yes" name="tpq2" value="yes">
<label for="tpq2yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="tpq2no" name="tpq2" value="no">
<label for="tpq2no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="tpq2submit" onclick="if(document.getElementById('tpq2yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('tpq2no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}basicTemplatePropertiesRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='tpq2no-out'>That&rsquo;s right: The list of options for the name would be unlimited, because you could enter any name. The modified template would no longer follow the properties.</p>

<p id='tpq2yes-out'>That&rsquo;s not right: The first property says that the list of options for a given blank position must be fixed and limited, but by allowing any name to be typed in, we would make the list unlimited, because you could enter any name. The modified template would no longer follow the properties.</p>

<div id='tpq3'>
<p>Comprehension question: If the above template were modified so that Andy cannot check out movies, would it still follow the above two properties?</p>

<div><span class="collapse-note" data-label="View Template">
    
<div id='two-template-block'><select name="alves" id="two-template-block-1" onchange="updateTemplate(this,false); if(this.value == 'andy') {document.getElementById('template-block-movie').setAttribute('disabled', true)} else {document.getElementById('template-block-movie').removeAttribute('disabled')};" data-for="output-two-template-block" autocomplete="off"><option value="empty" selected>NAME</option><option value="andy" id="template-block-andy">Andy</option><option value="alex">Alex</option><option value="ari">Ari</option></select><span> checked out a </span><select name="type" id="two-template-block-2" onchange="updateTemplate(this,false); if(this.value == 'movie') {document.getElementById('template-block-andy').setAttribute('disabled', true)} else {document.getElementById('template-block-andy').removeAttribute('disabled')};" data-for="output-two-template-block" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie" id="template-block-movie">movie</option></select><span> from the library.</span></div>
<div class='output-box' data-text='' id='output-two-template-block' data-blanks='two-template-block-1,two-template-block-2' data-template='two-template-block' data-section='basicTemplateProperties'></div>

</span></div>

<input type="radio" id="tpq3yes" name="tpq3" value="yes">
<label for="tpq3yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="tpq3no" name="tpq3" value="no">
<label for="tpq3no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="tpq3submit" onclick="if(document.getElementById('tpq3yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('tpq3no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}basicTemplatePropertiesRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='tpq3no-out'>That&rsquo;s right: The choice of options would no longer be context-free, because blocking the combination of &ldquo;Andy&rdquo; and &ldquo;movie&rdquo; means that the choice of options would no longer be made freely of the context of the other blank position.<span class="collapse-note"> I could still build a context-free template that generates the same strings as this modified non-context-free one (for example, by simply listing the remaining eight options), but this particular template, with the two blank positions depending on each other, would not be context-free.</span> The modified template would no longer follow the properties.</p>

<p id='tpq3yes-out'>That&rsquo;s not right: The second property says that the choice of options must be able to be made independently of the rest of the template, but if we prevented Andy from checking out movies, the choices would depend on each other. The modified template would no longer follow the properties.<span class="collapse-note"> I could still build a context-free template that generates the same strings as this modified non-context-free one (for example, by simply listing the remaining eight options), but this particular template, with the two blank positions depending on each other, would not be context-free.</span></p>

<button id="basicTemplateProperties-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('doubleTemplate'); redrawSections();">Continue</button>
</section>

<section id="doubleTemplate" data-state="" data-initial-state="">
<script type="text/javascript">
function doubleTemplateRedraw(sectionState) {
  if (sectionState.length > 2 && sectionState.charAt(0)!="X") {
    document.getElementById('doubleTemplate-button').style.display = 'block';
  } else {
    document.getElementById('doubleTemplate-button').style.display = 'none';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('doubleTemplate',doubleTemplateRedraw);
</script>
<h3>Rules</h3>
<p>There are three members of the Biswas family: Bala, Bijal, and Bhavya. We know that one of them also checked something out from the library. The following template lets us report any combined possibility for both the Alves and Biswas families. As before, generate a few strings to make sure you understand the template.</p>

<div id='four-template'><select name="alves" id="four-template-1" onchange="updateTemplate(this,true)" data-for="output-four-template" autocomplete="off"><option value="empty" selected>ALVES</option><option value="andy">Andy</option><option value="alex">Alex</option><option value="ari">Ari</option></select><span> checked out a </span><select name="type" id="four-template-2" onchange="updateTemplate(this,true)" data-for="output-four-template" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie">movie</option></select><span> from the library and </span><select name="biswas" id="four-template-3" onchange="updateTemplate(this,true)" data-for="output-four-template" autocomplete="off"><option value="empty" selected>BISWAS</option><option value="bala">Bala</option><option value="Bijal">Bijal</option><option value="Bhavya">Bhavya</option></select><span> checked out a </span><select name="type" id="four-template-4" onchange="updateTemplate(this,true)" data-for="output-four-template" autocomplete="off"><option value="empty">ITEM</option><option value="magazine">magazine</option><option value="book">book</option><option value="movie">movie</option></select><span> from the library.</div>
<div class='output-box' data-text='' id='output-four-template' data-blanks='four-template-1,four-template-2,four-template-3,four-template-4' data-template='four-template' data-section='doubleTemplate'></div>

<button id="doubleTemplate-button" onclick="parentSection(this).dataset.state='X'+parentSection(this).dataset.state; state.push('ruleTemplate'); redrawSections();">Continue</button>

</section>

<section id='ruleTemplate' data-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;" data-initial-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;">
<script type="text/javascript">
function ruleTemplateRedraw(sectionState) {
  const template = document.getElementById('four-rules-template');
  var sectionData = document.getElementById('ruleTemplate').dataset;
  const stateArray = sectionData.state.split(";");
  template.dataset.tree = stateArray[0];
  template.dataset.selected = stateArray[1];
  drawMyTemplate(template);
  const output = document.getElementById('output-four-rules-template');
  const outString = readString(stateArray[0],['Andy','Alex','Ari','Bala','Bijal','Bhavya','magazine','book','movie','checked','out','a','from','the','library','and','library.']);
  if (outString[0] == false) {
    if (output.dataset.text != outString[1]) {
      output.dataset.text = outString[1];
      if (sectionData.state.slice(sectionData.state.length-3,sectionData.state.length) != "..." && sectionData.state.slice(-1) != "X") {
        sectionData.state = sectionData.state + '.';
        //alert(sectionState);
      }
    }
  } else {
    output.dataset.text = "";
  }
  drawBox(output);
  if (sectionData.state.slice(sectionData.state.length-3,sectionData.state.length) == "...") {
    document.getElementById('ruleTemplate-button').style.display = 'block';
  } else {
    document.getElementById('ruleTemplate-button').style.display = 'none';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('ruleTemplate',ruleTemplateRedraw);
</script>
<p>As before, we can choose each option freely from a fixed list. However, the template above repeats some information: The same items (magazines, books, and movies) are available to both families, so each of those items is listed twice.</p>

<p>A CFG removes this repetition. We include all of the ITEM options in a list separately from the template, then refer to that list in the template. We&rsquo;ll use the following list of options for our template:</p>

<div class='tree-rules' data-rules='ITEM>magazine,ITEM>book,ITEM>movie' id='items-separate-rule-example'></div>

<p>We often refer to options like these as &ldquo;rules&rdquo;. In these rules, we see a label for a blank position in ALL CAPITAL LETTERS (on the left side), followed by a right arrow &lsquo;&rarr;&rsquo;, followed by an option that can be written into a blank position with that label (on the right side). You can read these aloud using the word &ldquo;becomes&rdquo; for the arrow &lsquo;&rarr;&rsquo;. The first rule would be read as &ldquo;ITEM becomes magazine&rsquo;.</p>

<p>We often shorten a list of rules that have the same label on the left side using the following notation:</p>

<div class='tree-rules' data-rules='ITEM>magazine|book|movie' id='items-rule-example'></div>

<p>Here, the vertical bar character &lsquo;|&rsquo; is used to separate multiple options. Read it out loud as &ldquo;or&rdquo;. The rules listed above can be read aloud as &ldquo;ITEM becomes magazine or book or movie&rdquo;, indicating all of the different options that can be used to fill a blank position with the label &lsquo;ITEM&rsquo;.</p>

<p>The template for the Alves and Biswas families is repeated below, this time in the new format. Each blank position is underlined and has a label underneath it, which is used to identify the rules which can be used to fill in that blank position (similarly to the word game <a href='https://www.madlibs.com/'>Mad Libs</a>). In order to generate a string, select each of the blank positions in the template in turn, then use the buttons in the rules listed below the template to fill them in.<span class='collapse-note' data-label='Controls'>You may select the blank positions by clicking on them, or by focusing them with your keyboard and pressing Space or Enter. Once a blank position has been selected (visually represented by a blue color and solid outline), navigate to the following rules and press one of the buttons to the right of the label which matches the label under the blank position you selected.<span class='collapse-note'>Screenreader users should note that the template is represented as a table, with text in the first row and blank labels in the second row. The buttons to select the blank positions are found inside the cells with the labels, in the second row. Later templates will include more than two rows, but the lowest level of blank labels will always be found on the last row.</span> The template is limited to one line, so you will need to scroll to the left and right in order to see all parts of the template.</span> As before, generate a few strings in order to contrast this process with the previous template.</p>

<style>
.table-button {
  position: absolute;
  left: -2%;
  width: 104%;
  left: calc(-.1em);
  width: calc(100% + .2em);
  height: 100%;
  border-style: dashed;
  border-width: 1px;
  border-color: gray;
  background: transparent;
}
.dark-mode .table-button {
    background: transparent;
}

.selection-color { color: #005AA3; }
.dark-mode .selection-color { color: #249CFF; }
.table-button.selected {
  border-style: solid;
  background: rgba(0,90,163,.2);
}
.dark-mode .table-button.selected {
  background: rgba(36, 136, 255, 0.4);
}
.table-button:hover {background: rgba(0,0,0,.1)}
.dark-mode .table-button:hover {background: rgba(256,256,256,.2)}
.table-button.selected:hover {background: rgba(0,60,130,.28)}
.dark-mode .table-button.selected:hover {background: rgba(70, 150, 255, 0.45);}
.table-button:active {background: rgba(0,0,0,.2)}
.dark-mode .table-button:active {background: rgba(256,256,256,.3)}
.table-button.selected:active {background: rgba(0,30,90,.36)}
.dark-mode .table-button.selected:active {background: rgba(0, 100, 220, 0.45)}
</style>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='ALVES,BISWAS,ITEM' data-index='0' id='four-rules-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='ALVES>Andy|Alex|Ari,BISWAS>Bala|Bijal|Bhavya,ITEM>magazine|book|movie' data-index='0' id='four-rules'></div>

<div class='output-box' data-text='' id='output-four-rules-template'></div>

<button id="ruleTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('nestingTemplate'); redrawSections();">Continue</button>

</section>

<section id='nestingTemplate' data-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;" data-initial-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;">
<script type="text/javascript">
function nestingTemplateStart(sectionState) {
  var seed = parseInt(document.getElementById('frontmatter').dataset.state,10);
  const alves = ['Andy','Alex','Ari'];
  const biswas = ['Bala','Bijal','Bhavya'];
  const item = ['book','movie'];
  const genre = ['fiction','nonfiction','children\u2019s'];
  targetString = "Andy checked out a fiction book from the library and Bala checked out a nonfiction movie from the library.";
  targetString = substitute(alves,permuteIndices(Math.floor(seed/12),alves),substitute(biswas,permuteIndices(Math.floor(seed/36),biswas),substitute(item,permuteIndices(Math.floor(seed/6),item),substitute(genre,permuteIndices(seed,genre),targetString))));
  document.getElementById('nesting-target').innerText = targetString;
}
function nestingTemplateRedraw(sectionState) {
  const template = document.getElementById('nesting-rules-template');
  var sectionState = document.getElementById('nestingTemplate').dataset.state;
  const stateArray = sectionState.split(";");
  template.dataset.tree = stateArray[0];
  template.dataset.selected = stateArray[1];
  drawMyTemplate(template);
  const output = document.getElementById('output-nesting-rules-template');
  const outString = readString(stateArray[0],['Andy','Alex','Ari','Bala','Bijal','Bhavya','magazine','book','movie','checked','out','a','from','the','library','and','library.','fiction','nonfiction','children\u2019s']);
  if (outString[0] == false) {
    output.dataset.text = outString[1];
  } else {
    output.dataset.text = "";
  }
  drawBox(output);
  if (outString[1] == document.getElementById('nesting-target').innerText) {
    disableButtons(document.getElementById('nesting-rules'));
    if (sectionState.charAt(sectionState.length-1) != "X") {
        document.getElementById('nestingTemplate-button').style.display = 'block';
    } else {
        document.getElementById('nestingTemplate-button').style.display = 'none';
    }
    document.getElementById('nesting-output').style.display = 'none';
  } else if (output.dataset.text == "") {
    enableButtons(document.getElementById('nesting-rules'));
    document.getElementById('nestingTemplate-button').style.display = 'none';
    document.getElementById('nesting-output').style.display = 'none';
  } else {
    enableButtons(document.getElementById('nesting-rules'));
    document.getElementById('nestingTemplate-button').style.display = 'none';
    disagree = [...output.dataset.text].findIndex((chr, i) => chr !== document.getElementById('nesting-target').innerText[i]);
    if (disagree == 1) {
        document.getElementById('nesting-output').innerText = "Which Alves family member went to the library?";
    } else if (disagree < 35) {
        document.getElementById('nesting-output').innerText = "What did the Alves family member check out?";
    } else if (disagree < 60) {
        document.getElementById('nesting-output').innerText = "Which Biswas family member went to the library?";
    } else {
        document.getElementById('nesting-output').innerText = "What did the Biswas family member check out?";
    }
    document.getElementById('nesting-output').style.display = 'block';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('nestingTemplate',nestingTemplateRedraw);
sectionStarts.set('nestingTemplate',nestingTemplateStart);
</script>


<h3>Nesting</h3>
<p>There is one more important ingredient for CFGs.</p>
    
<p>At the library, all magazines are stored together, but the books and movies are divided into different genres. Both books and movies can be fiction, nonfiction, or children&rsquo;s, and the genre of a book or movie must be included in our report.</p>

<p>The following rules include all of the possible items:</p>

<div class='tree-rules' data-rules='ITEM>magazine|fiction book|nonfiction book|children&rsquo;s book|fiction movie|nonfiction movie|children&rsquo;s movie'></div>

<p>Here we use multiple words in each option (which we&rsquo;ve never done before), but the longer options combined with having many more rules has caused the list to extend onto multiple lines. There are so many rules because we have to separately list each combination of genre with books and movies, which is repetitive. We can simplify this nicely with the tools we already have. First, we add in a rule for a new blank label, GENRE:</p>

<div class='tree-rules' data-rules='GENRE>fiction|nonfiction|children&rsquo;s'></div>

<p>Then we write a rule for the label ITEM which has blank positions labeled GENRE on the right side:</p>

<table data-tree='[ITEM] [&rarr;] [magazine] [|] [GENRE] [book] [|] [GENRE] [movie]' data-selected='X' data-index='-1' data-nonterminals='GENRE' data-index='0' id='rule-demo-template' class='template-frame' style='border-spacing:0px'></table>

<p>In order to write this more compactly, we don&rsquo;t include the actual blank position in the rule, and just use the label:</p>

<div class='tree-rules' data-rules='ITEM>magazine|GENRE book|GENRE movie'></div>

<p>This is the new ingredient! We&rsquo;ve never used a blank position on the right side of a rule before. By allowing for this possibility, we&rsquo;ve made CFGs much more powerful. We can now nest one blank position inside another blank position, as many times as we&rsquo;d like.</p>

<p>In the visualization we&rsquo;re using here, putting one blank position inside another blank position adds an extra line to the template, because the inner blank position is serving two roles, both as content inside the outer blank position, as well as a blank position that must be filled in its own right. This means that, in order to read the generated string, you can no longer read across a single line, and instead must jump up to read the content filling the inner blank positions. For example, the genre &lsquo;fiction&rsquo; in the following template appears above the label &lsquo;GENRE&rsquo;, but appears normally in the string generated below.</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='[[ALVES [Ari]] [checked] [out] [a] [ITEM [GENRE [fiction]] book]]' data-selected='X' data-nonterminals='ITEM,ALVES,GENRE' data-index='-1' id='nesting-example' class='template-frame' style='border-spacing:0px'></table></div>

<div class='output-box' data-text='Ari checked out a fiction book' id='output-nesting-example'></div>

<p>In order to complete this section, use the template below to generate the following string: &ldquo;<span id='nesting-target'></span>&rdquo; </p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='ALVES,BISWAS,ITEM,GENRE' data-index='0' id='nesting-rules-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='ALVES>Andy|Alex|Ari,BISWAS>Bala|Bijal|Bhavya,ITEM>magazine|GENRE book|GENRE movie,GENRE>fiction|nonfiction|children&rsquo;s' data-index='0' id='nesting-rules'></div>

<div class='output-box' data-text='' id='output-nesting-rules-template'></div>

<div id='nesting-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<button id="nestingTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('recursiveTemplate'); redrawSections();">Continue</button>

</section>

<section id='recursiveTemplate' data-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;" data-initial-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;">
<script type="text/javascript">
function recursiveTemplateRedraw(sectionState) {
  const template = document.getElementById('recursive-rules-template');
  var sectionState = document.getElementById('recursiveTemplate').dataset.state;
  const stateArray = sectionState.split(";");
  template.dataset.tree = stateArray[0];
  template.dataset.selected = stateArray[1];
  drawMyTemplate(template);
  const output = document.getElementById('output-recursive-rules-template');
  const outString = readString(stateArray[0],['Andy','Alex','Ari','Bala','Bijal','Bhavya','magazine','book','movie','checked','out','a','from','the','library','and','library.','fiction','nonfiction','children\u2019s', 'and']);
  if (outString[0] == false) {
    output.dataset.text = outString[1];
  } else {
    output.dataset.text = "";
  }
  drawBox(output);
  if ((output.dataset.text.match(/ a /g) || []).length == 5) {
    disableButtons(document.getElementById('recursive-rules'));
    if (sectionState.charAt(sectionState.length-1) != "X") {
        document.getElementById('recursiveTemplate-button').style.display = 'block';
    } else {
        document.getElementById('recursiveTemplate-button').style.display = 'none';
    }
    document.getElementById('five-items-output').style.display = 'none';
  } else if (output.dataset.text == "") {
    enableButtons(document.getElementById('recursive-rules'));
    document.getElementById('recursiveTemplate-button').style.display = 'none';
    document.getElementById('five-items-output').style.display = 'none';
  } else {
    enableButtons(document.getElementById('recursive-rules'));
    document.getElementById('five-items-output').style.display = 'block';
    document.getElementById('five-items-output').innerText = 'There are ' + numeralPronunciation((output.dataset.text.match(/ a /g) || []).length) + ' items checked out in your string, not five.';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('recursiveTemplate',recursiveTemplateRedraw);
</script>

<h3>Recursion</h3>
<p>Recursion is a special kind of nesting that is argued to be found in many different natural languages.<span class='collapse-note'>The term &ldquo;recursion&rdquo; is sometimes used more broadly, but its use for CFGs strictly refers to what is also called self-embedding (this name will make more sense later on). As with many ambiguous terms in Linguistics, this word has been the subject of fierce debate, with <a href='https://doi.org/10.1086/431525'>Everett (2005)</a> arguing that the Indigenous Brazilian language Piraha&#771; doesn't include any recursive structures, and that this fact undercuts Noam Chomsky's approach to studying language. A constrasting response is seen in <a href='https://dspace.mit.edu/handle/1721.1/94631'>Nevins, Pesetsky, and Rodrigues (2009)</a>, and the enterprising reader can find many other publications within this debate. All that&rsquo;s relevant here is that there are languages which are modeled well by CFGs with recursion.</span></p>

<p>Before defining recursion, let&rsquo;s look at an example of it. Let&rsquo;s add a single rule to our previous list:</p>

<div class='tree-rules' data-rules='ITEM>ITEM and a ITEM'></div>

<p>Using this rule, we can generate reports in which multiple items were checked out by a single person. Consider the following example:</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='[ALVES [Ari]] [checked] [out] [a] [ITEM [ITEM [magazine]] [and] [a] [ITEM [GENRE [nonfiction]] [movie]]] [from] [the] [library.]' data-selected='X' data-nonterminals='ALVES,BISWAS,ITEM,GENRE' data-index='-1' id='recursion-example' class='template-frame' style='border-spacing:0px'></table></div>

<p>The first blank position labeled ITEM in the template has been filled using our new rule. Each of the two new ITEM blank positions is then filled with a specific item, so that Ari has checked out two items.</p>

<p>In order to complete this section, use the template below to generate a string in which a total of five items are checked out between the two families. (Hint: Make all of the items magazines, to make the template simpler.)</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='ALVES,BISWAS,ITEM,GENRE' data-index='0' id='recursive-rules-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='ALVES>Andy|Alex|Ari,BISWAS>Bala|Bijal|Bhavya,ITEM>magazine|GENRE book|GENRE movie|ITEM and a ITEM,GENRE>fiction|nonfiction|children&rsquo;s' data-index='0' id='recursive-rules'></div>

<div class='output-box' data-text='' id='output-recursive-rules-template'></div>

<div id='five-items-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<button id="recursiveTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('recursiveQuestions'); redrawSections();">Continue</button>

</section>

<section id='recursiveQuestions' data-state='' data-initial-state="">
<script type="text/javascript">
function recursiveQuestionsRedraw(sectionState) {
  for (let i = 1; i <= 2; i++) {
    if (sectionState.length >= i) {
      if (i < 2) {
        document.getElementById('recq'+(i+1)).style.display = 'block';
      }
      document.getElementById('recq'+(i)+'yes').disabled = true;
      document.getElementById('recq'+(i)+'no').disabled = true;
      document.getElementById('recq'+(i)+'submit').style.display = 'none';
      if (sectionState.charAt(i-1) == "y") {
        document.getElementById('recq'+(i)+'yes').checked = true;
        document.getElementById('recq'+(i)+'yes-out').style.display = 'block';
        document.getElementById('recq'+(i)+'no-out').style.display = 'none';
      } else {
        document.getElementById('recq'+(i)+'no').checked = true;
        document.getElementById('recq'+(i)+'yes-out').style.display = 'none';
        document.getElementById('recq'+(i)+'no-out').style.display = 'block';
      }
    } else {
      if (i < 2) {
        document.getElementById('recq'+(i+1)).style.display = 'none';
      }
      document.getElementById('recq'+(i)+'yes').disabled = false;
      document.getElementById('recq'+(i)+'no').disabled = false;
      document.getElementById('recq'+(i)+'yes-out').style.display = 'none';
      document.getElementById('recq'+(i)+'no-out').style.display = 'none';
      document.getElementById('recq'+(i)+'submit').style.display = 'inline';
    }
  }
  if (sectionState.length == 2) {
    document.getElementById('recursiveQuestions-button').style.display = 'block';
  } else {
    document.getElementById('recursiveQuestions-button').style.display = 'none';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('recursiveQuestions',recursiveQuestionsRedraw);
</script>

<p>A CFG template includes <em>recursion</em> when a blank position with some label appears somewhere inside another blank position with the <em>same</em> label. The template above has recursion, because a blank position labeled ITEM appears inside another blank position labeled ITEM.</p>

<div id='recq1'>
<p>Comprehension question: In the CFG above that allows for recursion, we have a rule &lsquo;ITEM &rarr; ITEM and a ITEM&rsquo; that has the same label (&lsquo;ITEM&rsquo;) on both the left and right sides of the arrow. Is it necessary to have a single rule with the same label on the left and right sides of the arrow in order for a CFG to allow for recursion?</p>

<input type="radio" id="recq1yes" name="recq1" value="yes">
<label for="recq1yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="recq1no" name="recq1" value="no">
<label for="recq1no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="recq1submit" onclick="if(document.getElementById('recq1yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('recq1no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}recursiveQuestionsRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='recq1yes-out'>That&rsquo;s not right:</p>

<p id='recq1no-out'>That&rsquo;s right:</p>

<div id='recq2'>
<p>The recursion doesn&rsquo;t need to take place within a single rule application. For example, consider a CFG with the following rules:</p>

<div class='tree-rules' data-rules='ITEM>DOUBLE,DOUBLE>ITEM and a ITEM'></div>

<p>Then I can build the following structure:</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='[ITEM [DOUBLE [ITEM] [and] [a] [ITEM]]]' data-selected='X' data-nonterminals='ITEM,DOUBLE' data-index='-1' id='long-recursion-example' class='template-frame' style='border-spacing:0px'></table></div>

<p>This template includes recursion, since a blank position labeled ITEM appears inside another blank position labeled ITEM, even though it&rsquo;s not done directly.</p>

<p>Comprehension question: Using the template above, is there a fixed limit to the number of items that any individual can check out? We count repetitions of the same item type as multiple items: &ldquo;a magazine and a magazine&rdquo; count as two items.</p>

<input type="radio" id="recq2yes" name="recq2" value="yes">
<label for="recq2yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="recq2no" name="recq2" value="no">
<label for="recq2no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="recq2submit" onclick="if(document.getElementById('recq2yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('recq2no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}recursiveQuestionsRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<div id='recq2yes-out'>
<p>That&rsquo;s not right: If there were such a limit, I could always take a template at that limit, then use the &lsquo;ITEM &rarr; ITEM and a ITEM&rsquo; rule in order to turn one of the items into two items, breaking the limit.</p>
<p>More generally, rules that allow for recursion can allow for the generation of strings with <em>unbounded</em> length. This means that, for any generated string of a certain length, you can always generate a string that is even longer.</p>
</div>

<div id='recq2no-out'>
<p>That&rsquo;s right: You can use the &lsquo;ITEM &rarr; ITEM and a ITEM&rsquo; rule as many times as you want. Bhavya can always check out one more book!</p>
<p>More generally, rules that allow for recursion can allow for the generation of strings with <em>unbounded</em> length. This means that, for any generated string of a certain length, you can always generate a string that is even longer.</p>
</div>

<!--
<div id='recq3'>



<p>Question: Is it possible for a CFG to generate sentences of unbounded length if the rules don&rsquo;t allow for recursion?</p>

<input type="radio" id="recq3yes" name="recq3" value="yes">
<label for="recq3yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="recq3no" name="recq3" value="no">
<label for="recq3no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="recq3submit" onclick="if(document.getElementById('recq3yes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'y';}else if(document.getElementById('recq3no').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+'n';}recursiveQuestionsRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='recq3yes-out'>That's not right: </p>

<p id='recq3no-out'>That's right: </p>
-->

<button id="recursiveQuestions-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('epsilonTemplate'); redrawSections();">Continue</button>


</section>

<section id='epsilonTemplate' data-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;" data-initial-state="[ALVES] [checked] [out] [a] [ITEM] [from] [the] [library] [and] [BISWAS] [checked] [out] [a] [ITEM] [from] [the] [library.];X;;">
<script type="text/javascript">
function epsilonTemplateStart(sectionState) {
  var seed = parseInt(document.getElementById('frontmatter').dataset.state,10);
  const alves = ['Andy','Alex','Ari'];
  const biswas = ['Bala','Bijal','Bhavya'];
  const item = ['book','movie','magazine'];
  var targetString = "Andy checked out a book from the library and Bala checked out a movie and a magazine from the library."
  targetString = substitute(alves,permuteIndices(Math.floor(seed/648),alves),substitute(biswas,permuteIndices(Math.floor(seed/1944),biswas),substitute(item,permuteIndices(Math.floor(seed/108),item),targetString)));
  document.getElementById('epsilon-target').innerText = targetString;
}
function epsilonTemplateRedraw(sectionState) {
  const template = document.getElementById('epsilon-rules-template');
  var sectionState = document.getElementById('epsilonTemplate').dataset.state;
  const stateArray = sectionState.split(";");
  template.dataset.tree = stateArray[0];
  template.dataset.selected = stateArray[1];
  drawMyTemplate(template);
  const output = document.getElementById('output-epsilon-rules-template');
  const outString = readString(stateArray[0],['Andy','Alex','Ari','Bala','Bijal','Bhavya','magazine','book','movie','checked','out','a','from','the','library','and','library.','fiction','nonfiction','children\u2019s','\u03B5']);
  if (outString[0] == false) {
    output.dataset.text = outString[1];
  } else {
    output.dataset.text = "";
  }
  drawBox(output);
  if (outString[1] == document.getElementById('epsilon-target').innerText) {
    disableButtons(document.getElementById('epsilon-rules'));
    if  (sectionState.charAt(sectionState.length-1) != "X") {
        document.getElementById('epsilonTemplate-button').style.display = 'block';
    } else {
        document.getElementById('epsilonTemplate-button').style.display = 'none';
    }
    document.getElementById('epsilon-output').style.display = 'none';
  } else if (output.dataset.text == "") {
    enableButtons(document.getElementById('epsilon-rules'));
    document.getElementById('epsilonTemplate-button').style.display = 'none';
    document.getElementById('epsilon-output').style.display = 'none';
  } else {
    enableButtons(document.getElementById('epsilon-rules'));
    document.getElementById('epsilonTemplate-button').style.display = 'none';
    disagree = [...output.dataset.text].findIndex((chr, i) => chr !== document.getElementById('epsilon-target').innerText[i]);
    libIndex = output.dataset.text.indexOf("library");
    biswasIndex = output.dataset.text.indexOf("B");
    if (disagree == 1) {
        document.getElementById('epsilon-output').innerText = "Which Alves family member went to the library?";
    } else if (disagree < libIndex) {
        document.getElementById('epsilon-output').innerText = "What did the Alves family member check out?";
    } else if (disagree == biswasIndex + 1) {
        document.getElementById('epsilon-output').innerText = "Which Biswas family member went to the library?";
    } else {
        document.getElementById('epsilon-output').innerText = "What did the Biswas family member check out?";
    }
    document.getElementById('epsilon-output').style.display = 'block';
  }
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('epsilonTemplate',epsilonTemplateRedraw);
sectionStarts.set('epsilonTemplate',epsilonTemplateStart);
</script>

<h3>Extra notation</h3>
<p>In this section, I add two special rules to our definition. The first adds a new option to our toolbox, while the second changes an assumption we were already using.</p>
<p>First, the new tool: Sometimes you may want to define a rule in which you&rsquo;re allowed to leave a blank position empty. For example, if a GENRE blank position could be left empty, then we can generate reports in which the genre of a book or movie is unstated.</p>
<p>A natural way to write this is to leave the right side of a rule blank:</p>
<div class='tree-rules' data-rules='GENRE>'></div>
<p>However, this is not done because it can be confusing, especially in the template itself (is the blank position left empty because that&rsquo;s what we want, or because we&rsquo;re not done yet?) Instead, we write this possibility with a special symbol: the Greek letter &epsilon; (called &ldquo;epsilon&rdquo;).<span class='collapse-note'> Different people may use different symbols, depending on the context. The most common alternatives to &epsilon; are the Greek letter &lambda; (called &ldquo;lambda&rdquo;), the number 1, and capital letter I.</span> </p>
<div class='tree-rules' data-rules='GENRE>fiction|nonfiction|children&rsquo;s|&epsilon;'></div>
<p>We include this symbol in rules and in the template, but not in the generated strings. Below is a short template that uses &epsilon;, along with the string it generates, which doesn&rsquo;t include &epsilon;.</p>


<div style="width: 100%;overflow-x:scroll;"><table data-tree='[[ALVES [Ari]] [checked] [out] [a] [ITEM [GENRE [&epsilon;]] book]]' data-selected='X' data-nonterminals='ITEM,ALVES,GENRE' data-index='-1' id='epsilon-example' class='template-frame' style='border-spacing:0px'></table></div>

<div class='output-box' data-text='Ari checked out a book' id='output-epsilon-example'></div>

<p>To complete this section, generate the string &ldquo;<span id='epsilon-target'></span>&rdquo; using the template below.</p>


<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='ALVES,BISWAS,ITEM,GENRE' data-index='0' id='epsilon-rules-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='ALVES>Andy|Alex|Ari,BISWAS>Bala|Bijal|Bhavya,ITEM>magazine|GENRE book|GENRE movie|ITEM and a ITEM,GENRE>fiction|nonfiction|children&rsquo;s|&epsilon;' data-index='0' id='epsilon-rules'></div>

<div class='output-box' data-text='' id='output-epsilon-rules-template'></div>

<div id='epsilon-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<button id="epsilonTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('startSTemplate'); redrawSections();">Continue</button>

</section>

<section id='startSTemplate' data-state="" data-initial-state="">
<script type="text/javascript">
function startSTemplateRedraw(sectionState) {
    inputBox = document.getElementById('s-input')
    inputBox.dataset.text = sectionState.split(";")[0];
  if (sectionState != "" && sectionState.charAt(sectionState.length-1) != "X") {
    document.getElementById('startSTemplate-button').style.display = 'block';
    document.getElementById('s-output').style.display = 'block';
    document.getElementById('s-output').style.borderColor = 'rgb(0,150,0)';
    document.getElementById('s-output').innerText = 'Correct!';
  } else {
    document.getElementById('startSTemplate-button').style.display = 'none';
    document.getElementById('s-output').style.display = 'none';
  }
  if (sectionState == "") {
    document.getElementById('startS-submit-button').style.display = 'block';
    enableButtons(document.getElementById('s-labels'));
    inputBox.dataset.editing = 'true';
  } else {
    document.getElementById('startS-submit-button').style.display = 'none';
    disableButtons(document.getElementById('s-labels'));
    inputBox.dataset.editing = 'false';
  }
  drawBox(inputBox);
  document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('startSTemplate',startSTemplateRedraw);
</script>

<p>Second, the changed assumption: Above, we defined a CFG using a basic template as well as a set of rules. But that is two different things, and mathematicians always prefer to only have one thing when it can do just as well.<span class='collapse-note'> As well as scientists pretending to be mathematicians.</span></p>

<p>Here, we simplify the definition by requiring that the basic template always be a single blank position with the special label &lsquo;S&rsquo; (think of that as the first letter of &ldquo;Start&rdquo; or &ldquo;Sentence&rdquo;). Then, we include a rule that can fill a blank position labeled S with our original basic template. For the template above, we include the following rule: &lsquo;S &rarr; ALVES checked out a ITEM from the library and BISWAS checked out a ITEM from the library&rsquo;.</p>

<p>This doesn&rsquo;t change anything about how we&rsquo;ve been applying templates, but does make reading them a bit uglier.</p>

<p>To complete this section, read off the string from the template below.<span class='collapse-note' data-label='Controls'> Enter the string into the textbox directly below the template using the buttons directly below the textbox, which include all of the words you&rsquo;ll need, as well as a few extras and a backspace button.</span> After you&rsquo;ve done that, press the &ldquo;Submit&rdquo; button below.</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='[S [ALVES [Ari]] [checked] [out] [a] [ITEM [ITEM [GENRE [&epsilon;]] [book]] [and] [a] [ITEM [GENRE [nonfiction]] [movie]]]' data-selected='X' data-nonterminals='S,ALVES,ITEM,GENRE' data-index='-1' id='notation-example' class='template-frame' style='border-spacing:0px'></table></div>

<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='s-input' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,ALVES,ITEM,GENRE,Andy,Alex,Ari,checked,out,a,fiction,nonfiction,children&rsquo;s,&epsilon;,magazine,book,movie,and' data-for='s-input' id='s-labels' style='margin-bottom:5px'></div>
<div><button type="button" id="startS-submit-button" onclick="sStartFeedback()">Submit</button></div>

<script type="text/javascript">
function sStartFeedback() {
  const nonterminals = ['S','ALVES','ITEM','GENRE'];
  const badwords = ['Andy','Alex','magazine','fiction','children&rsquo;s'];
  const goodwords = ['Ari','checked','out','book','and','nonfiction','movie'];
  const input = document.getElementById('s-input').innerText.split(' ');
  const output = document.getElementById('s-output');
  output.style.display = 'block';
  output.style.borderColor='rgb(150,0,0)';
  for (let i=0; i<nonterminals.length; i++) {
    if (input.includes(nonterminals[i])) {
      output.innerText = 'While the blank label \u2018' + nonterminals[i] + '\u2019 does appear in the template above, it is filled with other words, and so is not included in the generated string. Please try again.';
      return;
    }
  }
  if (input.includes('\u03B5')) {
    output.innerText = 'While the character \u03B5 does appear in the template above, it represents the option of leaving a blank position empty, and so is not included in the generated string. Please try again.';
    return;
  }
  for (let i=0; i<badwords.length; i++) {
    if (input.includes(badwords[i])) {
      output.innerText = 'The word \u201C' + badwords[i] + '\u201D doesn\u2019t appear in the template, so shouldn\u2019t appear in the generated string. Please try again.';
      return;
    }
  }
  for (let i=0; i<goodwords.length; i++) {
    if (!input.includes(goodwords[i])) {
      output.innerText = 'The word \u201C' + goodwords[i] + '\u201D does appear in the template, so should also appear in the generated string. Please try again.';
      return;
    } else if (input.indexOf(goodwords[i])!=input.lastIndexOf(goodwords[i])) {      output.innerText = 'You\u2019ve included the word \u201C' + goodwords[i] + '\u201D too many times. Please try again.';
      return;
    }
  }
  if (input.filter(x => x=='a').length < 2) {
    output.innerText = 'The word \u201Ca\u201D appears in the template twice, so should also appear in the generated string twice. Please try again.';
    return;
  } else if (input.filter(x => x=='a').length > 2) {
    output.innerText = 'You\u2019ve included the word \u201Ca\u201D too many times. Please try again.';
    return;
  }
  if (document.getElementById('s-input').dataset.text != 'Ari checked out a book and a nonfiction movie') {
    alert(document.getElementById('s-input').dataset.text)
    output.innerText = 'Those words are not in the right order. Make sure that you\u2019ve included all of the words in the template from left to right.';
  } else {
    document.getElementById('startSTemplate').dataset.state = document.getElementById('s-input').dataset.text;
    startSTemplateRedraw(document.getElementById('startSTemplate').dataset.state)
  }
}
</script>

<div id='s-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0"></div>

<button id="startSTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+';X'; state.push('templateReview'); redrawSections();">Continue</button>


</section>

<section id='templateReview' data-state="" data-initial-state="">
<script type="text/javascript">
  function templateReviewRedraw(sectionState) {
    if (sectionState == "X") {
      document.getElementById('templateReview-button').style.display = 'none';
    } else {
      document.getElementById('templateReview-button').style.display = 'block';
    }
  }
  sectionRedraws.set('templateReview',templateReviewRedraw);
</script>
<h3>Review</h3>
<p>At this point it&rsquo;s worth taking stock of what we&rsquo;ve done so far. A CFG is a kind of template that may generate many different strings. A CFG starts with a blank position with a special starting label &lsquo;S&rsquo;, and contains a fixed and limited number of rules, each of which fills a single labeled blank position with any sequence of labeled blank positions and normal words (or nothing at all, represented by the special character &epsilon;). Only one rule may be used to fill any individual blank at a time.</p>
<p>When filling in a template, each choice may be made freely, independently of the surrounding context. When a blank position with some label contains another blank position with the same label, we call that recursion. Recursion may allow us to generate strings that are unboundedly long.</p>
<p>This is a complete and accurate definition of a CFG (if a little informal, compared to the standard mathematical notation.) However, you may be confused if you try to read other materials about CFGs, because I&rsquo;ve presented them to you in a slightly non-standard way. In the following section, you will learn the standard way that they&rsquo;re visually drawn on the page, as well as a few extra vocabulary words that go along with that visual format.</p>
<button id="templateReview-button" onclick="parentSection(this).dataset.state='X'; state.push('treeBasics'); redrawSections();">Continue</button>

</section>

<section id='treeBasics' data-state="" data-initial-state="">
<script type="text/javascript">
    function treeBasicsStart(sectionState) {
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10));
        

        const questionTrees = ['[R [S [U] [Center [X [Z]]] [V [Y]]] [T [W]]]','[R [S [U] [V [X]] [Center [Y [Z]]]] [T [W]]]','[R [S [U]] [T [Center [X [Z]]] [V [Y]] [W]]]','[R [S [U]] [T [V [X]] [Center [Y [Z]]] [W]]]'];
        var questionTreeString = questionTrees[Math.floor(seed/100000)%4];
        //var questionTreeString = '[R [S [U [W]] [Center [X [Z]] [Y]]] [T [V]]]';
        //questionTreeString = substitute(letterArray,permuteIndices(seed,letterArray),questionTreeString);
        document.getElementById("relations-question-tree").dataset.tree = questionTreeString;
    }
    function treeBasicsRedraw(sectionState) {
        drawTrees(document.getElementById("relations-example-tree"));
        drawTrees(document.getElementById("relations-question-tree"));
        const stateArray = sectionState.split(';');
        // This is for the relation selection bit
        if (stateArray.length > 0 && stateArray[0] != '') {
            //Array.from(document.getElementById('checkbox-table').querySelectorAll('input[type="checkbox"]').forEach((element) => {element.disabled = true;element.checked = (stateArray[0].includes(element.value));}));
            Array.from(document.getElementById('checkbox-table').querySelectorAll('input[type="checkbox"]')).forEach((element) => {element.disabled = true;element.checked = (stateArray[0].includes(element.value));});
            document.getElementById('relations-output').style.display = 'block';
            document.getElementById('relations-output').style.borderColor = 'rgb(0,150,0)';
            document.getElementById('relations-output').innerText = 'Correct!';
            document.getElementById('relation-questions-submit-button').style.display = 'none';
            document.getElementById('relations-q2').style.display = 'block';
        } else {
            Array.from(document.getElementById('checkbox-table').querySelectorAll('input[type="checkbox"]')).forEach((element) => {element.disabled = false;});
            document.getElementById('relations-output').style.display = 'none';
            document.getElementById('relations-q2').style.display = 'none';
            document.getElementById('relation-questions-submit-button').style.display = 'block';
        }
        if (stateArray.length > 1) {
            
            document.getElementById('relations-exit').style.display='block';
            document.getElementById('tqsubmit').style.display = 'none';
            document.getElementById('tqyes').disabled = true;
            document.getElementById('tqno').disabled = true;
            if (stateArray[1] == 'y') {
                document.getElementById('tqyes').checked = true;
                document.getElementById('tqno-out').style.display='none';
                document.getElementById('tqyes-out').style.display='block';
            } else {
                document.getElementById('tqno').checked = true;
                document.getElementById('tqyes-out').style.display='none';
                document.getElementById('tqno-out').style.display='block';
            }
        } else {
            document.getElementById('tqno-out').style.display='none';
            document.getElementById('tqyes-out').style.display='none';
            document.getElementById('relations-exit').style.display='none';
            document.getElementById('tqsubmit').style.display = 'block';
            document.getElementById('tqyes').disabled = false;
            document.getElementById('tqno').disabled = false;
        }
        if (stateArray.length > 2) {
            document.getElementById('treeBasics-button').style.display = 'none'
        } else {
            document.getElementById('treeBasics-button').style.display = 'block'
        }
        
        drawTrees(document.getElementById("modify-example-tree"));
        drawTrees(document.getElementById("modify-example-forest"));

        document.getElementById('banner-out').innerText = getSectionStates();
        
    }
    sectionStarts.set('treeBasics',treeBasicsStart);
    sectionRedraws.set('treeBasics',treeBasicsRedraw);
</script>

<h3>Trees</h3>

<p>In order to match the standard presentation of CFGs, we need to flip our visualization on its head, and treat CFGs as <em>trees</em> instead of templates.</p>
<p>These trees grow down the page, with their roots at the top and their leaves at the bottom. This is the usual way that family trees are drawn, and you will see that this analogy motivates some vocabulary later on.</p>
<p>Trees are made up of <em>nodes</em> connected with <em>edges</em>. Each node is just a piece of text (usually a word or abbreviation), and each edge is just a line between a <em>higher</em> node and a <em>lower</em> node. </p>
<p>We use the analogy of a family tree in order to describe relationships between nodes in the tree. If there is an edge between two nodes, then the higher node is the <em>parent</em> node, and the lower node is the <em>child</em> node. If two nodes share a parent node, then they are <em>sibling</em> nodes.</p>

<p>Below is an example of a tree containing six nodes with labels &lsquo;A&rsquo; through &lsquo;F&rsquo;.<span class="collapse-note" data-label='Controls'> For screenreader users: While any tree is in focus, you can navigate its nodes using the keyboard. The up arrow will take you from a node to its parent node. The left and right arrows will take you from a node to its siblings directly to the left or right. The down arrow will take you from a node to its leftmost child. For later trees, you may be able to select nodes using the Enter or Spacebar keys.</span></p>

<div><svg viewbox='0 0 150 140' width='150' height='140' data-tree='[A [B] [C [E] [F]] [D]]' id='relations-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>Select a node from the dropdown menu below in order to read a description of its relations to the other nodes in the tree.</p>

<p><select name="node-selector" id="node-selector" onchange="
{
    const values = ['Node \u2018A\u2019 has no parent nodes, because there are no edges going up from it. This means that it has no sibling nodes, because nothing can share a parent with it. There are three edges going down from it to nodes \u2018B\u2019, \u2018C\u2019, and \u2018D\u2019, and so \u2018A\u2019 has those three child nodes. Even though nodes \u2018E\u2019 and \u2018F\u2019 are below it, there is no single edge connecting it to them, and so there is no parent-child relation between them.',
    'Node \u2018B\u2019 has an edge going up from it to \u2018A\u2019, and so has parent node \u2018A\u2019. Because nodes \u2018C\u2019 and \u2018D\u2019 also have parent node \u2018A\u2019, node \u2018B\u2019 has them both as its sibling nodes (to its right). There are no edges going down from it, so it has no child nodes, even though nodes \u2018E\u2019 and \u2018F\u2019 are below it.',
    'Node \u2018C\u2019 has an edge going up from it to \u2018A\u2019, and so has parent node \u2018A\u2019. Because nodes \u2018B\u2019 and \u2018D\u2019 also have parent node \u2018A\u2019, node \u2018C\u2019 has them both as its sibling nodes (to its left and right, respectively). There are two edges going down from it to nodes \u2018E\u2019 and \u2018F\u2019, and so \u2018C\u2019 has those two child nodes.',
    'Node \u2018D\u2019 has an edge going up from it to \u2018A\u2019, and so has parent node \u2018A\u2019. Because nodes \u2018B\u2019 and \u2018C\u2019 also have parent node \u2018A\u2019, node \u2018D\u2019 has them both as its sibling nodes (to its left). There are no edges going down from it, so it has no child nodes, even though nodes \u2018E\u2019 and \u2018F\u2019 are below it.',
    'Node \u2018E\u2019 has an edge going up from it to \u2018C\u2019, and so has parent node \u2018C\u2019. Because node \u2018F\u2019 also has parent node \u2018C\u2019, node \u2018E\u2019 has it as its sibling node (to its right). There are no edges going down from it, so it has no child nodes.',
    'Node \u2018F\u2019 has an edge going up from it to \u2018C\u2019, and so has parent node \u2018C\u2019. Because node \u2018E\u2019 also has parent node \u2018C\u2019, node \u2018F\u2019 has it as its sibling node (to its left). There are no edges going down from it, so it has no child nodes.'];
    const nodeNames = ['a','b','c','d','e','f'];
    document.getElementById('node-selector-text').innerText = values[nodeNames.indexOf(document.getElementById('node-selector').value)];
}
" autocomplete="off"><option value="a">Node &lsquo;A&rsquo;</option><option value="b">Node &lsquo;B&rsquo;</option><option value="c">Node &lsquo;C&rsquo;</option><option value="d">Node &lsquo;D&rsquo;</option><option value="e">Node &lsquo;E&rsquo;</option><option value="f">Node &lsquo;F&rsquo;</option></select>: <span id="node-selector-text">Node &lsquo;A&rsquo; has no parent nodes, because there are no edges going up from it. This means that it has no sibling nodes, because nothing can share a parent with it. There are three edges going down from it to nodes &lsquo;B&rsquo;, &lsquo;C&rsquo;, and &lsquo;D&rsquo;, and so &lsquo;A&rsquo; has those three child nodes. Even though nodes &lsquo;E&rsquo; and &lsquo;F&rsquo; are below it, there is no single edge connecting it to them, and so there is no parent-child relation between them.</span></p>

<p>Consider the following tree. There is a node labeled &lsquo;Center&rsquo; in the middle of it, with the rest labeled &lsquo;R&rsquo; through &lsquo;Z&rsquo;. For each listed relation, indicate which of the other nodes in the tree have that relation to the Center node.</p>

<div><svg viewbox='0 0 280 210' width='280' height='210' data-tree='[R [S [U [W]] [Center [X [Z]] [Y]]] [T [V]]]' id='relations-question-tree' class='tree-frame' data-select-lock='true'></svg></div>

<style>
#checkbox-table td {
  padding-right: 2em;
}
</style>

<table id="checkbox-table">
    <tr>
        <td>Parents:</td>
        <td><input type="checkbox" id="parents-R" name="parents" value="R"/>
        <label for="parents-R">R</label></td>
        <td><input type="checkbox" id="parents-S" name="parents" value="S"/>
        <label for="parents-S">S</label></td>
        <td><input type="checkbox" id="parents-T" name="parents" value="T"/>
        <label for="parents-T">T</label></td>
    </tr>
    <tr>
        <td>Sibling(s):</td>
        <td><input type="checkbox" id="siblings-U" name="siblings" value="U"/>
        <label for="siblings-U">U</label></td>
        <td><input type="checkbox" id="siblings-V" name="siblings" value="V"/>
        <label for="siblings-V">V</label></td>
        <td><input type="checkbox" id="siblings-W" name="siblings" value="W"/>
        <label for="siblings-W">W</label></td>
    </tr>
    <tr>
        <td>Child(ren):</td>
        <td><input type="checkbox" id="children-X" name="children" value="X"/>
        <label for="children-X">X</label></td>
        <td><input type="checkbox" id="children-Y" name="children" value="Y"/>
        <label for="children-Y">Y</label></td>
        <td><input type="checkbox" id="children-Z" name="children" value="Z"/>
        <label for="children-Z">Z</label></td>
    </tr>
</table>


<div><button type="button" id="relation-questions-submit-button" onclick="
{
    const treeString = document.getElementById('relations-question-tree').dataset.tree;
    let parentsKey = ['S']
    if (treeString.split('Center')[0].includes('T')) {
        parentsKey = ['T'];
    }
    let siblingsKey = ['V','W'];
    if (treeString.split('T')[0].includes('V')) {
        siblingsKey = ['U','V'];
    }
    const childrenKey = [treeString[treeString.indexOf('Center') + 8]];
    const output = document.getElementById('relations-output');
    output.style.display = 'block';
    output.style.borderColor='rgb(150,0,0)';

    inputParents = Array.from(document.querySelectorAll('input[name=\'parents\']:checked')).map((elem) => elem.value);
    inputSiblings = Array.from(document.querySelectorAll('input[name=\'siblings\']:checked')).map((elem) => elem.value);
    inputChildren = Array.from(document.querySelectorAll('input[name=\'children\']:checked')).map((elem) => elem.value);
    if (parentsKey.toString() != inputParents.toString()) {
        output.innerText = 'You haven\u2019t selected the correct node(s) as the parent(s) of the Center. Recall that a node is a parent node of the Center exactly when there is a single edge going directly down from that node to the Center.';
        return;
    }
    if (siblingsKey.toString() != inputSiblings.toString()) {
        output.innerText = 'You haven\u2019t selected the correct node(s) as the sibling(s) of the Center. Recall that a node is a sibling node of the Center exactly when it shares its parent node with the Center (which you\u2019ve correctly identified).';
        return;
    } 
    if (childrenKey.toString() != inputChildren.toString()) {
        output.innerText = 'You haven\u2019t selected the correct node(s) as the child(ren) of the Center. Recall that a node is a child node of the Center exactly when there is single edge going directly down from the Center to that node.';
        return;
    }
    document.getElementById('treeBasics').dataset.state = inputParents.concat(inputSiblings).concat(inputChildren).join('');
    treeBasicsRedraw(document.getElementById('treeBasics').dataset.state)
}
">Submit</button></div>
<div id='relations-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0"></div>

<div id="relations-q2">
<p>In order for a diagram containing nodes and edges to be a tree, it must meet two strict rules. First, there must be exactly one node in the tree, called the &ldquo;root&rdquo;, which has no parents. That is, there is no edge between it and a higher node: It is the highest node.

<div><svg viewbox='0 0 150 140' width='150' height='140' data-tree='[A [B] [C [D]]]' id='modify-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>In the tree above, the root node is labeled &ldquo;A&rdquo;. If we removed that node and the two edges coming down from it, then the resulting diagram wouldn't be a tree because the two nodes &ldquo;B&rdquo; and &ldquo;C&rdquo; <em>both</em> wouldn't have parent nodes, and so the diagram would have two roots.<span class="collapse-note"> Sometimes a diagram with multiple roots (and so with multiple trees) is called a <em>forest</em>.</span> You can see this diagram below.<span class='collapse-note' data-label="Controls"> For screenreader users: You can switch between parentless root nodes using the left and right arrow keys, in the same way that you can switch between siblings.</span></p>

<div><svg viewbox='0 0 150 90' width='150' height='90' data-tree='[B] [C [D]]' id='modify-example-forest' class='tree-frame' data-select-lock='true'></svg></div>

<p>Second, all nodes in the tree that aren&rsquo;t the root must have exactly one parent.<span class="collapse-note"> Since that parent also has exactly one parent, and <em>that</em> parent also has exactly one parent, all the way up to the root, it must be the case that there is exactly one path of edges leading down from the root node to any other node in the tree. You can never have two branches separate on the way down, then merge back together.</span> In the tree above, if we added an edge from the node labeled &ldquo;B&rdquo; down to &ldquo;D&rdquo;, then the resulting diagram wouldn't be a tree because &ldquo;D&rdquo; would have two parent nodes.</p>



<p>Comprehension question: Think about your own family tree. If we draw a diagram where edges are drawn between actual biological parents and children, does this form a tree according to the rules above?</p>

<input type="radio" id="tqyes" name="tq" value="yes">
<label for="tqyes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="tqno" name="tq" value="no">
<label for="tqno" style="margin:0 2em 0 0">No</label>
<button type="submit" id="tqsubmit" onclick="if(document.getElementById('tqyes').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+';y';}else if(document.getElementById('tqno').checked){parentSection(this).dataset.state=parentSection(this).dataset.state+';n';}treeBasicsRedraw(parentSection(this).dataset.state);">Submit</button>
</div>

<p id='tqno-out'>That&rsquo;s right: The family tree doesn&rsquo;t match the tree definition above. Putting aside the question of a root, it is clear that all nodes will have two parents, while nodes in our trees can only have one.</p>

<p id='tqyes-out'>That&rsquo;s not right: The family tree doesn&rsquo;t match the tree definition above. Putting aside the question of a root, it is clear that all nodes will have two parents, while nodes in our trees can only have one.</p>
    
<div id='relations-exit'>

<p>In contrast, most bacteria reproduce by splitting in two, and so only have one parent. The family tree for an individual bacterium will be a tree based on the definition above, although if we look at two unrelated bacteria, we may end up with multiple roots.</p>

<button id="treeBasics-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+';X'; state.push('treeTemplate'); redrawSections();">Continue</button>

</div>




</section>

<section id='treeTemplate' data-state="[S];X;;[S];X;;" data-initial-state="[S];X;;[S];X;;">
<script type="text/javascript">
    function treeTemplateStart(sectionState) {
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/1889568);
        const target = ["[S [A [A [t]] [B [o]]] [A [t] [o]]]",
                        "[S [A [t] [o]] [A [A [t]] [B [o]]]]",
                        "[S [A [t]] [B [B [o]] [A [t] [o]]]]",
                        "[S [A [t]] [B [B [o] [t]] [B [o]]]]",
                        "[S [A [A [t]] [B [o] [t]]] [B [o]]]",
                        "[S [A [A [t] [o]] [A [t]]] [B [o]]]"][seed%6];
        document.getElementById("match-tree").dataset.tree = target;
    }
    function treeTemplateRedraw(sectionState) {
        const stateArray = document.getElementById('treeTemplate').dataset.state.split(";");
        const template = document.getElementById('parallel-tree-template');
        template.dataset.tree = stateArray[0];
        template.dataset.selected = stateArray[1];
        drawMyTemplate(template);
        const tree = document.getElementById('parallel-tree');
        tree.dataset.tree = stateArray[0];
        drawTrees(tree);
        drawTrees(document.getElementById('rule-example-tree'));

        const template2 = document.getElementById('match-tree-template');
        template2.dataset.tree = stateArray[3];
        template2.dataset.selected = stateArray[4];
        drawMyTemplate(template2);
        const tree2 = document.getElementById('match-tree');
        drawTrees(tree2);

        if (template2.dataset.tree == tree2.dataset.tree && stateArray[6] == "") {
            const section = document.getElementById("treeTemplate")
            section.dataset.state = section.dataset.state + ".";
            stateArray[6] = ".";
        }

        if (stateArray[6].length > 0) {
            disableButtons(document.getElementById("match-tree-rules"));
        } else {
            enableButtons(document.getElementById("match-tree-rules"));
        }
        
        if (stateArray[6].length == 1) {
            document.getElementById('treeTemplate-button').style.display = 'block';
        } else {
            document.getElementById('treeTemplate-button').style.display = 'none';
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('treeTemplate',treeTemplateRedraw);
    sectionStarts.set('treeTemplate',treeTemplateStart);
</script>
<h3>Trees and templates</h3>

<p>Now that we've defined trees, how can we use them instead of templates to visualize CFGs?</p>

<p>Instead of starting a template with a single blank position labeled &lsquo;S&rsquo;, a tree starts with a single root node labeled &lsquo;S&rsquo;. Instead of using rules to fill in blank positions in the template, we use rules to add children to nodes in the tree. If we have a rule &lsquo;ITEM &rarr; GENRE book&rsquo;, then we can take a node labeled &lsquo;ITEM&rsquo; with no child nodes and give it two child nodes labeled &lsquo;GENRE&rsquo; and &lsquo;book&rsquo;, in that order. We can only use one rule to add children to any given node, in the same way that we can only choose one option when filling in a blank position. The rule &lsquo;ITEM &rarr; GENRE book&rsquo; is illustrated in tree notation below:</p>

<div><svg viewbox='0 0 150 90' width='150' height='90' data-tree='[ITEM [GENRE] [book]]' id='rule-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>By adding children to nodes starting with &lsquo;S&rsquo; in the same way that we previously filled in blank positions staring with &lsquo;S&rsquo;, we draw a tree which looks very similar to the template, flipped vertically, where an edge is included between two nodes if the child node would have been written directly into the parent node in the equivalent template.</p>


<!-- Original text of this section:
<p>Now that we've defined trees, how do they relate to the templates we were using earlier? We'll look for similarities between trees and templates, and use those to create a recipe for translating between the two visualizations.</p>

<p>There are elements that contain text in both trees and templates. For trees, nodes are labeled with text. For templates, regular words are text, and blank positions are labeled with text. When turning a template into a tree, we'll include a node for every word and for every blank position, and vice versa.</p>

<p>There is a relationship which holds between elements in both trees and templates. For trees, any node may be the parent of many child nodes, but it only has a single parent. For templates, any blank position may be filled with many other blank positions or words, but both blank positions and words only are written directly into a single blank position. When turning a template into a tree, we'll include an edge down from every blank position's node to each of the nodes for the words and blank positions written directly within it, and vice versa. We'll also make sure that the left-to-right ordering of the child nodes of a parent node is the same as the left-to-right ordering of words and blank positions written into a blank position.</p>

<p>This gives us another similarity for free: There is a special starting-point element in both trees and templates. For trees, there is exactly one root node that has no parent node. For templates, there is exactly one starting blank position (labeled &lsquo;S&rsquo;) that has nothing below it. When turning a template into a tree, the rule above means that the starting blank position will become the root node, and vice versa.</p>
-->

<p>As you use the template below, an equivalent tree will automatically be drawn below it, according to the description above. Play around with it to make sure you understand the correspondence between the two different types of diagrams.</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='S,NAME,ALVES,BISWAS,ITEM,GENRE' data-index='0' id='parallel-tree-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='S>NAME checked out a ITEM from the library|S and S,NAME>ALVES|BISWAS,ALVES>Andy|Alex|Ari,BISWAS>Bala|Bijal|Bhavya,ITEM>magazine|GENRE book|GENRE movie|ITEM and a ITEM,GENRE>fiction|nonfiction|children&rsquo;s|&epsilon;' data-index='0' id='parallel-tree-rules'></div>

<div style="width: 100%;overflow-x:scroll;margin:.5em 0"><svg viewbox='0 0 640 180' width='640' height='180' data-tree='' id='parallel-tree' class='tree-frame' data-select-lock='true' data-resize="true"></svg></div>

<p>In order to complete this section, fill in the template below in order to match the tree which follows it. Starting with this problem, we will move away from our library scenario, instead using more abstract CFGs with single-letter labels.</p>

<div style="width: 100%;overflow-x:scroll;"><table data-tree='' data-selected='' data-nonterminals='S,A,B' data-index='3' id='match-tree-template' class='template-frame' style='border-spacing:0px'></table></div>

<div class='rule-buttons' data-rules='S>A A|A B,A>A A|A B|t|t o,B>B B|B A|o|o t' data-index='3' id='match-tree-rules'></div>

<div style="width: 100%;overflow-x:scroll;margin:.5em 0"><svg viewbox='0 0 200 180' width='200' height='180' data-tree='' id='match-tree' class='tree-frame' data-select-lock='true'></svg></div>

<button id="treeTemplate-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('treeVocab'); redrawSections();">Continue</button>

</section>

<section id='treeVocab' data-state=";" data-initial-state=";">
<script type="text/javascript">
  function treeVocabRedraw(sectionState) {
    const valueMap = {
      'nonterm' : 'That\u2019s correct: In the template visualization, we always used ALL CAPITALS for blank position labels, which we now use the term \u2018nonterminal symbols\u2019 for.',
      'root' : 'That\u2019s not correct. While it is true that all root nodes have the label \u2018S\u2019, which is in ALL CAPITALS, it\u2019s only one type of node with that property. In the template visualization, we always used ALL CAPITALS for blank position labels, which we now use the term \u2018nonterminal symbols\u2019 for. Root nodes are a special example of nonterminal nodes.',
      'child' : 'That\u2019s not correct. Any node that\u2019s not a root node is a child node, and looking at the examples above, we see child nodes with all sorts of labels. In the template visualization, we always used ALL CAPITALS for blank position labels, which we now use the term \u2018nonterminal symbols\u2019 for.',
      'term' : 'That\u2019s not correct: Terminal symbols correspond to regular words (recall: terminal nodes are at the ends of the tree, because they cannot be given any child nodes), which we\u2019ve been writing with lowercase letters. In the template visualization, we always used ALL CAPITALS for blank position labels, which we now use the term \u2018nonterminal symbols\u2019 for.'
    }
    const stateArray = sectionState.split(';');
    if (stateArray[0] != '') {
      for (let radio of document.querySelectorAll('input[name="tvq1"]')) {
        radio.disabled = true;
      }
      document.getElementById('tvq1' + stateArray[0]).checked = true;
      document.getElementById('tvq1-out').style.display = 'block';
      document.getElementById('tvq1-out').innerText = valueMap[stateArray[0]];
      document.getElementById('tvq1submit').style.display = 'none';
    } else {
      for (let radio of document.querySelectorAll('input[name="tvq1"]')) {
        radio.disabled = false;
      }
      document.getElementById('tvq1-out').style.display = 'none';
      document.getElementById('tvq1submit').style.display = 'block';
    }
    if (stateArray[1].length == 1) {
      document.getElementById('treeVocab-button').style.display = 'block';
    } else {
      document.getElementById('treeVocab-button').style.display = 'none';
    }
    document.getElementById('banner-out').innerText = getSectionStates();
  }
  sectionRedraws.set('treeVocab',treeVocabRedraw);
</script>
<h3>More tree vocabulary</h3>

<p> We use special terms for describing nodes of the CFG tree. A node corresponding to a blank position is called a <em>nonterminal</em> node, while a node corresponding to a regular word is called a <em>terminal</em> node. Similarly, labels for blank positions are called nonterminal symbols, and regular words are called terminal symbols. When I say <em>terminal</em>, think of the word <em>terminate</em>, which means <em>end</em>. A terminal node is the end of the rule-application process, because you can&rsquo;t use another rule to give it child nodes. A nonterminal node is <em>not</em> the end of the rule-application process, because you must use a rule to give it child nodes.</p>

<div id="tvq1">
<p>Comprehension question: What kind of nodes have we been labeling in ALL CAPITALS?</p>

<input type="radio" id="tvq1root" name="tvq1" value="root">
<label for="tvq1root" style="margin:0 2em 0 0">Root nodes</label><br>
<input type="radio" id="tvq1child" name="tvq1" value="child">
<label for="tvq1child" style="margin:0 2em 0 0">Child nodes</label><br>
<input type="radio" id="tvq1nonterm" name="tvq1" value="nonterm">
<label for="tvq1nonterm" style="margin:0 2em 0 0">Nonterminal nodes</label><br>
<input type="radio" id="tvq1term" name="tvq1" value="term">
<label for="tvq1term" style="margin:0 2em 0 0">Terminal nodes</label><br>
<button type="submit" id="tvq1submit" onclick="
let myName = 'tvq1';
let qs = document.querySelector('input[name=\'tvq1\']:checked');
if (qs != null) {
  parentSection(this).dataset.state = qs.value + ';.';
}
treeVocabRedraw(parentSection(this).dataset.state);
">Submit</button>
</div>

<p id='tvq1-out'>This text should never be displayed</p>

<button id="treeVocab-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('treeGenerateAll'); redrawSections();">Continue</button>

</section>

<section id='treeGenerateAll' data-state=";[S];XX;" data-initial-state=";[S];XX;">
<!--State description: progress;tree;selection; any number of generated strings-->
<script type="text/javascript">
    function treeGenerateAllRedraw(sectionState) {
        const stateArray = document.getElementById('treeGenerateAll').dataset.state.split(";");
        const tree = document.getElementById('generate-all-tree'); 
        tree.dataset.tree = stateArray[1];
        tree.dataset.selected = stateArray[2];
        drawTrees(tree);
        if (stateArray[2] != 'XX') {
            stateArray[3] = tree.dataset.tree.charAt(findNode(tree.dataset.tree, tree.dataset.selected)[0]+1);
        } else {
            stateArray[3] = '';
        }
        const output = document.getElementById('generate-all-output');
        if (!readString(tree.dataset.tree,['t','o','y'])[0]) {
            const outString = readString(tree.dataset.tree,['t','o','y'])[1];
            output.dataset.text = outString;
            if (!stateArray.slice(4).includes(outString) && stateArray.length < 12) {
                stateArray.push(outString);
            }
        } else {
            output.dataset.text = '';
        }
        drawBox(output);
        const outputList = document.getElementById('generate-all-list');
        for (let i = 4; i < stateArray.length; i++) {
            outputList.childNodes.item(1+2*(i-4)).innerText = stateArray[i];
        }
        if (stateArray[0] == '' && stateArray.length == 12) {
            document.getElementById('treeGenerateAll-button').style.display = 'block';
        } else {
            document.getElementById('treeGenerateAll-button').style.display = 'none';
        }

        document.getElementById('treeGenerateAll').dataset.state = stateArray.toString().replace(/,/g,';');
        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('treeGenerateAll',treeGenerateAllRedraw);
</script>

<h2>Practice with CFG trees</h2>

<p>In this section, you will practice working with trees that are generated by different CFGs. These CFGs are abstract, with single-letter symbols, and have been constructed just for these exercises, rather than reflecting any natural language. Once you&rsquo;ve gotten comfortable with the formal properties of CFGs, we will move on to applying them to data and considering their use as models of language.</p>

<h3>Generating strings with trees</h3>

<p>Earlier, you used rules to fill in templates. You would do this by selecting the label of a blank position in a template, then pressing the button of a rule which had that blank position&rsquo;s label on the left side in order to fill in the blank position according to that rule. Below, you will do the same thing with trees. By selecting the node in a tree, then pressing the button of a rule with that node&rsquo;s symbol on the left side, the node will be given child nodes according to that rule.<span class='collapse-note' data-label='Controls'> You can select a node in a tree by either clicking on it, or navigating to it with the keyboard and pressing the Enter or Spacebar keys. Once you have selected a node, you can deselect it by clicking it again, or by clicking on a different node, which will then become selected.</span></p>

<p>An empty tree and a list of rules are included below. When a string of only terminal symbols can be read off of the tree you draw, it will appear in the box below the rules. If you&rsquo;ve never generated that string before, then it will also be added to the empty list below the box. You will complete this section by generating eight different strings.</p>

<div><svg viewbox='0 0 640 300' width='640' height='300' data-tree='' id='generate-all-tree' class='tree-frame' data-index='1' data-resize="true"></svg></div>

<div class='rule-buttons' data-rules='S>A|B A,A>o|y C o,B>A|t,C>y|o A' data-index='1' id='generate-all-rules'></div>

<div class='output-box' data-text='' id='generate-all-output'></div>

<ol id='generate-all-list'>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ol>

<button id="treeGenerateAll-button" onclick="parentSection(this).dataset.state='X'+parentSection(this).dataset.state; state.push('readingTrees'); redrawSections();">Continue</button>
</section>

<section id='readingTrees' data-state=";;;;" data-initial-state=";;;;">
<script type="text/javascript">
    function readingTreesStart(sectionState) {
        var stateArray = sectionState.split(";");
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/1458);
        const nonterms = ['A','B','C'];
        const terms = ['t','o','y'];
        const permNonts = permuteIndices(seed,nonterms);
        const permTerms = permuteIndices(Math.floor(seed/6),terms);
        const outputsList = ['reading-q1-output','reading-q2-output','reading-q3-output','reading-q4-output'];
        for (let i = 0; i < outputsList.length; i++) {
            document.getElementById(outputsList[i]).style.display = "none";
        }
        const inputsList = ['reading-input-1','reading-input-2','reading-input-3','reading-input-4'];
        for (let i = 0; i < inputsList.length; i++) {
            document.getElementById(inputsList[i]).dataset.text = stateArray[i];
            drawBox(document.getElementById(inputsList[i]));
        }
        const trees = ["[S [t] [o] [y]]","[S [A [o]] [B [y] [t]]]","[S [C [y] [y]] [o] [A [t]]]","[S [t] [B [\u03B5]] [C [o]]]"];
        const treeList = ['reading-tree-1','reading-tree-2','reading-tree-3','reading-tree-4'];
        for (let i = 0; i < treeList.length; i++) {
            const myTree = document.getElementById(treeList[i]);
            myTree.dataset.tree = substitute(nonterms,permNonts,substitute(terms,permTerms,trees[i]));
            myTree.dataset.selected = "XX";
        }
    }
    function readingTreesRedraw(sectionState) {
        var stateArray = sectionState.split(";");
        const questionList = ['reading-q1','reading-q2','reading-q3','reading-q4','reading-exit'];
        for (let i = 0; i < questionList.length; i++) {
            if (i <= stateArray[4].length) {
                document.getElementById(questionList[i]).style.display = "block";
                if (i != stateArray[4].length) {
                    disableButtons(document.getElementById(questionList[i]));
                } else {
                    enableButtons(document.getElementById(questionList[i]));
                }
            } else {
                document.getElementById(questionList[i]).style.display = "none";
            }
            
        }
        
        const treeList = ['reading-tree-1','reading-tree-2','reading-tree-3','reading-tree-4'];
        for (let i = 0; i < treeList.length; i++) {
            drawTrees(document.getElementById(treeList[i]));
        }
        if (stateArray[4].charAt(stateArray[4].length-1) == "X") {
            document.getElementById('readingTrees-button').style.display = "none";
        } else {
            document.getElementById('readingTrees-button').style.display = "block";
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('readingTrees',readingTreesRedraw);
    sectionStarts.set('readingTrees',readingTreesStart);
</script>

<h3>Reading trees</h3>

<p>Above, strings of terminal symbols were automatically read off of the trees you drew. Here, you will read the strings off of the trees yourself.</p>

<div id="reading-q1">
<p>Enter the string read off of the tree below.</p>

<div><svg viewbox='0 0 160 100' width='160' height='100' data-tree='' data-index="1" id='reading-tree-1' class='tree-frame' data-select-lock='true'></svg></div>
<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='reading-input-1' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,A,B,C,t,o,y,&epsilon;' data-for='reading-input-1' id='reading-labels-1' style='margin-bottom:5px'></div>

<div><button type="button" onclick="{
let input = document.getElementById('reading-input-1').dataset.text;
let output = document.getElementById('reading-q1-output');
if (input.includes('&epsilon;')) {
    output.innerText = 'That is incorrect. Recall, the special character &epsilon; is used in rules and trees to represent the possibility of leaving a blank position empty, but should not appear in generated strings.';
    output.style.display = 'block';
    return;
}
let inputArray = input.split(' ');
for (let i = 0; i < inputArray.length; i++) {
    if (!document.getElementById('reading-tree-1').dataset.tree.includes(inputArray[i])) {
        output.innerText = 'That is incorrect. You&rsquo;ve included the symbol &lsquo;' + inputArray[i] + '&rsquo;, which is not present in the tree above.';
        output.style.display = 'block';
        return;
    }
}
if (input == '') {
    output.innerText = 'Please enter a string, using the buttons in the toolbar above.';
} else if (input != input.toLowerCase()) {
    output.innerText = 'That is incorrect. You&rsquo;ve included the nonterminal symbol &lsquo;S&rsquo; in your answer, but the node with that label has children in this tree, representing how it is a blank position which has been filled. A filled blank position&rsquo;s label will not be included in the generated string.';
} else if (input != readString(document.getElementById('reading-tree-1').dataset.tree,['t','o','y'])[1]) {
    output.innerText = 'That is incorrect. The root node has three child nodes representing three words which fill the blank position of the root node. The generated string is simply those three words, written left-to-right.';
} else {
    output.style.display = 'none';
    document.getElementById('reading-q2-output').style.display = 'none';
    let stateArray = document.getElementById('readingTrees').dataset.state.split(';');
    stateArray[0] = input;
    stateArray[4] = '.' + stateArray[4];
    document.getElementById('readingTrees').dataset.state = stateArray.toString().replace(/,/g,';');
    sectionRedraws.get('readingTrees')(document.getElementById('readingTrees').dataset.state);
    return;
}
document.getElementById('reading-q1-output').style.display = 'block';}
">Submit</button></div>
<div id='reading-q1-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="reading-q2">
<p>Correct! You just needed to read the terminal symbols in the tree from left to right.</p>

<p>Enter the string read off of the tree below.</p>

<div><svg viewbox='0 0 160 140' width='160' height='140' data-tree='' data-index="3" id='reading-tree-2' class='tree-frame' data-select-lock='true'></svg></div>
<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='reading-input-2' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,A,B,C,t,o,y,&epsilon;' data-for='reading-input-2' id='reading-labels-2' style='margin-bottom:5px'></div>

<div><button type="button" onclick="{
let input = document.getElementById('reading-input-2').dataset.text;
let output = document.getElementById('reading-q2-output');
let tree = document.getElementById('reading-tree-2').dataset.tree;
if (input.includes('&epsilon;')) {
    output.innerText = 'That is incorrect. Recall, the special character &epsilon; is used in rules and trees to represent the possibility of leaving a blank position empty, but should not appear in generated strings.';
    output.style.display = 'block';
    return;
}
let inputArray = input.split(' ');
for (let i = 0; i < inputArray.length; i++) {
    if (!tree.includes(inputArray[i])) {
        output.innerText = 'That is incorrect. You&rsquo;ve included the symbol &lsquo;' + inputArray[i] + '&rsquo;, which is not present in the tree above.';
        output.style.display = 'block';
        return;
    }
}
if (input == '') {
    output.innerText = 'Please enter a string, using the buttons in the toolbar above.';
} else if (input != input.toLowerCase()) {
    output.innerText = 'That is incorrect. You&rsquo;ve included a nonterminal symbol in your answer, but all nonterminal nodes have children in this tree, representing how they are filled blank positions. A filled blank position&rsquo;s label will not be included in the generated string.';
} else if (input.length < 5) {
    output.innerText = 'That is incorrect. There are three terminal nodes in the tree that are included in the generated string, but you haven&lsquo;t included all three.';
} else if (input.split('t').length != 2 || input.split('o').length != 2 || input.split('y').length != 2) {
    output.innerText = 'That is incorrect. Each terminal symbol only occurs once in the tree, but you&rsquo;ve included some symbol more than once.';
} else if (input.charAt(0) != readString(tree,['t','o','y'])[1].charAt(0)) {
    output.innerText = 'That is incorrect. Since the node labeled &lsquo;' + tree.charAt(4) + '&rsquo; is the left sibling of the node labeled &lsquo;' + tree.charAt(12) + '&rsquo;, its child node needs to appear to the left of both children of its sibling.';
} else if (input != readString(tree,['t','o','y'])[1]) {
    output.innerText = 'That is incorrect. The children of the node labeled &lsquo;' + tree.charAt(12) + '&rsquo; are not in the same order in your answer as they are in the tree.';
} else {
    output.style.display = 'none';
    document.getElementById('reading-q3-output').style.display = 'none';
    let stateArray = document.getElementById('readingTrees').dataset.state.split(';');
    stateArray[1] = input;
    stateArray[4] = '.' + stateArray[4];
    document.getElementById('readingTrees').dataset.state = stateArray.toString().replace(/,/g,';');
    sectionRedraws.get('readingTrees')(document.getElementById('readingTrees').dataset.state);
    return;
}
document.getElementById('reading-q2-output').style.display = 'block';}
">Submit</button></div>
<div id='reading-q2-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="reading-q3">
<p>Correct! Even though there were additional nonterminal nodes in this tree, you still only needed to include the three terminal symbols in the tree in the correct order.</p>

<p>Enter the string read off of the tree below.</p>

<div><svg viewbox='0 0 180 140' width='180' height='140' data-tree='' data-index="5" id='reading-tree-3' class='tree-frame' data-select-lock='true'></svg></div>
<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='reading-input-3' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,A,B,C,t,o,y,&epsilon;' data-for='reading-input-3' id='reading-labels-3' style='margin-bottom:5px'></div>

<div><button type="button" onclick="{
let input = document.getElementById('reading-input-3').dataset.text;
let output = document.getElementById('reading-q3-output');
let tree = document.getElementById('reading-tree-3').dataset.tree;
if (input.includes('&epsilon;')) {
    output.innerText = 'That is incorrect. Recall, the special character &epsilon; is used in rules and trees to represent the possibility of leaving a blank position empty, but should not appear in generated strings.';
    output.style.display = 'block';
    return;
}
let inputArray = input.split(' ');
for (let i = 0; i < inputArray.length; i++) {
    if (!tree.includes(inputArray[i])) {
        output.innerText = 'That is incorrect. You&rsquo;ve included the symbol &lsquo;' + inputArray[i] + '&rsquo;, which is not present in the tree above.';
        output.style.display = 'block';
        return;
    }
}
if (input == '') {
    output.innerText = 'Please enter a string, using the buttons in the toolbar above.';
} else if (input != input.toLowerCase()) {
    output.innerText = 'That is incorrect. You&rsquo;ve included a nonterminal symbol in your answer, but all nonterminal nodes have children in this tree, representing how they are filled blank positions. A filled blank position&rsquo;s label will not be included in the generated string.';
} else if (!input.includes(tree.charAt(16))) {
    output.innerText = 'That is incorrect. Even though the node labeled &lsquo;' + tree.charAt(16) + '&rsquo; is not on the same row as the other terminal nodes, it is included in the generated string.';
} else if (input.length != 7) {
    output.innerText = 'That is incorrect. There are four terminal nodes in the tree, but your input doesn&lsquo;t include four words.';
} else if (input.split(tree.charAt(16)).length != 2 || input.split(tree.charAt(23)).length != 2 || input.split(tree.charAt(7)).length != 3) {
    output.innerText = 'That is incorrect. You haven&rsquo;t included each terminal symbol the correct number of times.';
} else if (input != readString(tree,['t','o','y'])[1]) {
    output.innerText = 'That is incorrect. The node labeled &lsquo;' + tree.charAt(16) + '&rsquo; is the right neighbor of the node labeled &lsquo;' + tree.charAt(4) + '&rsquo;, so must be to the right of both of its child nodes, and is the left neighbor of the node labeled &lsquo;' + tree.charAt(20) + '&rsquo;, so must be to the left of its child node.';
} else {
    output.style.display = 'none';
    document.getElementById('reading-q4-output').style.display = 'none';
    let stateArray = document.getElementById('readingTrees').dataset.state.split(';');
    stateArray[2] = input;
    stateArray[4] = '.' + stateArray[4];
    document.getElementById('readingTrees').dataset.state = stateArray.toString().replace(/,/g,';');
    sectionRedraws.get('readingTrees')(document.getElementById('readingTrees').dataset.state);
    return
}
document.getElementById('reading-q3-output').style.display = 'block';}
">Submit</button></div>
<div id='reading-q3-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="reading-q4">
<p>Correct! In this tree, the terminal nodes weren&rsquo;t all lined up on the same row, but you can find the correct order for the terminal symbols by remembering that the order of siblings in the tree must be the same as the order of symbols in the generated string.</p>
<p>Enter the string read off of the tree below.</p>

<div><svg viewbox='0 0 160 140' width='160' height='140' data-tree='' data-index="7" id='reading-tree-4' class='tree-frame' data-select-lock='true'></svg></div>
<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='reading-input-4' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,A,B,C,t,o,y,&epsilon;' data-for='reading-input-4' id='reading-labels-4' style='margin-bottom:5px'></div>

<div><button type="button" onclick="{
let input = document.getElementById('reading-input-4').dataset.text;
let output = document.getElementById('reading-q4-output');
let tree = document.getElementById('reading-tree-4').dataset.tree;
if (input.includes('&epsilon;')) {
    output.innerText = 'That is incorrect. Recall, the special character &epsilon; is used in rules and trees to represent the possibility of leaving a blank position empty, but should not appear in generated strings.';
    output.style.display = 'block';
    return;
}
let inputArray = input.split(' ');
for (let i = 0; i < inputArray.length; i++) {
    if (!tree.includes(inputArray[i])) {
        output.innerText = 'That is incorrect. You&rsquo;ve included the symbol &lsquo;' + inputArray[i] + '&rsquo;, which is not present in the tree above.';
        output.style.display = 'block';
        return;
    }
}
if (input == '') {
    output.innerText = 'Please enter a string, using the buttons in the toolbar above.';
} else if (input != input.toLowerCase()) {
    output.innerText = 'That is incorrect. You&rsquo;ve included a nonterminal symbol in your answer, but all nonterminal nodes have children in this tree, representing how they are filled blank positions. A filled blank position&rsquo;s label will not be included in the generated string.';
} else if (!input.includes(tree.charAt(4))) {
    output.innerText = 'That is incorrect. Even though the node labeled &lsquo;' + tree.charAt(4) + '&rsquo; is not on the same row as the other terminal nodes, it is included in the generated string.';
} else if (input.length != 3) {
    output.innerText = 'That is incorrect. There are two non-&epsilon; terminal nodes in the tree, but your input doesn&lsquo;t include two words.';
} else if (input.split(tree.charAt(4)).length != 2 || input.split(tree.charAt(19)).length != 2) {
    output.innerText = 'That is incorrect. You haven&rsquo;t included each terminal symbol the correct number of times.';
} else if (input != readString(tree,['t','o','y'])[1]) {
    output.innerText = 'That is incorrect. The node labeled &lsquo;' + tree.charAt(4) + '&rsquo; is a left neighbor of the node labeled &lsquo;' + tree.charAt(16) + '&rsquo;, so must be to the left of its child node.';
} else {
    output.style.display = 'none';
    let stateArray = document.getElementById('readingTrees').dataset.state.split(';');
    stateArray[3] = input;
    stateArray[4] = '.' + stateArray[4];
    document.getElementById('readingTrees').dataset.state = stateArray.toString().replace(/,/g,';');
    sectionRedraws.get('readingTrees')(document.getElementById('readingTrees').dataset.state);
    return
}
document.getElementById('reading-q4-output').style.display = 'block';}
">Submit</button></div>
<div id='reading-q4-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="reading-exit">
<p>Correct! As in the last example, the terminal symbols weren&rsquo;t in the same row; additionally, a rule was used which added a node labeled &epsilon; in the tree, which represents leaving a blank position empty, and so which isn&rsquo;t included in the generated string.</p>

<button id="readingTrees-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('ruleFromTree'); redrawSections();">Continue</button>
</div>

</section>

<section id='ruleFromTree' data-state=";" data-initial-state=";">
<script type="text/javascript">
    function ruleFromTreeStart(sectionState) {
        var stateArray = sectionState.split(";");
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/52488);
        const nonterms = ['A','B','C'];
        const terms = ['t','o','y'];
        const permNonts = permuteIndices(seed,nonterms);
        const permTerms = permuteIndices(Math.floor(seed/6),terms);
        document.getElementById('rule-from-tree-tree').dataset.tree = substitute(nonterms,permNonts,substitute(terms,permTerms,'[S [A [t] [C [y]]] [B [o]]]'));
        document.getElementById('rule-from-tree-tree').dataset.startSelected = '00';
        document.getElementById('rule-from-tree-output').style.display = 'none';
    }
    function ruleFromTreeRedraw(sectionState) {
        var stateArray = sectionState.split(";");
        drawTrees(document.getElementById('rule-from-tree-tree'));
        if (stateArray[0].length == 0) {
            enableButtons(document.getElementById('rule-from-tree-labels'));
            document.getElementById('rule-from-tree-submit').disabled = false;
            document.getElementById('ruleFromTree-button').style.display = "none";
        } else {
            document.getElementById('rule-from-tree-box').dataset.text = stateArray[0].replace('>','\u2192');
            drawBox(document.getElementById('rule-from-tree-box'));
            disableButtons(document.getElementById('rule-from-tree-labels'));
            document.getElementById('rule-from-tree-submit').disabled = true;
            document.getElementById('rule-from-tree-output').style.borderColor = 'rgb(0,150,0)';
            document.getElementById('rule-from-tree-output').style.display = "block";
            document.getElementById('rule-from-tree-output').innerText = "Correct!";
            if (stateArray[1].length == 0) {
                document.getElementById('ruleFromTree-button').style.display = "block";
            } else {
                document.getElementById('ruleFromTree-button').style.display = "none";
            }
        }
        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('ruleFromTree',ruleFromTreeRedraw);
    sectionStarts.set('ruleFromTree',ruleFromTreeStart);
</script>

<h3>Identifying rules</h3>

<p>Recall that child nodes are added to a nonterminal node in a CFG tree by using a rule that has the nonterminal node&rsquo;s symbol on the left side, and adding nodes with all of the symbols found on the right side.</p>

<p>The following tree was built using the rules of a CFG. One of the nonterminal nodes in it is highlighted.<span class='collapse-note' data-label='Controls'> For screenreader users, the highlighted node will have the extra label &ldquo;selected&rdquo;</span> Some rule must have been used in order to give it child nodes. In the textbox below the tree, enter the rule which must have been used.</p>

<div><svg viewbox='0 0 180 180' width='180' height='180' data-tree='' id='rule-from-tree-tree' class='tree-frame' data-select-lock='true'></svg></div>
<div class='input-box' data-text='' data-editing="true" data-cursor-index="0" id='rule-from-tree-box' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,A,B,C,t,o,y,&epsilon;,&rarr;' data-for='rule-from-tree-box' id='rule-from-tree-labels' style='margin-bottom:5px'></div>

<div><button type="button" id='rule-from-tree-submit' onclick="
{
    let input = document.getElementById('rule-from-tree-box').dataset.text;
    let output = document.getElementById('rule-from-tree-output');
    let tree = document.getElementById('rule-from-tree-tree').dataset.tree;

    if (!input.includes('&rarr;')) {
        output.innerText = 'That is incorrect. A rule needs to include the symbol &rarr; to separate the left side from the right side.';
    } else if (input.split('&rarr;').length != 2) {
        output.innerText = 'That is incorrect. A rule can only include one copy of the symbol &rarr; to separate the left side from the right side.';
    } else if (input.charAt(2)!='&rarr;' || input.charAt(0) == input.charAt(0).toLowerCase()) {
        output.innerText = 'That is incorrect. The left side of the rule (to the left of the symbol &rarr;) must be exactly one nonterminal character.';
    } else if (input.length <= 3) {
        output.innerText = 'That is incorrect. You must have some sequence of terminal and nonterminal symbols on the right side of the rule.';
    } else if (input.charAt(0) != tree.charAt(4)) {
        output.innerText = 'That is incorrect. The rule used to add child nodes to a nonterminal node must have the nonterminal node&rsquo;s symbol on the left side of the rule, but the nonterminal symbol on the left side of your rule is not the symbol of the highlighted node.';
    } else if (input.includes(tree.charAt(14))) {
        output.innerText = 'That is incorrect. While the node labeled &lsquo;' + tree.charAt(14) + '&rsquo; is a descendant of the highlighted node, it is not a direct parent-child relationship (analogously, it is a grandparent-grandchild relationship). This means that &lsquo;' + tree.charAt(14) + '&rsquo; should not be included in the rule used to add child nodes to the highlighted node.';
    } else if (input.includes(tree.charAt(23))) {
        output.innerText = 'That is incorrect. While the node labeled &lsquo;' + tree.charAt(23) + '&rsquo; is found on the row below the highlighted node, there is no edge between the two, and so they are not in a parent-child relationship. This means that &lsquo;' + tree.charAt(23) + '&rsquo; should not be included in the rule used to add child nodes to the highlighted node.';
    } else if (!validNode(document.getElementById('rule-from-tree-tree'),input.replace(' &rarr; ','>'))) {
        output.innerText = 'That is incorrect. The highlighted node has two children, and so the right side of the rule is simply the symbols of those two children, in left-to-right order.';
    } else {
        output.style.display = 'none';
        document.getElementById('ruleFromTree').dataset.state = input.replace('&rarr;','>')+';';
        sectionRedraws.get('ruleFromTree')(document.getElementById('ruleFromTree').dataset.state);
        return;
    }
    output.style.display = 'block';
}
">Submit</button></div>
<div id='rule-from-tree-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<div style='margin-top:5px'><button id="ruleFromTree-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('badRuleInTree'); redrawSections();">Continue</button></div>

</section>

<section id='badRuleInTree' data-state = '' data-initial-state = ''>
<script type="text/javascript">
function badRuleInTreeStart(sectionState) {
    if (sectionState == "") {
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/1458);
        const nonterms = ['A','B','C'];
        const terms = ['t','o','y'];
        const permNonts = permuteIndices([2,4][seed%2],nonterms);
        const permTerms = permuteIndices([2,4][seed%2],terms);
        let myState = "[S [A [A [t]] [C [C [y]] [B [o]]]] [B [B [B [o]] [C [y]]] [A [t]]] [C [C [y]] [A [A [t]] [B [o]]]]];XX;";
        const substrings = [[17,31],[38,64],[41,56],[70,96],[81,95]];
        const mySub = substrings[Math.floor(seed/2)%5];
        myState = myState.slice(0,mySub[0]) + substitute(nonterms,permNonts,substitute(terms,permTerms,myState.slice(mySub[0],mySub[1]))) + myState.slice(mySub[1]);
        document.getElementById('badRuleInTree').dataset.state = myState;
        document.getElementById('bad-tree').dataset.tree = myState.slice(0,-4);
        document.getElementById('bad-tree-output').style.display = 'none';
    } else {
        document.getElementById('badRuleInTree').dataset.state = sectionState;
        const stateArray = sectionState.split(";");
        document.getElementById('bad-tree').dataset.tree = stateArray[0];
        document.getElementById('bad-tree-output').style.display = 'none';
    }
}
function badRuleInTreeRedraw(sectionState) {
    var stateArray = sectionState.split(";");
    drawTreeRules(document.getElementById("bad-rules"));
    document.getElementById("bad-tree").dataset.selected = stateArray[1];
    drawTrees(document.getElementById("bad-tree"));
    if (stateArray[2].length == 0) {
        document.getElementById('bad-tree').dataset.selectLock = false;
        document.getElementById('bad-tree-submit').disabled = false;
        document.getElementById('badRuleInTree-button').style.display = 'none';
    } else if (stateArray[2].length == 1) {
        document.getElementById('bad-tree').dataset.selectLock = true;
        document.getElementById('bad-tree-submit').disabled = true;
        document.getElementById('badRuleInTree-button').style.display = 'block';
    } else {
        document.getElementById('bad-tree').dataset.selectLock = true;
        document.getElementById('bad-tree-submit').disabled = true;
        document.getElementById('badRuleInTree-button').style.display = 'none';
    }

    document.getElementById('banner-out').innerText = getSectionStates();
}
sectionRedraws.set('badRuleInTree',badRuleInTreeRedraw);
sectionStarts.set('badRuleInTree',badRuleInTreeStart);
</script>
<h3>Identifying bad rules</h3>
<p>A useful skill when working with CFGs is being able to identify when a tree is <em>not</em> consistent with a given set of rules. There are two possible ways for a tree to not be valid: first, the root node may not be labeled &lsquo;S&rsquo; (which is easy to test); second, there may be some node in the tree which has child nodes which could not have been added by any rule in the CFG. To test this, there&rsquo;s nothing to do other than look at each nonterminal node in the tree, identify what rule must have been used to add its child nodes, then check whether that rule is included in the CFG&rsquo;s list of rules.</p>

<p>Below is a CFG and a tree which is not consistent with that CFG. In this exercise, you must select the one nonterminal node in the tree which has child nodes which are not compatible with any rules in the CFG.</p>

<div class='tree-rules' data-rules='S>A B C|B C A|C A B,A>A B|A C|t,B>B A|B C|o,C>C A|C B|y' id='bad-rules' style='margin-bottom:5px'></div>
<div><svg viewbox='0 0 240 180' width='240' height='180' data-tree='' data-index="0" id='bad-tree' class='tree-frame', data-resize='true'></svg></div>

<div><button type="button" id='bad-tree-submit' onclick="
    let rules = document.getElementById('bad-rules').dataset.rules;
    let output = document.getElementById('bad-tree-output');
    let badTree = document.getElementById('bad-tree');

    output.style.borderColor = 'rgb(150,0,0)';
    if (validNode(badTree, rules) == -1) {
        output.innerText = 'Please select a node in the tree above.';
    } else if (validNode(badTree, rules) == 2) {
        output.innerText = 'That is incorrect. The node you selected is a terminal node with no children, and so would be consistent with any CFG.';
    } else if (validNode(badTree, rules) == 1) {
        usedRule = nodeRule(badTree);
        if (usedRule.length == 5) {
            output.innerText = 'That is incorrect. The node you selected has one child node labeled &lsquo;' + usedRule.charAt(4) + '&rsquo;, which is consistent with the rule &lsquo;' + usedRule + '&rsquo; found in the CFG.';
        } else {
            output.innerText = 'That is incorrect. The node you selected has child nodes labeled &lsquo;' + usedRule.slice(4).replaceAll(' ','&rsquo;, &lsquo;') + '&rsquo;, which is consistent with the rule &lsquo;' + nodeRule(badTree) + '&rsquo; found in the CFG.';
        }
    } else {
        output.innerText = 'Correct!';
        output.style.borderColor = 'rgb(0,150,0)';
        document.getElementById('badRuleInTree').dataset.state = document.getElementById('badRuleInTree').dataset.state + '.';
        sectionRedraws.get('badRuleInTree')(document.getElementById('badRuleInTree').dataset.state);
    }
    output.style.display = 'block';
">Submit</button></div>
<div id='bad-tree-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<div style='margin-top:5px'><button id="badRuleInTree-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state+'X'; state.push('labelTrees'); redrawSections();">Continue</button></div>

</section>


<section id='labelTrees' data-state="" data-initial-state="">
<h3>Labeling trees according to rules</h3>
<script type="text/javascript">
    function labelTreesStart(sectionState) {
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/120);
        const nonterms = ['A','B','C'];
        const terms = ['t','o','y'];
        const permNonts = permuteIndices(seed,nonterms);
        const permTerms = permuteIndices(Math.floor(seed/6),terms);
        
        var startRuleArray = ['t A','t B','o B','y C'];
        var moreRulesArray = ['A>t','A>o','A>A A','B>o','B>y','B>C B','C>y','C>B C','C>C C'];
        for (let i = 0; i < startRuleArray.length; i++) {
            startRuleArray[i] = substitute(nonterms,permNonts,substitute(terms,permTerms,startRuleArray[i]));
        }
        startRuleArray.sort();
        for (let i = 0; i < moreRulesArray.length; i++) {
            moreRulesArray[i] = substitute(nonterms,permNonts,substitute(terms,permTerms,moreRulesArray[i]));
        }
        moreRulesArray.sort();
        var rules = "S>";
        for (let i = 0; i < startRuleArray.length; i++) {
            rules = rules + startRuleArray[i] + "|";
        }
        rules = rules.slice(0,rules.length-1) + ",";
        for (let i = 0; i < 3; i++) {
            rules = rules + moreRulesArray[i*3] + "|" + moreRulesArray[i*3+1].slice(2) + "|" + moreRulesArray[i*3+2].slice(2) + ",";
        }
        rules = rules.slice(0,rules.length-1);

        const rulesList = ['label-rules-1','label-rules-2','label-rules-3','label-rules-4','label-rules-5'];
        for (let i = 0; i < rulesList.length; i++) {
            document.getElementById(rulesList[i]).dataset.rules = rules;
            drawTreeRules(document.getElementById(rulesList[i]));
        }
        const outputsList = ['label-q1-output','label-q2-output','label-q3-output','label-q4-output','label-q5-output'];
        for (let i = 0; i < outputsList.length; i++) {
            document.getElementById(outputsList[i]).style.display = "none";
        }
        var explainers = document.getElementById('labelTrees').getElementsByClassName('label-explainer');
        for (let explainer of explainers) {
            explainer.innerText = substitute(nonterms,permNonts,substitute(terms,permTerms,explainer.dataset.base));
        }
        
        if (sectionState == "") {
            // For new time through, not load
            myState = ";[!S [!o] [\u2026 [!o]]];01;[!S [!t] [\u2026 [!t]]];01;[!S [!t] [\u2026 [!y]]];01;[!S [!y] [\u2026 [\u2026 [!o]] [!C [\u2026]]]];XX;[!S [\u2026] [\u2026 [\u2026 [!o]] [\u2026 [!y]]]];XX;"
            myState = substitute(nonterms,permNonts,substitute(terms,permTerms,myState));
            document.getElementById('labelTrees').dataset.state = myState;
        }
    }
    function labelTreesRedraw(sectionState) {
        var stateArray = sectionState.split(";");

        const questionList = ['label-q1','label-q2','label-q3','label-q4','label-q5','label-exit'];
        for (let i = 0; i < questionList.length; i++) {
            if (i <= stateArray[0].length) {
                document.getElementById(questionList[i]).style.display = "block";
                if (i != stateArray[0].length) {
                    disableButtons(document.getElementById(questionList[i]));
                } else {
                    enableButtons(document.getElementById(questionList[i]));
                }
            } else {
                document.getElementById(questionList[i]).style.display = "none";
            }
            
        }
        const treeList = ['label-tree-1','label-tree-2','label-tree-3','label-tree-4','label-tree-5'];
        for (let i = 0; i < treeList.length; i++) {
            
            const myTree = document.getElementById(treeList[i]);
            myTree.dataset.tree = stateArray[1+2*i];
            myTree.dataset.selected = stateArray[2+2*i];
            drawTrees(myTree);
            
        }
        if (stateArray[0].charAt(0) == "X") {
            document.getElementById('labelTrees-button').style.display = "none";
        } else {
            document.getElementById('labelTrees-button').style.display = "block";
        }
        document.getElementById('banner-out').innerText = getSectionStates();
        
    }
    sectionRedraws.set('labelTrees',labelTreesRedraw);
    sectionStarts.set('labelTrees',labelTreesStart);
</script>

<div id="label-q1">
<p>Label the following tree so that it is consistent with the accompanying rules. To change the symbol of a selected node, click on the button corresponding to the desired symbol below the tree.</p>

<div class='tree-rules' data-rules='' id='label-rules-1'></div>
<div><svg viewbox='0 0 160 140' width='160' height='140' data-tree='' data-index="1" id='label-tree-1' class='tree-frame' data-start-selected='01' data-select-lock='true'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B,C' data-terminals='t,o,y' data-index='1' id='label-labels-1'></div>
<div><button type="button" onclick="
if (document.getElementById('label-tree-1').dataset.tree.includes('&mldr;')) {
    document.getElementById('label-q1-output').innerText = 'Please label all nodes in the tree.';
} else if (document.getElementById('label-tree-1').dataset.tree.charAt(10).toLowerCase() == document.getElementById('label-tree-1').dataset.tree.charAt(10)) {
    document.getElementById('label-q1-output').innerText = 'That is incorrect. The node you&rsquo;ve labeled has a child node, which means it must be a nonterminal node. You&rsquo;ve labeled it with a terminal symbol.';
} else if (frameErrors(document.getElementById('label-tree-1'), document.getElementById('label-rules-1').dataset.rules)[0] == 0) {
    document.getElementById('label-q1-output').style.display = 'none';
    document.getElementById('label-q2-output').style.display = 'none';
    document.getElementById('labelTrees').dataset.state = '.' + document.getElementById('labelTrees').dataset.state;
    sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
    return;
} else {
    document.getElementById('label-q1-output').innerText = 'That is incorrect. In order to build this tree with the given rules, there must be a rule that adds a terminal node &lsquo;' + document.getElementById('label-tree-1').dataset.tree.charAt(6) + '&rsquo; followed by some other node as child nodes of the root &lsquo;S&rsquo;. What rule matches this pattern? Given that rule, what must the other node be labeled?';
}
document.getElementById('label-q1-output').style.display = 'block';
">Submit</button></div>
<div id='label-q1-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="label-q2">
<p>Correct! To answer this question, you have to use <em>top-down</em> information: Looking <em>above</em> the unlabeled node, we see that the root node labeled &lsquo;S&rsquo; has two child nodes, the first labeled &lsquo;<span class="label-explainer" data-base="o"></span>&rsquo;. There is only one rule with &lsquo;S&rsquo; on the left side and &lsquo;<span class="label-explainer" data-base="o"></span>&rsquo; followed by another symbol on the right side: &lsquo;<span class="label-explainer" data-base="S &rarr; o B"></span>&rsquo;. The blank symbol has to be &lsquo;<span class="label-explainer" data-base="B"></span>&rsquo;.</p>

<p>Label the following tree so that it follows the accompanying rewrite rules, which are the same as the rules above.</p>

<div class='tree-rules' data-rules='' id='label-rules-2'></div>
<div><svg viewbox='0 0 160 140' width='160' height='140' data-tree='' data-index="3" id='label-tree-2' class='tree-frame' data-start-selected='01' data-select-lock='true'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B,C' data-terminals='t,o,y' data-index='3' id='label-labels-2'></div>
<div><button type="button" onclick="
    if (document.getElementById('label-tree-2').dataset.tree.includes('&mldr;')) {
        document.getElementById('label-q2-output').innerText = 'Please label all nodes in the tree.';
    } else if (document.getElementById('label-tree-2').dataset.tree.charAt(10).toLowerCase() == document.getElementById('label-tree-2').dataset.tree.charAt(10)) {
        document.getElementById('label-q2-output').innerText = 'That is incorrect. The node you&rsquo;ve labeled has a child node, which means it must be a nonterminal node. You&rsquo;ve labeled it with a terminal symbol.';
        document.getElementById('label-q2-output').style.display = 'block';
    } else if (frameErrors(document.getElementById('label-tree-2'), document.getElementById('label-rules-2').dataset.rules)[0] == 0) {
        document.getElementById('label-q2-output').style.display = 'none';
        document.getElementById('label-q3-output').style.display = 'none';
        document.getElementById('labelTrees').dataset.state = '.' + document.getElementById('labelTrees').dataset.state;
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
        return;
    } else {
        document.getElementById('label-q2-output').innerText = 'That is incorrect. In order to build this tree with the given rules, there must be a rule that adds only a nonterminal &lsquo;' + document.getElementById('label-tree-2').dataset.tree.charAt(14) + '&rsquo; as the child of some nonterminal node. What rule matches this pattern? Given that rule, what must the parent node be labeled?';
    }
    document.getElementById('label-q2-output').style.display = 'block';
">Submit</button></div>
<div id='label-q2-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="label-q3">
<p>Correct! To answer this question, you have to use <em>bottom-up</em> information: Looking <em>below</em> the unlabeled node, we see that the unlabeled node has a child labeled &lsquo;<span class="label-explainer" data-base="t"></span>&rsquo;. There is only one rule with just the symbol &lsquo;<span class="label-explainer" data-base="t"></span>&rsquo; on the right side: &lsquo;<span class="label-explainer" data-base="A &rarr; t"></span>&rsquo;. The blank symbol has to be &lsquo;<span class="label-explainer" data-base="A"></span>&rsquo;. </p>

<p>Label the following tree so that it follows the accompanying rewrite rules, which are the same as the rules above.</p>

<div class='tree-rules' data-rules='' id='label-rules-3'></div>
<div><svg viewbox='0 0 160 140' width='160' height='140' data-tree='' data-index="5" id='label-tree-3' class='tree-frame' data-start-selected='01' data-select-lock='true'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B,C' data-terminals='t,o,y' data-index='5' id='label-labels-3'></div>
<div><button type="button" onclick="
    if (document.getElementById('label-tree-3').dataset.tree.includes('&mldr;')) {
        document.getElementById('label-q3-output').innerText = 'Please label all nodes in the tree.';
    } else if (document.getElementById('label-tree-3').dataset.tree.charAt(10).toLowerCase() == document.getElementById('label-tree-3').dataset.tree.charAt(10)) {
        document.getElementById('label-q3-output').innerText = 'That is incorrect. The node you&rsquo;ve labeled has a child node, which means it must be a nonterminal node. You&rsquo;ve labeled it with a terminal symbol.';
    } else if (frameErrors(document.getElementById('label-tree-3'), document.getElementById('label-rules-3').dataset.rules)[0] == 0) {
        document.getElementById('label-q3-output').style.display = 'none';
        document.getElementById('label-q4-output').style.display = 'none';
        document.getElementById('labelTrees').dataset.state = '.' + document.getElementById('labelTrees').dataset.state;
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
        return;
    } else if (frameErrors(document.getElementById('label-tree-3'), document.getElementById('label-rules-3').dataset.rules)[1] == '0') {
        document.getElementById('label-q3-output').innerText = 'That is incorrect. There is no rule &lsquo;S &rarr; ' + document.getElementById('label-tree-3').dataset.tree.charAt(6) + ' ' + document.getElementById('label-tree-3').dataset.tree.charAt(10) + '&rsquo;, which would be needed to build the tree you labeled.';
    } else {
        document.getElementById('label-q3-output').innerText = 'That is incorrect. There is no rule &lsquo;' + document.getElementById('label-tree-3').dataset.tree.charAt(10) + ' &rarr; ' + document.getElementById('label-tree-3').dataset.tree.charAt(14) + '&rsquo;, which would be needed to build the tree you labeled.';
    }
    document.getElementById('label-q3-output').style.display = 'block';
">Submit</button></div>
<div id='label-q3-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="label-q4">
<p>Correct! To answer this question, you have to use both top-down and bottom-up information. Looking top-down, we can use either rules &lsquo;<span class="label-explainer" data-base="S &rarr; t B"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="S &rarr; t A"></span>&rsquo;. Looking bottom-up, we can use either rule &lsquo;<span class="label-explainer" data-base="B &rarr; y"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="C &rarr; y"></span>&rsquo;. The only symbol that works in both directions is &lsquo;<span class="label-explainer" data-base="B"></span>&rsquo;</p>

<p>Label the following tree so that it follows the accompanying rewrite rules, which are the same as the rules above. Since there are more blank nodes in this tree, you will have to select a blank node before you can label it.</p>

<div class='tree-rules' data-rules='' id='label-rules-4'></div>
<div><svg viewbox='0 0 180 180' width='180' height='180' data-tree='' data-index="7" id='label-tree-4' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B,C' data-terminals='t,o,y' data-index='7' id='label-labels-4'></div>
<div><button type="button" onclick="
    if (document.getElementById('label-tree-4').dataset.tree.includes('&mldr;')) {
        document.getElementById('label-q4-output').innerText = 'Please label all nodes in the tree.';
    } else if (frameErrors(document.getElementById('label-tree-4'), document.getElementById('label-rules-4').dataset.rules)[0] == 0) {
        document.getElementById('label-q4-output').style.display = 'none';
        document.getElementById('labelTrees').dataset.state = '.' + document.getElementById('labelTrees').dataset.state;
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
        return;
    } else if (frameErrors(document.getElementById('label-tree-4'), document.getElementById('label-rules-4').dataset.rules)[1] == '0') {
        document.getElementById('label-q4-output').innerText = 'That is incorrect. There is no rule &lsquo;S &rarr; ' + document.getElementById('label-tree-4').dataset.tree.charAt(5) + ' ' + document.getElementById('label-tree-4').dataset.tree.charAt(9) + '&rsquo;, which would be needed to build the tree you labeled.';
    } else {
        document.getElementById('label-q4-output').innerText = 'That is incorrect. There is no rule that would allow the highlighted node to have the child(ren) that it has in the tree.';
        var stateArray = document.getElementById('labelTrees').dataset.state.split(';');
        stateArray[8] = frameErrors(document.getElementById('label-tree-4'), document.getElementById('label-rules-4').dataset.rules)[1];
        document.getElementById('labelTrees').dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
    }
    document.getElementById('label-q4-output').style.display = 'block';
">Submit</button></div>
<div id='label-q4-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="label-q5">
<p>Correct! For this question, each unlabeled node required a different combination of top-down and bottom-up information. For the highest node, we can use its parent labeled &lsquo;S&rsquo; and left sibling labeled &lsquo;<span class="label-explainer" data-base="y"></span>&rsquo; to fix the top-down rule &lsquo;<span class="label-explainer" data-base="S &rarr; y C"></span>&rsquo;. The top blank symbol has to be &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo;.</p>

<p> Similarly, the bottom unlabeled node is the only child of a node labeled &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo;, which by top-down reasoning must have been rewritten with &lsquo;<span class="label-explainer" data-base="C &rarr; y"></span>&rsquo;. The lowest unlabeled node must be &lsquo;<span class="label-explainer" data-base="y"></span>&rsquo;.</p>

<p>The middle unlabeled node requires both top-down and bottom-up reasoning. We&rsquo;ve already worked out that its parent node is labeled &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo;, and it has a right sibling also labeled &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo;. There are two consistent rules here: &lsquo;<span class="label-explainer" data-base="C &rarr; B C"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="C &rarr; C C"></span>&rsquo;. Looking bottom-up, we see that the middle blank has a single child labeled &lsquo;<span class="label-explainer" data-base="o"></span>&rsquo;, so we must use either rule &lsquo;<span class="label-explainer" data-base="A &rarr; o"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="B &rarr; o"></span>&rsquo;. The only symbol consistent with both top-down and bottom-up information is &lsquo;<span class="label-explainer" data-base="B"></span>&rsquo;.</p>

<p>Label the following tree so that it follows the accompanying rewrite rules, which are the same as the rules above. There are once again multiple blank nodes. This problem is trickier, and will require tracking multiple possibilities (you may want to use pencil and paper).</p>

<div class='tree-rules' data-rules='' id='label-rules-5'></div>
<div><svg viewbox='0 0 180 180' width='180' height='180' data-tree='' data-index="9" id='label-tree-5' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B,C' data-terminals='t,o,y' data-index='9' id='label-labels-5'></div>
<div><button type="button" onclick="
    if (document.getElementById('label-tree-5').dataset.tree.includes('&mldr;')) {
        document.getElementById('label-q5-output').innerText = 'Please label all nodes in the tree.';
    } else if (frameErrors(document.getElementById('label-tree-5'), document.getElementById('label-rules-5').dataset.rules)[0] == 0) {
        document.getElementById('label-q5-output').style.display = 'none';
        document.getElementById('labelTrees').dataset.state = '.' + document.getElementById('labelTrees').dataset.state;
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
        return;
    } else if (frameErrors(document.getElementById('label-tree-5'), document.getElementById('label-rules-5').dataset.rules)[1] == '0') {
        document.getElementById('label-q5-output').innerText = 'That is incorrect. There is no rule &lsquo;S &rarr; ' + document.getElementById('label-tree-5').dataset.tree.charAt(5) + ' ' + document.getElementById('label-tree-5').dataset.tree.charAt(9) + '&rsquo;, which would be needed to build the tree you labeled.';
    } else {
        document.getElementById('label-q5-output').innerText = 'That is incorrect. There is no rule that would allow the highlighted node to have the child(ren) that it has in the tree.';
        var stateArray = document.getElementById('labelTrees').dataset.state.split(';');
        stateArray[8] = frameErrors(document.getElementById('label-tree-5'), document.getElementById('label-rules-5').dataset.rules)[1];
        document.getElementById('labelTrees').dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('labelTrees')(document.getElementById('labelTrees').dataset.state);
    }
    document.getElementById('label-q5-output').style.display = 'block';
">Submit</button></div>
<div id='label-q5-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="label-exit">
<p>Correct! For this tree, you had to combine a number of top-down and bottom-up reasoning steps. Working from the bottom, either labels &lsquo;<span class="label-explainer" data-base="A"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="B"></span>&rsquo; could have gone above &lsquo;<span class="label-explainer" data-base="o"></span>&rsquo;, and either symbols &lsquo;<span class="label-explainer" data-base="B"></span>&rsquo; or &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo; could have gone above &lsquo;<span class="label-explainer" data-base="y"></span>&rsquo;. Combining these choices gives us four possibilities for the symbols above &lsquo;<span class="label-explainer" data-base="o"></span>&rsquo; and &lsquo;<span class="label-explainer" data-base="y"></span>&rsquo;: &lsquo;<span class="label-explainer" data-base="A B"></span>&rsquo;, &lsquo;<span class="label-explainer" data-base="A C"></span>&rsquo;, &lsquo;<span class="label-explainer" data-base="B B"></span>&rsquo;, or &lsquo;<span class="label-explainer" data-base="B C"></span>&rsquo;. However, only the last of these appears on the right side of a rule, and so the only way to consistently label all three of the right nodes is to use the rule &lsquo;<span class="label-explainer" data-base="C &rarr; B C"></span>&rsquo;.</p>
    
<p>Since the only rule which has &lsquo;<span class="label-explainer" data-base="S"></span>&rsquo; on the left side and &lsquo;<span class="label-explainer" data-base="C"></span>&rsquo; on the right side is &lsquo;<span class="label-explainer" data-base="S &rarr; y C"></span>&rsquo;, the last remaining symbol must be &lsquo;<span class="label-explainer" data-base="y"></span>&rsquo;.</p>

<p>The terms &ldquo;top-down&rdquo; and &ldquo;bottom-up&rdquo; are commonly used in the field of <em>parsing</em>, where your goal is to build a tree structure which a particular string can be read off of.<span class="collapse-note"> In parsing, top-down reasoning is a type of prediction or expectation driven by previous experience, while bottom-up reasoning is driven by current experience. For example, an English listener who hears the words &ldquo;Could you&rdquo; might begin constructing a syntactic structure for those two words, which would strongly predict that the following word is either an adverb (&ldquo;please&rdquo;) or a verb (&ldquo;pass&rdquo;), via top-down reasoning. The listener may be forced to re-evaluate that prediction on the basis of bottom-up evidence, like hearing the following word &ldquo;all&rdquo;.</span> The next section is a quick detour to teach you how to draw and submit trees for this activity, after which we will return to top-down and bottom-up thinking in parsing.</p>

<button id="labelTrees-button" onclick="parentSection(this).dataset.state='X'+parentSection(this).dataset.state.slice(1); state.push('drawAnyTree'); redrawSections();">Continue</button>
</div>

</section>

<section id='drawAnyTree' data-state=";[S];XX" data-initial-state=";[S];XX">
<script type="text/javascript">
    const parseConst = 12000;
    function parsingPermute(input) {
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10)/parseConst);
        const nonterms = ['A','B'];
        const terms = ['t','o','y'];
        const permNonts = permuteIndices(seed,nonterms);
        const permTerms = permuteIndices(Math.floor(seed/2),terms);
        return substitute(terms,permTerms,substitute(nonterms,permNonts,input));
    }
    function drawAnyTreeStart(sectionState) {
        const SRulesArray = ['t A','A o','B y','B y t','y t','o o'].map((x) => parsingPermute(x));
        const otherRulesArray = ['A>y S|S t|B y|t o|o y','B>t S|o S|o B|B t|A o'].map((x) => parsingPermute(x)).sort();
        /*let SRulesArray = ['w A B','x C A','C A y','A A y'];
        for (let i = 0; i < SRulesArray.length; i++) {
            SRulesArray[i] = parsingPermutation(SRulesArray[i]);
        }
        SRulesArray.sort();
        let otherRulesArray = ['A>w D|C x|w x|x y','B>x C|D w|x w|w y','C>x A|w w|z x','D>w B|x x|z y'];
        for (let i = 0; i < otherRulesArray.length; i++) {
            otherRulesArray[i] = substitute(terms,permTerms,substitute(nonterms1,permNonts1,substitute(nonterms2,permNonts2,otherRulesArray[i])));
        }
        otherRulesArray.sort();
        */
        let rules = "S>";
        for (let i = 0; i < SRulesArray.length; i++) {
            rules = rules + SRulesArray[i] + '|';
        }
        rules = rules.slice(0,-1)+',';
        for (let i = 0; i < otherRulesArray.length; i++) {
            rules = rules + otherRulesArray[i] + ',';
        }
        rules = rules.slice(0,-1);

        const ruleset = document.getElementById('draw-any-rules');
        ruleset.dataset.rules = rules;
        drawTreeRules(ruleset);
    }
    function drawAnyTreeRedraw(sectionState) {
        const stateArray = sectionState.split(';');
        const myTree = document.getElementById('draw-any-tree');
        myTree.dataset.tree = stateArray[1];
        myTree.dataset.selected = stateArray[2];
        drawTrees(myTree);
        if (stateArray[0] == '') {
            enableButtons(document.getElementById('draw-any-q1'));
            document.getElementById('drawAny-button').style.display = 'none';
        } else if (stateArray[0] == '.') {
            disableButtons(document.getElementById('draw-any-q1'));
            document.getElementById('drawAny-button').style.display = 'block';
        } else {
            disableButtons(document.getElementById('draw-any-q1'));
            document.getElementById('drawAny-button').style.display = 'none';
        }


        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('drawAnyTree',drawAnyTreeRedraw);
    sectionStarts.set('drawAnyTree',drawAnyTreeStart);
</script>    


<h3>Drawing Trees</h3>

<p>In earlier exercises, you filled in templates and trees by selecting a nonterminal symbol, then pressing on a rule which has that symbol on the left side. It&rsquo;s important that you also be able to draw trees on your own, by drawing the nodes and edges by yourself. We can&rsquo;t quite do that in this online format, but starting in this section you will have to add and label each node individually, and check that it follows the CFG&rsquo;s rules by yourself.</p>

<p>Below is a set of rules (which you will get to know very well in the next section on parsing). To complete this section, you simply need to submit any tree consistent with the rules, which a string of only terminal symbols can be read off of. To do this, you will make use of the same labeling buttons as above, as well as four new buttons that change the structure of the tree. The &ldquo;Delete&rdquo; button deletes the selected node, as well as its children, and their children, and so on (that is, all descendants of the selected node). The &ldquo;Add child&rdquo; button adds one child node to the selected node, to the right of all of its current child nodes. The &ldquo;Swap left&rdquo; and &ldquo;Swap right&rdquo; buttons swap the position of the selected node with its sibling node directly to the left or right, if one exists. These new buttons can be found below all of the labeling buttons.</p>

<div id = 'draw-any-q1'>
<div class='tree-rules' data-rules='' id='draw-any-rules'></div>
<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' data-index="1" id='draw-any-tree' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B' data-terminals='t,o,y' data-index='1' id='draw-any-labels'></div>
<div class='tree-manipulations' data-index='1' id='draw-any-manips'></div>
<div><button type="button" onclick="{
    const tree = document.getElementById('draw-any-tree');
    const output = document.getElementById('draw-any-output');
    const rules = document.getElementById('draw-any-rules');
    if (tree.dataset.tree.includes('\u2026')) {
        output.innerText = 'Please label all nodes in the tree.';
    } else if (readString(tree.dataset.tree, ['t','o','y'])[0]) {
        output.innerText = 'That is incorrect. There is a nonterminal node in your tree that doesn\u2019t have any child nodes, so the string read off of the tree doesn\u2019t include only terminal symbols.';
    } else if (frameErrors(tree, rules.dataset.rules)[0] != 0) {
        let errors = frameErrors(tree, rules.dataset.rules);
        if (errors[1][errors[1].length - 1] == 'start') {
            output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
        } else {
            output.innerText = 'That is incorrect. There is no rule that would allow the highlighted node to have the child(ren) that it has in the tree.';
            var stateArray = document.getElementById('drawAnyTree').dataset.state.split(';');
            stateArray[2] = errors[1][0];
            document.getElementById('drawAnyTree').dataset.state = stateArray.toString().replace(/,/g,';');
            drawAnyTreeRedraw(document.getElementById('drawAnyTree').dataset.state);
        }
    } else {
        output.style.display = 'none';
        document.getElementById('drawAnyTree').dataset.state = '.' + document.getElementById('drawAnyTree').dataset.state;
        drawAnyTreeRedraw(document.getElementById('drawAnyTree').dataset.state);
        return;
    }
    output.style.display = 'block';
    
}">Submit</button></div>
<div id='draw-any-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
</div>
</div>

<button id="drawAny-button" onclick="parentSection(this).dataset.state='X'+parentSection(this).dataset.state; state.push('parsing'); redrawSections();" style="margin-top:5px">Continue</button>


</section>

<section id='parsing' data-state=";[S];XX;[S];XX;[S];XX" data-initial-state=";[S];XX;[S];XX;[S];XX">
<script type="text/javascript">
    function parsingStart(sectionState) {
        const perms = document.getElementsByClassName('parsing-perm');
        for (let s of perms) {
            s.innerText = parsingPermute(s.dataset.initial);
        }
        const ruleNotes = document.getElementById('parsing').getElementsByClassName('collapse-note');
        for (let n of ruleNotes) {
            const rules = n.getElementsByClassName('tree-rules');
            if (rules.length > 0) {
                const r = rules.item(0);
                r.dataset.rules = document.getElementById('draw-any-rules').dataset.rules;
                drawTreeRules(r);
            }
        }
        const trees = document.getElementById('parsing').getElementsByClassName('tree-frame');
        for (let t of trees) {
            if (t.dataset.initialTree != null) {
                t.dataset.tree = parsingPermute(t.dataset.initialTree);
            }
        }
        for (let i = 1; i <= 1; i++) {
            document.getElementById('parsing-q'+i+'-output').style.display = "none";
        }
    }
    function parsingRedraw(sectionState) {
        var stateArray = sectionState.split(";");

        const questionList = ['parsing-q1','parsing-q2','parsing-q3','parsing-exit'];
        for (let i = 0; i < questionList.length; i++) {
            if (i <= stateArray[0].length) {
                document.getElementById(questionList[i]).style.display = "block";
                if (i != stateArray[0].length) {
                    disableButtons(document.getElementById(questionList[i]));
                } else {
                    enableButtons(document.getElementById(questionList[i]));
                }
            } else {
                document.getElementById(questionList[i]).style.display = "none";
            }
        }

        for (let i = 1; i <= 3; i++) {
            const myTree = document.getElementById('parsing-tree-'+i);
            myTree.dataset.tree = stateArray[-1+2*i];
            myTree.dataset.selected = stateArray[2*i];
        }

        const trees = document.getElementById('parsing').getElementsByClassName('tree-frame');
        for (let t of trees) {
            drawTrees(t);
        }


        
        if (stateArray[0].charAt(0) == "X") {
            document.getElementById('parsing-button').style.display = "none";
        } else {
            document.getElementById('parsing-button').style.display = "block";
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionRedraws.set('parsing',parsingRedraw);
    sectionStarts.set('parsing',parsingStart);
</script>

<h3>Parsing</h3>

<p>In this section, we return to the problem of parsing, in which you are given a string and a CFG, and have to draw a tree for that string using only the rules in the CFG. These problems are like the previous labeling problems, except the tree structure won&rsquo;t be provided for you. For example, take the following rules:</p>

<div class='tree-rules' data-rules='S>t A,A>o|y'></div>

<p>A parsing problem may ask you to draw a tree for the string &ldquo;t o&rdquo;, which only uses those rules. To complete this problem, you would submit the following tree:</p>

<div><svg viewbox='0 0 140 140' width='140' height='140' data-tree='[S [t] [A [o]]]' id='parsing-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>In solving these problems, you will learn some strategies for parsing in both top-down or bottom-up ways. While the exact details of these strategies are specific to the CFG provided to you, the general ideas are used in many different models and theories of parsing. Notably, none of the problems you will solve require <em>guessing</em> something about the structure of the tree: There will always be some node that you can add to your tree with certainty. Some of the most difficult aspects of parsing models involve dealing with temporary ambiguities that require this kind of guessing, but you will not have to deal with them here.</p>

<div id="parsing-q1">

<p>We will first discuss how to parse in a top-down way. Here, you will start by drawing a root node &lsquo;S&rsquo;, and will repeatedly add children to the nonterminal nodes in your tree until you&rsquo;ve drawn a tree which your target string can be read off of. In this section, you will always be able to eliminate all possible rules to use except one, given the target string. Let&rsquo;s look at an example.</p>

<p>The CFG you will use throughout this section is included in the hidden note below (and will be repeated regularly).</p>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>In this demonstration, we will parse the string &ldquo;<span class="parsing-perm" data-initial="y o o o y"></span>&rdquo;. We start with a tree including only the root node &lsquo;S&rsquo;:</p>

<div><svg viewbox='0 0 140 70' width='140' height='70' data-tree='' data-initial-tree="[S]" id='parsing-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>What rule can be applied to this root node? We can immediately eliminate the two rules &lsquo;<span class="parsing-perm" data-initial="S &rarr; y t"></span>&rsquo; and &lsquo;<span class="parsing-perm" data-initial="S &rarr; o o"></span>&rsquo; because neither one has any nonterminal symbols on the right side, which would limit our generated string to only being two symbols long. For the remaining rules (with nonterminal symbols), we can reason about which symbols are added to our final string, and whether they are consistent with the target.</p>

<p>Consider &lsquo;<span class="parsing-perm" data-initial="S &rarr; t A"></span>&rsquo;. The nonterminal symbol &lsquo;<span class="parsing-perm" data-initial="A"></span>&rsquo; follows the terminal &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo;, and any terminals generated by &lsquo;<span class="parsing-perm" data-initial="A"></span>&rsquo; or its descendants will likewise follow &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo;. This means that, it we use this rule first, the string would have to begin with &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo;. It does not (since it starts with &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;), so this rule isn&rsquo;t possible. Similarly, &lsquo;<span class="parsing-perm" data-initial="S &rarr; A o"></span>&rsquo; would lead to the string ending in &lsquo;<span class="parsing-perm" data-initial="o"></span>&rsquo; (which it doesn&rsquo;t), and &lsquo;<span class="parsing-perm" data-initial="S &rarr; B y t"></span>&rsquo; would lead to the string ending in &lsquo;<span class="parsing-perm" data-initial="y t"></span>&rsquo; (which it doesn&rsquo;t).</p>

<p>There is only one rule remaining: &lsquo;<span class="parsing-perm" data-initial="S &rarr; B y"></span>&rsquo;. Because the nonterminal symbol &lsquo;<span class="parsing-perm" data-initial="B"></span>&rsquo; precedes the terminal &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;, using this rule would lead to the string ending in &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;, which is consistent with our target. This is the correct first rule to use, which gives us the intermediate step below:</p>

<div><svg viewbox='0 0 140 100' width='140' height='100' data-tree='' data-initial-tree="[S [B] [y]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>What&rsquo;s next to parse &ldquo;<span class="parsing-perm" data-initial="y o o o y"></span>&rdquo;? We&rsquo;re looking to apply a rule to nonterminal symbol &lsquo;<span class="parsing-perm" data-initial="B"></span>&rsquo;, which gives us five options. We can reason about the first three, &lsquo;<span class="parsing-perm" data-initial="B &rarr; t S"></span>&rsquo;, &lsquo;<span class="parsing-perm" data-initial="B &rarr; o S"></span>&rsquo;, and &lsquo;<span class="parsing-perm" data-initial="B &rarr; o B"></span>&rsquo; similarly to our previous step: since the terminal symbols precede the nonterminal symbols, using any of these rules would fix the first symbols of the generated string. The first symbol of the target string is &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;, which doesn&rsquo;t match any of those three rules.</p>

<p>The other two rules are a little trickier to reason about, because they add a terminal symbol after a nonterminal symbol, but we already have a terminal symbol &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo; to the right of &lsquo;<span class="parsing-perm" data-initial="B"></span>&rsquo;. This means that the choice of rule here would fix the terminal symbol right before the final &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;: the second-to-last symbol. The target string ends &lsquo;<span class="parsing-perm" data-initial="o y"></span>&rsquo;, so this second-to-last symbol is &lsquo;<span class="parsing-perm" data-initial="o"></span>&rsquo;, locking in the next rule used as &lsquo;<span class="parsing-perm" data-initial="B &rarr; A o"></span>&rsquo;. This gives us the following intermediate step:</p>

<div><svg viewbox='0 0 140 140' width='140' height='140' data-tree='' data-initial-tree="[S [B [A] [o]] [y]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>What remains? We have a nonterminal symbol &lsquo;<span class="parsing-perm" data-initial="A"></span>&rsquo; to add children to, and the last two terminal symbols, &lsquo;<span class="parsing-perm" data-initial="o y"></span>&rsquo;, are already set. That means we will need to generate the first three terminal symbols, &ldquo;<span class="parsing-perm" data-initial="y o o"></span>&rdquo;, from our nonterminal &lsquo;<span class="parsing-perm" data-initial="A"></span>&rsquo;. &ldquo;<span class="parsing-perm" data-initial="y o o"></span>&rdquo; doesn&rsquo;t end with &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo; or &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo;, so we must use rule &lsquo;<span class="parsing-perm" data-initial="S &rarr; y S"></span>&rsquo;. That gives us &ldquo;<span class="parsing-perm" data-initial="o o"></span>&rdquo; to generate from &lsquo;<span class="parsing-perm" data-initial="S"></span>&rsquo;, which we can do with rule &lsquo;<span class="parsing-perm" data-initial="S &rarr; o o"></span>&rsquo;.</p>

<div><svg viewbox='0 0 240 240' width='240' height='240' data-tree='' data-initial-tree="[S [B [A [y] [S [o] [o]]] [o]] [y]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true'></svg></div>

<p>This tree is a valid parse tree for the string &ldquo;<span class="parsing-perm" data-initial="y o o o y"></span>&rdquo;.</p>

<p>Now it&rsquo;s your turn: Using the top-down strategy demonstrated above, submit a parse tree for the target string &ldquo;<span class="parsing-perm" id="parsing-q1-target" data-initial="t o o t o t"></span>&rdquo;.</p>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' data-index="1" id='parsing-tree-1' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B' data-terminals='t,o,y' data-index='1' id='parsing-labels-1'></div>
<div class='tree-manipulations' data-index='1' id='parsing-manips-1'></div>
<script type="text/javascript">
function parsingFeedback(index) {
    const tree = document.getElementById('parsing-tree-' + index);
    const output = document.getElementById('parsing-q' + index + '-output');
    const target = document.getElementById('parsing-q' + index + '-target');
    const rules = document.getElementById('draw-any-rules');
    if (tree.dataset.tree.includes('\u2026')) {
        output.innerText = 'Please label all nodes in the tree.';
    } else if (readString(tree.dataset.tree, ['t','o','y'])[1] != target.innerText) {
        output.innerText = 'That is incorrect. The string \u201C' + readString(tree.dataset.tree, ['t','o','y'])[1] + '\u201D is read off of your tree, not the target string of \u201C' + target.innerText + '\u201D.';
    } else if (frameErrors(tree, rules.dataset.rules)[0] != 0) {
        let errors = frameErrors(tree, rules.dataset.rules);
        if (errors[1][errors[1].length - 1] == 'start') {
            output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
        } else {
            output.innerText = 'That is incorrect. There is no rule that would allow the highlighted node to have the child(ren) that it has in the tree.';
            var stateArray = document.getElementById('parsing').dataset.state.split(';');
            stateArray[index*2] = errors[1][0];
            document.getElementById('parsing').dataset.state = stateArray.toString().replace(/,/g,';');
            parsingRedraw(document.getElementById('parsing').dataset.state);
        }
    } else {
        output.style.display = 'none';
        document.getElementById('parsing').dataset.state = '.' + document.getElementById('parsing').dataset.state;
        parsingRedraw(document.getElementById('parsing').dataset.state);
        return;
    }
    output.style.display = 'block';
}
</script>
<div><button type="button" onclick="parsingFeedback(1);">Submit</button></div>
<div id='parsing-q1-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
</div>

</div>

<div id="parsing-q2">
<p>Good work! We will now discuss how to parse in a bottom-up way. Until now, we&rsquo;ve been drawing trees from the root down, by adding and labeling child nodes to nonterminal nodes. This naturally fits the top-down approach above. In order to parse in a bottom-up way, it will be useful to draw a tree differently, from the terminal nodes up, by writing the target string along the bottom of a page, and then adding nonterminal parent nodes above them. This method will be demonstrated below, and I recommend working through the later exercise on a sheet of paper so that you can draw your tree in this way (before submitting it on the website using the usual method).</p>

<p>We consider a new string to parse, &ldquo;<span class="parsing-perm" data-initial="t y o o"></span>&rdquo;. We start by writing all of our terminal symbols in a line. The following diagram is technically not a tree, because all of the terminal nodes are parentless roots.</p>

<div><svg viewbox='0 0 240 50' width='240' height='50' data-tree='' data-initial-tree="[t] [y] [o] [o]" id='parsing-example-tree' class='tree-frame' data-select-lock='true' data-bottom-up='true'></svg></div>
    
<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>We would run into a little trouble if we tried to parse this string top-down: We could choose either &lsquo;<span class="parsing-perm" data-initial="S &rarr; t A"></span>&rsquo; or &lsquo;<span class="parsing-perm" data-initial="S &rarr; A o"></span>&rsquo; as a first rule to apply, since the target string both starts with &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo; and ends with &lsquo;<span class="parsing-perm" data-initial="o"></span>&rsquo;.</p>

<p>However, there is no such trouble going bottom-up. There are no nonterminal symbols in the final string by definition, so the last rule that applies must have only terminal symbols on its right side. There are four rules like that, each of which generates two terminal symbols next to each other. We can look at the target string and see that there are three pairs of letters next to each other: the first two &ldquo;<span class="parsing-perm" data-initial="t y"></span>&rdquo;, the middle two &ldquo;<span class="parsing-perm" data-initial="y o"></span>&rdquo;, and the final two &ldquo;<span class="parsing-perm" data-initial="o o"></span>&rdquo;. Only one of these pairs appears on the right side of a rule, and so we know that the bottom-most rule must be &lsquo;<span class="parsing-perm" data-initial="S &rarr; o o"></span>&rsquo;. We can write the new nonterminal symbol above our terminal symbols like so:</p>

<div><svg viewbox='0 0 240 90' width='240' height='90' data-tree='' data-initial-tree="[t] [y] [S [o] [o]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true' data-bottom-up='true'></svg></div>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>This opens up a new possibility: that the next rule up has a nonterminal symbol on its right side. Since we have terminal &lsquo;<span class="parsing-perm" data-initial="y"></span>&rsquo; followed by nonterminal &lsquo;<span class="parsing-perm" data-initial="S"></span>&rsquo;, we can use rule &lsquo;<span class="parsing-perm" data-initial="A &rarr; y S"></span>&rsquo;. This gives us the following intermediate step:</p>

<div><svg viewbox='0 0 240 130' width='240' height='130' data-tree='' data-initial-tree="[t] [A [y] [S [o] [o]]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true' data-bottom-up='true'></svg></div>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<p>This diagram looks quite different from the trees we are used to, because we have an edge that is taller than the others, but we can still read it the way we usually do, where edges tell us which nodes are in parent-child relations.</p>

<p>We&rsquo;re almost done! There are only two nodes which don&rsquo;t have parents: &lsquo;<span class="parsing-perm" data-initial="t"></span>&rsquo; and &lsquo;<span class="parsing-perm" data-initial="A"></span>&rsquo;, in that order. There is a convenient rule &lsquo;<span class="parsing-perm" data-initial="S &rarr; t A"></span>&rsquo; which matches these symbols, and which has the (necessary) benefit of giving up a root node labelled &lsquo;<span class="parsing-perm" data-initial="S"></span>&rsquo;. We have the following tree:</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-tree='' data-initial-tree="[S [t] [A [y] [S [o] [o]]]]" id='parsing-example-tree' class='tree-frame' data-select-lock='true' data-bottom-up='true'></svg></div>

<p>This tree is a valid parse for the string &ldquo;<span class="parsing-perm" data-initial="t y o o"></span>&rdquo;.</p>

<p>Now it&rsquo;s your turn: Using the bottom-up strategy demonstrated above, submit a parse tree for the target string &ldquo;<span class="parsing-perm" id="parsing-q2-target" data-initial="t t y y t y"></span>&rdquo;. As in the demonstration above, start by looking for two terminal symbols that are next to each other, which could be children of the same nonterminal node.</p>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' data-index="3" id='parsing-tree-2' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B' data-terminals='t,o,y' data-index='3' id='parsing-labels-2'></div>
<div class='tree-manipulations' data-index='3' id='parsing-manips-2'></div>
<div><button type="button" onclick="parsingFeedback(2);">Submit</button></div>
<div id='parsing-q2-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
</div>

</div>

<div id="parsing-q3">
<p>Correct! For the last parsing problem, you will have to mix both bottom-up and top-down strategies. If you try to use one strategy, but find that multiple choices are possible, you should try the other strategy, because this string was chosen specifically to allow for parsing without any ambiguity.</p>

<p>Submit a parse tree for the target string &ldquo;<span class="parsing-perm" id="parsing-q3-target" data-initial="o t t t o y t"></span>&rdquo;.</p>

<div><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules=''></div></span></div>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' data-index="5" id='parsing-tree-3' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,A,B' data-terminals='t,o,y' data-index='5' id='parsing-labels-3'></div>
<div class='tree-manipulations' data-index='5' id='parsing-manips-3'></div>
<div><button type="button" onclick="parsingFeedback(3);">Submit</button></div>
<div id='parsing-q3-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
</div>

</div>

<div id='parsing-exit'>

<p>Well done! You needed to start top-down, because we see multiple places to start working botttom-up from the final string (one of &lsquo;<span class="parsing-perm" data-initial="A &rarr; t o"></span>&rsquo;, &lsquo;<span class="parsing-perm" data-initial="A &rarr; o y"></span>&rsquo;, or &lsquo;<span class="parsing-perm" data-initial="S &rarr; y T"></span>&rsquo;.) After using top-down rule &lsquo;<span class="parsing-perm" data-initial="S &rarr; B y t"></span>&rsquo;, we can&rsquo;t do more top-down work, because both rules &lsquo;<span class="parsing-perm" data-initial="B &rarr; o S"></span>&rsquo; and &lsquo;<span class="parsing-perm" data-initial="B &rarr; o B"></span>&rsquo; are possible, but from here it&rsquo;s possible to complete the rest of the tree bottom-up.</p>

<button id="parsing-button" onclick="parentSection(this).dataset.state='X' + parentSection(this).dataset.state; state.push('ambiguity'); redrawSections();">Continue</button>
</div>

</div>

</section>

<section id='ambiguity' data-state='[S];XX;[S];XX;' data-initial-state='[S];XX;[S];XX;'>
<script type="text/javascript">
    function ambiguityRedraw(sectionState) {
        var stateArray = sectionState.split(";");
        const terminals = ['they', 'at', 'dawn', 'noon', 'night', 'left', 'said'];
        drawTreeRules(document.getElementById("ambi-rules"));
        const treeList = ["ambi-tree-1","ambi-tree-2"];
        for (let i = 0; i < treeList.length; i++) {
            const myTree = document.getElementById(treeList[i]);
            myTree.dataset.tree = stateArray[2*i];
            myTree.dataset.selected = stateArray[1+2*i];
            myTree.dataset.selectLock = (stateArray[4].length > 0);
            drawTrees(myTree);
        }
        if (stateArray[4].length == 0) {
            document.getElementById('ambi-submit').style.display = 'block';
            document.getElementById('ambi-answer').style.display = 'none';
            enableButtons(document.getElementById('ambi-t-1'));
            enableButtons(document.getElementById('ambi-t-2'));
        } else {
            document.getElementById('ambi-submit').style.display = 'none';
            document.getElementById('ambi-answer').style.display = 'block';
            disableButtons(document.getElementById('ambi-t-1'));
            disableButtons(document.getElementById('ambi-t-2'));
            const sentence = readString(stateArray[0], terminals)[1];
            document.getElementById('ambi-sentence-copy').innerText = sentence;
            document.getElementById('ambi-time-copy-1').innerText = sentence.split('left')[1];
            document.getElementById('ambi-time-copy-2').innerText = sentence.split('left')[1];
            if (stateArray[4].length == 1) {
                document.getElementById('ambiguity-button').style.display = 'block';
            } else {
                document.getElementById('ambiguity-button').style.display = 'none';
            }
        }

        drawTrees(document.getElementById("ambi-tree-3"));
        document.getElementById('banner-out').innerText = getSectionStates();
    }

    sectionRedraws.set('ambiguity',ambiguityRedraw);

    function ambiFeedback() {
        var stateArray = document.getElementById('ambiguity').dataset.state.split(';');
        const tree1 = document.getElementById('ambi-tree-1');
        const tree2 = document.getElementById('ambi-tree-2');
        const output = document.getElementById('ambi-output');
        const rules = document.getElementById('ambi-rules').dataset.rules;
        const terminals = ['they', 'at', 'dawn', 'noon', 'night', 'left', 'said'];

        if (stateArray[0].includes('\u2026') || stateArray[2].includes('\u2026')) {
            output.innerText = 'Please label all nodes in both trees.';
        } else if (readString(stateArray[0], terminals)[0] || readString(stateArray[2], terminals)[0]) {
            output.innerText = 'Please ensure all nonterminal nodes have children.';
        } else if (frameErrors(tree1, rules)[0] != 0) {
            let errors = frameErrors(tree1, rules);
            if (errors[1][errors[1].length - 1] == 'start') {
                output.innerText = 'That is incorrect. The root nodes of the both trees need to be labeled with the special symbol \u2018S\u2019.';
            } else {
                output.innerText = 'That is incorrect. There is no rule that would allow the highlighted node in your first tree to have the child(ren) that it has in the tree.';
                stateArray[1] = errors[1][0];
                stateArray[3] = 'XX';
            }
        } else if (frameErrors(tree2, rules)[0] != 0) {
            let errors = frameErrors(tree2, rules);
            if (errors[1][errors[1].length - 1] == 'start') {
                output.innerText = 'That is incorrect. The root nodes of the both trees need to be labeled with the special symbol \u2018S\u2019.';
            } else {
                output.innerText = 'That is incorrect. There is no rule that would allow the highlighted node in your second tree to have the child(ren) that it has in the tree.';
                stateArray[3] = errors[1][0];
                stateArray[1] = 'XX';
            }
        } else if (readString(stateArray[0], terminals)[1] !== readString(stateArray[2], terminals)[1]) {
            output.innerText = 'That is incorrect. The string \u201C' + readString(stateArray[0], terminals)[1] + '\u201D is read off the first tree, while the string \u201C' + readString(stateArray[2], terminals)[1] + '\u201D is read off the second tree. Please make sure the strings are the same.';
        } else if (stateArray[0] == stateArray[2]) {
            output.innerText = 'That is incorrect. The two trees are identical, so do not demonstrate ambiguity.';
        } else if (stateArray[0].split('said').length > 2) {
            output.innerText = 'That is incorrect. Please include no more than one node labeled \u2018said\u2019 in each tree.';
        } else {
            output.style.display = 'none';
            stateArray[1] = 'XX';
            stateArray[3] = 'XX';
            document.getElementById('ambiguity').dataset.state = stateArray.toString().replace(/,/g,';') + '.';
            sectionRedraws.get('ambiguity')(document.getElementById('ambiguity').dataset.state);
            return;
        }
        output.style.display = 'block';
        document.getElementById('ambiguity').dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('ambiguity')(document.getElementById('ambiguity').dataset.state);
    }
</script>
<h3>Ambiguity</h3>

<p>Sometimes two different tree structures consistent with a given CFG will have the same string of terminal symbols read off of them. This is known as <em>ambiguity</em>, because it is ambiguous which tree was used in generating that string.</p>

<p>Some (but not all) of the strings generated by the following CFG are ambiguous. Using the CFG, draw two trees that have different structures, but which have the same string of terminal symbols read off of them. To keep things simple, each tree should not contain more than one node labeled &lsquo;said&rsquo;.</p>

<div class='tree-rules' data-rules='S>they VERB|they VERB TIME,VERB>left|said S,TIME>at dawn|at noon|at night' id='ambi-rules'></div>

<div id='ambi-t-1'>
<div><svg viewbox='0 0 240 180' width='240' height='480' data-resize="true" data-tree='' data-index="0" id='ambi-tree-1' class='tree-frame' style='margin-top:2em'></svg></div>
<div class='tree-labels' data-nonterminals='S,VERB,TIME' data-terminals='they,left,said,at,dawn,noon,night' data-index='0' id='ambi-labels-1'></div>
<div class='tree-manipulations' data-index='0' id='ambi-manips-1'></div>
</div>

<div style='padding-top:1em'><span class="collapse-note" data-label="Rules"><div class='tree-rules' data-rules='S>they VERB|they VERB TIME,VERB>left|said S,TIME>at dawn|at noon|at night'></div></span></div>

<div id='ambi-t-2'>
<div><svg viewbox='0 0 240 180' width='240' height='480' data-resize="true" data-tree='' data-index="2" id='ambi-tree-2' class='tree-frame' style='margin-top:2em'></svg></div>
<div class='tree-labels' data-nonterminals='S,VERB,TIME' data-terminals='they,left,said,at,dawn,noon,night' data-index='2' id='ambi-labels-2'></div>
<div class='tree-manipulations' data-index='2' id='ambi-manips-2'></div>
</div>

<div><button type="button" id='ambi-submit' onclick="ambiFeedback()" style='margin-top:2em'>Submit</button></div>
<div id='ambi-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

<div id="ambi-answer">
<p>Correct! In this tree, the TIME node can be attached in two different places: to the root &lsquo;S&rsquo; above the verb &lsquo;said&rsquo;, or to the lower &lsquo;S&rsquo; above the verb &lsquo;left&rsquo;.</p>

<p>The string you generated, &ldquo;<span id="ambi-sentence-copy"></span>&rdquo;, also has two different meanings: Is the speaker telling us that the saying event happened <span id="ambi-time-copy-1"></span>, or that the leaving event happened <span id="ambi-time-copy-2"></span>? By looking at a related sentence, we can see that the different tree positions are associated with different meanings:</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='[S [they] [VERB [said] [S [they] [VERB [left]] [TIME [at] [noon]]]] [TIME [at] [night]]]' id='ambi-tree-3' class='tree-frame' data-select-lock='true'></svg></div>

<p>In this sentence, &ldquo;they said they left at noon at night&rdquo; (which is a bit clunky, but sounds better if you pause a little before &ldquo;at night&rdquo;), the leaving happens unambiguously at noon, and the saying happens unambiguously at night. This suggests that the higher TIME position tells us when the saying happens, and the lower TIME position tells us when the leaving happens. This makes some intuitive sense, too, since the top position is closer to the verb &lsquo;said&rsquo;, and the lower position is closer to the verb &lsquo;left&rsquo;. This also suggests that the ambiguity in the string you generated is explained by the ambiguity in tree structure, where each different tree structure gets a different interpretation.</p>

<button id="ambiguity-button" onclick="parentSection(this).dataset.state=parentSection(this).dataset.state + 'X'; state.push('modelingMorpho'); redrawSections();">Continue</button>
</div>
</section>

<section id='modelingMorpho' data-state=';-1;choose;;;' data-initial-state=';-1;choose;;;'>
<!-- State is: Counter, quadruples (state,over,tree,treeselector) or (state,under,word,.) -->
<script type="text/javascript">
    //const funcArray = [(x) => 2*x,(x) => 3*x,(x) => 4*x];
    function distribute(a, b, inter) {
        return [].concat(...a.map(x => b.map(y => "".concat(x,inter,y).trim())));
    }
    const morphoStates = ['-1'].concat(distribute(distribute(distribute(['0'],['0','1'],''),['0','1'],''),['0','1','2'],'')).concat(distribute(distribute(['1'],['0','1','2','3'],''),['0','1','2','3'],''));
    // ['0000'],[]
    // State description:
    // First bit is non-cyclic (0) or cyclic (1)
    // If non-cyclic, next are erEdge (0-1), erVerb (0-1), re(Re)Verb (0-2)
    // If cyclic, next are free+erVerbEdge (0-3), re(Re)Verb (0-3)
    function morphoNextStates(state) {
        let out = new Array();
        if (state == '-1') {
            out.push('0000');
            return out;
        }
        if (state.charAt(0) == '0') {
            out.push("1" + Math.min(3,3*parseInt(state.charAt(1))+2*parseInt(state.charAt(2))) + Math.round(1.6*parseInt(state.charAt(3))));
            // ASDF are the following in the right order?
            if (state.charAt(2) == '0') out.push(state.slice(0,2) + "1" + state.slice(3));
            if (state.charAt(1) == '0') out.push("01" + state.slice(2));    
            if (parseInt(state.charAt(3)) < 2) out.push(state.slice(0,3) + (parseInt(state.charAt(3))+1));
        } else {
            let x = parseInt(state.charAt(1));
            let y = parseInt(state.charAt(2));
            if (x < 3) out.push("1" + (x+1) + y);
            if (y < 3) out.push("1" + x + (y+1));
            if (x < 2 && y%2 == 0) out.push("1" + (x+1) + (y+1));
            if (x == 0) out.push("12" + y);
            if (x == 0 && y%2 == 0) out.push("12" + (y+1));
        }
        return out;
    }
    function morphoRules(state) {
        if (state == '-1') {
            return 'S>adapt|globe|real';
        } else if (state.charAt(0) == '0') {
            const x = parseInt(state.charAt(1)); // erEdge
            const y = parseInt(state.charAt(2)); // erVerb
            const z = parseInt(state.charAt(3)); // re(Re)Verb
            const U = ['S','T'];
            const PR = ['','re','P'];
            const V = [['adapt', U[x] + ' ize'],['V']];
            let out = (x == 0) ? "S>adapt|globe|real|S ize|S ation|S al" : "S>T,T>adapt|globe|real|T ize|T ation|T al";
            out = (z == 0) ? addRule(out,"S>re S") : out;
            if (z > 0) {
                const additions = distribute([U[x]],distribute([PR[z]],V[y],' '),'>');
                for (let i = 0; i < additions.length; i++) {
                    out = addRule(out,additions[i]);
                }
            }
            out = (y == 0) ? addRule(out,"S>" + U[x] + " er") : out;
            out = (y == 1 && z == 0) ? addRule(addRule(out,"S>adapt er"),"S>" + U[x] + " ize er") : out;
            out = (y*z > 0) ? addRule(addRule(out,"S>V er"),"S>" + PR[z] + " V er") + ",V>adapt|" + U[x] + " ize" : out;
            out = (z == 2) ? out + ",P>re|P re" : out;
            return out.replaceAll("?","");
        } else {
            const x = parseInt(state.charAt(1));
            const y = parseInt(state.charAt(2));
            let out = (x == 0) ? "S>V ation|N al|A ize" : "S>V|N|A";
            out = out + ",V>adapt|A ize,N>globe|V ation,A>real|N al";
            out = (y == 1) ? addRule(out,"S>re S") : (y == 2) ? addRule(out,"S>re V") : (y == 3) ? addRule(out,"V>re V") : out;
            out = (x == 2) ? addRule(out,"N>V er") : (x == 3) ? addRule(out,"S>V er") : out;
            return out.replaceAll("?","");
        }
    }
    function morphoCheck(string) {
        const morphoCheckRules = ['S>V|N|A|V er,V>adapt|A ize|re V,N>globe|V ation,A>real|N al','S>V|N|A|V er|A er,V>adapt|A ize|re V,N>globe|V ation,A>real|N al','S>V|N|A,V>adapt|A ize|N ize|re V,N>globe|V ation|V er,A>real|N al'];
        if (parse(morphoCheckRules[0],string) != '') {
            return 'good';
        } else if (parse(morphoCheckRules[1],string) != '') {
            return 'Aer';
        } else if (parse(morphoCheckRules[2],string) != '') {
            return 'erize';
        } else {
            return 'bad';
        }
    }
    function morphoCyclic(s) {
        return !(s.includes('globe ize') || s.includes('adapt ize') || s.includes('ation ize') || s.includes('ize ize') || 
            s.includes('real al') || s.includes('adapt al') || s.includes('ize al') || s.includes('al al') || 
            s.includes('globe ation') || s.includes('real ation') || s.includes('al ation') || s.includes('ation ation'));
    }
    function modelingMorphoStart(sectionState) {
        const stateArray = sectionState.split(";");
        document.getElementById('morpho-test-box').dataset.text = '';
        drawBox(document.getElementById('morpho-test-box'));
        document.getElementById('morpho-test-response').innerText = 'Enter a string and press \u201CCheck\u201D to see if it is a grammatical English word in the target';
        const container = document.getElementById('morpho-container');
        while (container.hasChildNodes()) {
            container.removeChild(container.lastChild);
        }
        let newState = -3;
        document.getElementById('morpho-outro').style.display = 'none';
        for (let i = 0; i <= stateArray[0].length; i++) {
            let oldState = newState;
            newState = stateArray[i*4 + 1];const newPart = document.createElement('div');
            newPart.setAttribute('id','morpho-part-' + i);
            morphoAddStateText(newPart,oldState,newState);
            if (newState == '133') {
                document.getElementById('morpho-outro').style.display = 'block';
                enableButtons(document.getElementById('morpho-outro'));
                console.log('broken');
                break;
            }
            morphoAddSelector(newPart);
            morphoAddResponse(newPart,i*4 + 3,stateArray.slice(i*4 + 2, i*4 + 5));
            container.appendChild(newPart);
            disableButtons(newPart);
        }
        if (stateArray[0].charAt(0) == 'X') {
            document.getElementById('morpho-button').style.display = 'none';
        } else {
            document.getElementById('morpho-button').style.display = 'block';
        }
        enableButtons(container.lastChild);
    }
    function modelingMorphoRedraw(sectionState) {
        const stateArray = sectionState.split(";");
        const container = document.getElementById('morpho-container');
        if (stateArray[0].length + 1 > container.childNodes.length) {
            // Add new section
            disableButtons(container.lastChild);
            if (stateArray[stateArray.length - 4] == '133') {
                const newPart = document.createElement('div');
                newPart.setAttribute('id','morpho-part-' + stateArray[0].length);
                container.appendChild(newPart);
                morphoAddStateText(newPart,stateArray[stateArray.length - 8],stateArray[stateArray.length - 4]);
                document.getElementById('morpho-outro').style.display = 'block';
                enableButtons(document.getElementById('morpho-outro'));
            } else {
                const newPart = document.createElement('div');
                newPart.setAttribute('id','morpho-part-' + stateArray[0].length);
                morphoAddStateText(newPart,stateArray[stateArray.length - 8],stateArray[stateArray.length - 4]);
                morphoAddSelector(newPart);
                morphoAddResponse(newPart,stateArray.length - 2,stateArray.slice(-3));
                container.appendChild(newPart);
            }
        } else if (stateArray[stateArray.length - 4] != '133' && stateArray[stateArray.length - 3] != container.lastChild.lastChild.dataset.responseType) {
            // Change response type
            container.lastChild.removeChild(container.lastChild.lastChild);
            morphoAddResponse(container.lastChild,stateArray.length-2,stateArray.slice(-3));
        }
        const treeList = document.getElementById('modelingMorpho').getElementsByTagName('svg');
        for (tree of treeList) {
            tree.dataset.tree = stateArray[parseInt(tree.dataset.index,10)];
            tree.dataset.selected = stateArray[parseInt(tree.dataset.index,10)+1];
            if (tree.parentNode.parentNode.parentNode == container.lastChild && tree.dataset.treeType != 'error') {
                tree.dataset.selectLock = false;
            } else {
                tree.dataset.selectLock = true;
            }
            drawTrees(tree);
        }
        if (stateArray[0].charAt(0) == 'X') {
            document.getElementById('morpho-button').style.display = 'none';
        } else {
            document.getElementById('morpho-button').style.display = 'block';
        }
        document.getElementById('banner-out').innerText = getSectionStates();
    }
    function morphoHint(index) {
        const hints = ['Consider simple words that contain only two parts: a basic word, and a single prefix or suffix. Some of those combinations are ungrammatical, but are generated by this CFG, which means that it overgenerates. It should only take a few tries to find such a string.','What is the shortest word that this CFG can generate? Does that seem right?','Not all of the eight English word parts from the target are included in this CFG. What\u2019s missing, and how does that cause the CFG to undergenerate?','The rule used to add \u2018re-\u2019 is not quite right. Try putting it before other words, and seeing what is grammatical (and what is generated by this CFG).','The rule used to add \u2018re-\u2019 is not quite right. While introducing this domain, I mentioned some words in the target that you probably have never heard or read before. Some of those words are relevant to what is wrong with the rule used to add \u2018re-\u2019.','The rule used to add \u2018-er\u2019 is not quite right. Try testing it out with other suffixes, in different combinations.'];
        const hintDiv = document.createElement('div');
        hintDiv.style.marginTop = '1em';
        hintDiv.style.marginBottom = '1em';
        const hintNote = document.createElement('span');
        hintNote.setAttribute('class','collapse-note');
        hintNote.dataset.label = 'Hint';
        hintNote.innerText = hints[index];
        hintDiv.appendChild(hintNote);
        drawNote(hintNote);
        return hintDiv;
    }
    function morphoAddStateText(myParent,oldState, newState) {
        const outputDiv = document.createElement('div');
        if (newState == '-1') {
            const comment = document.createElement('p');
            comment.innerHTML = '<strong>Student:</strong> Let\u2019s start simple. There are three actual words, so I\u2019ll start by generating them with the following three rules:'
            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            const comment2 = document.createElement('p');
            comment2.innerHTML = 'This CFG clearly undergenerates, because it doesn\u2019t generate any of the words with prefixes or suffixes. To criticize the model, select \u201CUndergeneration\u201D below, then enter any grammatical word which contains a prefix or suffix (like \u201Creal-ize\u201D) and submit it.'
            outputDiv.appendChild(comment);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
            outputDiv.appendChild(comment2);
            myParent.appendChild(outputDiv);
            return;
        } else if (newState == '0000') {
            const comment = document.createElement('p');
            comment.innerHTML = '<strong>Student:</strong> Right, that undergenerated because I need to include the prefix and suffixes. Well, prefixes must appear at the start of the word, and suffixes must appear at the end of the word. I\u2019ll add a rule \u2018S \u2192 re S\u2019 which lets me add the prefix to the beginning, and similar rules to add all of the suffixes to the end:'
            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            const comment2 = document.createElement('p');
            comment2.innerHTML = 'This CFG clearly overgenerates, because it doesn\u2019t constrain which of the prefixes and suffixes appear, and in which order. To criticize the model, select \u201COvergeneration\u201D below, then enter a tree consistent with the new CFG which uses the prefixes or suffixes in an ungrammatical way and submit it. After this step, you will need to decide for yourself where to make undergeneration corrections and where to make undergeneration corrections (although there will be a hint that you can look at if you want).'
            outputDiv.appendChild(comment);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
            outputDiv.appendChild(comment2);
            myParent.appendChild(outputDiv);
            return;
        } else if (oldState.charAt(0) == '0' && newState.charAt(0) == '0') {
            // Intra-non-cyclic
            let addV = false;
            if (oldState.charAt(1) == '0' && newState.charAt(1) == '1') {
                const comment = document.createElement('p');
                comment.innerHTML = '<strong>Student:</strong> Based on your evidence, I looked at many words trying to see where the suffix \u2018-er\u2019 can appear. For example, \u201Cadapteral\u201D and \u201Crealerize\u201D are ungrammatical, but \u201Cadapter\u201D and \u201Crealizer\u201D are grammatical. I\u2019ve noticed a pattern: \u2018-er\u2019 can only appear at the very end of the word. In order to put this constraint into the CFG, I need to make it so that, after adding any suffix to the end of the word, you can\u2019t add an \u2018-er\u2019 to the nonterminal node to its left. I\u2019ll add a new nonterminal symbol \u2018T\u2019 (just the next letter after \u2018S\u2019), which will have all of the old rules that added suffixes to \u2018S\u2019, <em>except</em> adding \u2018-er\u2019. Then, if you want to add \u2018-er\u2019, you have to use a rule that includes \u2018T\u2019 to its left, instead of \u2018S\u2019. I\u2019ll also include a rule \u2018S \u2192 T\u2019 for words without \u2018-er\u2019. Let\u2019s try the following CFG:';
                outputDiv.appendChild(comment);
            } else if (oldState.charAt(2) == '0' && newState.charAt(2) == '1') {
                const comment = document.createElement('p');
                comment.innerHTML = '<strong>Student:</strong> Based on your evidence, I looked at many words trying to see what the suffix \u2018-er\u2019 can attach to. For example, \u201Cglober\u201D and \u201Cadaptationer\u201D are ungrammatical, but \u201Cadapter\u201D and \u201Crealizer\u201D are grammatical. I\u2019ve noticed a pattern: \u2018-er\u2019 can only follow \u2018adapt\u2019 (like in \u201Creadapter\u201D) and \u2018-ize\u2019 (like in \u201Crerealizer\u201D and \u201Cglobalizer\u201D). To include this restriction in my CFG, wherever I have a rule that would attach \u2018er\u2019, I\u2019ll replace it with one rule that fills in the entire word \u2018adapt er\u2019, and another rule that adds both suffixes \u2018ize er\u2019. This gives me the new CFG:';
                outputDiv.appendChild(comment);
                addV = true;
            } else if (oldState.charAt(3) == '0' && newState.charAt(3) == '1') {
                const comment = document.createElement('p');
                comment.innerHTML = '<strong>Student:</strong> Based on your evidence, I looked at many words trying to see what the preffix \u2018re-\u2019 can attach to. For example, \u201Creglobe\u201D and \u201Creglober\u201D are ungrammatical, but \u201Creadaptation\u201D and \u201Crerealize\u201D are grammatical. I\u2019ve noticed a pattern: \u2018re-\u2019 can only precede a word that contains \u2018adapt\u2019 or the suffix \u2018-ize\u2019. To include this restriction in my CFG, wherever I have a rule that would attach \u2018re\u2019, I\u2019ll replace it with one rule that fills in the entire word \u2018re adapt\u2019, and another rule that adds both the prefix \u2018re\u2019 and the suffix \u2018ize\u2019. This gives me the new CFG:';
                outputDiv.appendChild(comment);
                addV = true;
            } else if (oldState.charAt(3) == '1' && newState.charAt(3) == '2') {
                const comment = document.createElement('p');
                comment.innerHTML = '<strong>Student:</strong> Oops, I\u2019ve made the rules for \u2018re-\u2019 too strict.  I can no longer recursively add \u2018re-\u2019: Grammatical words like \u201Crereadapt\u201D can\u2019t be generated by my CFG. This feels a little clunky, but an easy way to allow for many copies of \u2018re-\u2019 is to replace \u2018re\u2019 in my rules with a new nonterminal symbol \u2018P\u2019 (which stands for \u201CPREFIX\u201D), and then add rules \u2018P > re\u2019 (which gets me back what I had before) as well as \u2018P > P re\u2019, which lets me recursively add as many copies of \u2018re-\u2019 as I want. This gives me the new CFG:';
                outputDiv.appendChild(comment);
            }
            if (addV && newState.charAt(3) != '0' && newState.charAt(2) != '0') {
                const badRules = document.createElement('div');
                badRules.setAttribute('class','tree-rules');
                const lastRuleText = Array.from(document.getElementById('morpho-container').lastChild.getElementsByClassName("tree-rules")).pop().dataset.rules + '|';
                badRules.dataset.rules = lastRuleText.replaceAll(',','|,').replace('S er|','adapt er|S ize er|').replace('re S|','re adapt|re S ize|').replace('T er|','adapt er|T ize er|').replaceAll('|,',',').slice(0,-1);
                outputDiv.appendChild(badRules);
                drawTreeRules(badRules);
                const comment = document.createElement('p');
                const U = (newState.charAt(1) == '1') ? 'T' : 'S';
                const PR = (newState.charAt(3) == '2') ? 'P' : 're';
                comment.innerHTML = '<strong>Student:</strong> And actually, there\u2019s some similarity between what\u2019s going on with \u2018re\u2019 and with \u2018er\u2019. They both require either \u2018adapt\u2019 or \u2018-ize\u2019. Thinking further, I realize that \u2018adapt\u2019 and words ending with \u2018-ize\u2019 are <em>verbs</em>: They represent actions, and can fit into sentence contexts like \u201CIt was \u005F\u005F\u005F\u005F-ed\u201D (\u201CIt was adapted\u201D, \u201CIt was realized\u201D). I\u2019ll include a new nonterminal symbol \u2018V\u2019 (standing for \u201CVERB\u201D), add the rules \u2018V > adapt\u2019 and \u2018V > ' + U + ' ize\u2019 to reflect what a verb can be, and then replace similar rules that use \u2018adapt\u2019 and \u2018' + U + ' ize\u2019 with a single rule that uses \u2018V\u2019. Oh, and I\u2019d better add a rule adding both \u2018' + PR + '\u2019 and \u2018er\u2019 to \u2018V\u2019 in case I want to use both of them. That all gives me this CFG:';
                outputDiv.appendChild(comment);
            }

            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
        } else if (oldState.charAt(0) == '0' && newState.charAt(0) == '1') {
            // Non-cyclic to cyclic
            if (oldState.charAt(2) == '0' || oldState.charAt(3) == '0') {
                const comment = document.createElement('p');
                comment.innerHTML = '<strong>Student:</strong> Okay, I\u2019m focusing on what the three suffixes \u2018-ize\u2019, \u2018-ation\u2019, and \u2018-al\u2019 can attach to, and I see a big pattern. \u2018-ize\u2019 can attach to \u2018real\u2019 and words ending in \u2018-al\u2019 like \u201Cglobal\u201D. Those words are all <em>adjectives</em>: They represent properties, and can fit into sentence contexts like \u201CIt was so \u005F\u005F\u005F\u005F\u201D (\u201CIt was so real\u201D, \u201CIt was so global\u201D). \u2018-ation\u2019 can attach to \u2018adapt\u2019 and words ending in \u2018-ize\u2019 like \u201Crealize\u201D. Those words are all <em>verbs</em>: They represent actions, and can fit into sentence contexts like \u201CIt was \u005F\u005F\u005F\u005F-ed\u201D (\u201CIt was adapted\u201D, \u201CIt was realized\u201D). \u2018-al\u2019 can attach to \u2018globe\u2019 and words ending in \u2018-ation\u2019 like \u201Cadaptation\u201D. Those words are all <em>nouns</em>: They represent things, and can fit into sentence contexts like \u201CIt was the \u005F\u005F\u005F\u005F\u201D (\u201CIt was the globe\u201D, \u201CIt was the adaptation\u201D).';
                outputDiv.appendChild(comment);
            } else {
                const comment = document.createElement('p');
                comment.innerHTML = '</strong> Okay, I\u2019m focusing on what the three suffixes \u2018-ize\u2019, \u2018-ation\u2019, and \u2018-al\u2019 can attach to, and I see a big pattern. \u2018-ation\u2019, just like \u2018re-\u2019 and \u2018-er\u2019, attaches to verbs. \u2018-ize\u2019 can attach to \u2018real\u2019 and words ending in \u2018-al\u2019 like \u201Cglobal\u201D. Those words are all <em>adjectives</em>: They represent properties, and can fit into sentence contexts like \u201CIt was so \u005F\u005F\u005F\u005F\u201D (\u201CIt was so real\u201D, \u201CIt was so global\u201D).  \u2018-al\u2019 can attach to \u2018globe\u2019 and words ending in \u2018-ation\u2019 like \u201Cadaptation\u201D. Those words are all <em>nouns</em>: They represent things, and can fit into sentence contexts like \u201CIt was the \u005F\u005F\u005F\u005F\u201D (\u201CIt was the globe\u201D, \u201CIt was the adaptation\u201D).';
                outputDiv.appendChild(comment);
            }
            const comment2 = document.createElement('p');
            comment2.innerHTML = '<strong>Student:</strong> Given all of this, I\u2019m going to use three nonterminal symbols for my different word types: \u2018A\u2019 for adjectives, \u2018V\u2019 for verbs, and \u2018N\u2019 for nouns. Then I\u2019ll use a rule like \u2018V \u2192 A ize\u2019, to show that some verbs are made of an adjective followed by \u2018-ize\u2019. All of the rules for \u2018-ize\u2019, \u2018-ation\u2019, and \u2018-al\u2019, as well as the full words, give me the following CFG:';
            outputDiv.appendChild(comment2);

            if (oldState == '0000') {
                const rules = document.createElement('div');
                rules.setAttribute('class','tree-rules');
                rules.dataset.rules = morphoRules(newState);
                outputDiv.appendChild(rules);
                drawTreeRules(rules);
                outputDiv.appendChild(morphoHint(1));
                myParent.appendChild(outputDiv);
                return;
            }

            const badRules = document.createElement('div');
            badRules.setAttribute('class','tree-rules');
            if (oldState.slice(1,3) == '00') {
                badRules.dataset.rules = 'S>V ation|N al|A ize,V>adapt|A ize,N>globe|V ation,A>real|N al';
            } else {
                badRules.dataset.rules = 'S>V|N|A,V>adapt|A ize,N>globe|V ation,A>real|N al';
            }
            outputDiv.appendChild(badRules);
            drawTreeRules(badRules);

            const comment3 = document.createElement('p');
            switch (oldState.slice(1)) {
                case '001':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018re-\u2019 can be said in a simpler way, by saying that it attaches to verbs. Then I\u2019ll include a rule \u2018S \u2192 re V\u2019 to include that prefix:';
                    break;
                case '002':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018re-\u2019 can be said in a simpler way, by saying that it attaches to verbs. Since I need the rule for adding \u2018re-\u2019 to be recursive, I\u2019ll add in a rule \u2018V \u2192 re V\u2019 to include that prefix:';
                    break;
                case '010':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018-er\u2019 can be said in a simpler way, by saying that it attaches to verbs. Since the word you get by attaching \u2018-er\u2019 to a verb is a noun (like \u201Cadapter\u201D), I\u2019ll include a rule \u2018N \u2192 V er\u2019 to include that suffix:';
                    break;
                case '011':
                    comment3.innerHTML = '<strong>Student:</strong> I\u2019ll include a rule \u2018S \u2192 re V\u2019 to include the prefix \u2018re-\u2019 and a rule \u2018N \u2192 V er\u2019 to include the suffix \u2018-er\u2019:';
                    break;
                case '012':
                    comment3.innerHTML = '<strong>Student:</strong> Since the word you get by attaching \u2018-er\u2019 to a verb is a noun (like \u201Cadapter\u201D), I\u2019ll include a rule \u2018N \u2192 V er\u2019 to include that suffix. In order to recursively add \u2018re-\u2019 to verbs, I\u2019ll include a rule \u2018V \u2192 re V\u2019. That gives me this CFG:';
                    break;
                case '100':
                    comment3.innerHTML = '<strong>Student:</strong> Now turning to \u2018-er\u2019, I see that it attaches to verbs, just like \u2018-ation\u2019 does. Since it needs to appear at the edge of a word, I\u2019ll include the rule \u2018S \u2192 V er\u2019 and get the following CFG:';
                    break;
                case '101':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018re-\u2019 can be said in a simpler way, by saying that it attaches to verbs, so I\u2019ll include a rule \u2018S \u2192 re V\u2019. Turning to \u2018-er\u2019, I see that it also attaches to verbs. Since it needs to appear at the edge of a word, I\u2019ll include the rule \u2018S \u2192 V er\u2019 and get the following CFG:';
                    break;
                case '102':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018re-\u2019 can be said in a simpler way, by saying that it attaches to verbs, so in order to recursively add \u2018re-\u2019, I\u2019ll include a rule \u2018V \u2192 re V\u2019. Turning to \u2018-er\u2019, I see that it also attaches to verbs. Since it needs to appear at the edge of a word, I\u2019ll include the rule \u2018S \u2192 V er\u2019 and get the following CFG:';
                    break;
                case '110':
                    comment3.innerHTML = '<strong>Student:</strong> Looking back, I now see that my analysis of \u2018-er\u2019 can be said in a simpler way, by saying that it attaches to verbs. Since it needs to appear at the edge of a word, I\u2019ll include the rule \u2018S \u2192 V er\u2019 and get the following CFG:';
                    break;
                case '111':
                    comment3.innerHTML = '<strong>Student:</strong> I\u2019ll include a rule \u2018S \u2192 re V\u2019 to include the prefix \u2018re-\u2019 and a rule \u2018S \u2192 V er\u2019 to include the suffix \u2018-er\u2019, which can only appear at the edge of the word:';
                    break;
                case '112':
                    comment3.innerHTML = '<strong>Student:</strong> In order to recursively add \u2018re-\u2019 to verbs, I\u2019ll include a rule \u2018V \u2192 re V\u2019. In order to add \u2018-er\u2019 to verbs only at the edges of words, I\u2019ll include a rule \u2018S \u2192 V er\u2019. This gives me the following CFG:';
                    break;
            }
            outputDiv.appendChild(comment3);
            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
        } else if (oldState.charAt(0) == '1' && newState.charAt(0) == '1') {
            const old_x = parseInt(oldState.charAt(1));
            const old_y = parseInt(oldState.charAt(2));
            const new_x = parseInt(newState.charAt(1));
            const new_y = parseInt(newState.charAt(2));
            // Intra-cyclic
            const comment = document.createElement('p');
            comment.innerHTML = '<strong>Student:</strong>';
            if (old_y == 0 && new_y == 1) {
                comment.innerHTML = comment.innerHTML + ' I need to include the prefix \u2018re-\u2019. I can apply it recursively (like in \u201Cre-re-readapt\u201D), so I\u2019ll add a rule \u2018S \u2192 re S\u2019, which can be applied over and over.?';
            } else if (old_y == 1 && new_y == 2) {
                comment.innerHTML = comment.innerHTML + ' Okay, so the prefix \u2018re-\u2019 can\u2019t attach to <em>everything</em>. Testing out a few words, it looks like it needs a verb after it, so I can use the rule \u2018S \u2192 re V\u2019.?';
            } else if (old_y == 2 && new_y == 3) {
                comment.innerHTML = comment.innerHTML + ' Oops, I\u2019ve made the rule for \u2018re-\u2019 too strict. With the rule \u2018S \u2192 re V\u2019, the prefix can only appear at the very beginning of the word and so can\u2019t be used again recursively. It also can only appear when the entire word following it is a verb, but sometimes \u2018re-\u2019 is grammatical before something that only contains a verb (like \u201Creadaptation\u201D, where \u201Cadapt\u201D is a verb, but \u201Cadaptation\u201D is not). By replacing it with \u2018V \u2192 re V\u2019, I can apply the rule recursively to generate words like \u201Cre-re-re-adapt\u201D, which is in the target, as well as apply the rule lower down in the tree to generate words like \u201Creadaptation\u201D.?';
            }
            if (old_x < new_x && new_x == 2) {
                comment.innerHTML = comment.innerHTML + '? I haven\u2019t included the suffix \u2018-er\u2019. It looks like it attaches to verbs to form nouns (like in \u201Cadapter\u201D and \u201Crealizer\u201D), so I\u2019ll add a rule \u2018N \u2192 V er\u2019.?';
            } else if (old_x == 2 && new_x == 3) {
                comment.innerHTML = comment.innerHTML + '? Based on your evidence, I looked at many words trying to see where the suffix \u2018-er\u2019 can appear. For example, \u201Cadapteral\u201D and \u201Crealerize\u201D are ungrammatical, but \u201Cadapter\u201D and \u201Crealizer\u201D are grammatical. I\u2019ve noticed a pattern: \u2018-er\u2019 can only appear at the right edge of the word. That\u2019s easy to fix in the CFG, by replacing the old \u2018-er\u2019 rule with a new one \u2018S \u2192 V er\u2019.?';
            }
            if (old_x == 0 && old_x < new_x) {
                comment.innerHTML = comment.innerHTML + '? I haven\u2019t put in a way for the CFG to generate words without suffixes! Thankfully, that should be an easy fix: I\u2019ll just have rules to go straight from \u2018S\u2019 to the other nonterminal symbols, rather than including the suffixes in those rules.';
            }
            comment.innerHTML = comment.innerHTML.replaceAll("??"," Also,").replaceAll("?","") + ' This gives me the CFG:';
            outputDiv.appendChild(comment);
            if (oldState == '103' && newState == '113') {
                const lastPart = document.getElementById('morpho-container').lastChild;
                const input = Array.from(lastPart.getElementsByClassName('input-box')).pop().dataset.text;
                if (input.contains('ize')) {
                    comment.innerHTML = '<strong>Student:</strong> After messing around with the CFG for a while, I realized that the following CFG both allows for the evidence you provided, as well as allowing the CFG to generate words without suffixes (which it previously couldn\u2019t do):'
                }
            }
            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
        } else {
            const lorem = document.createElement('p');
            lorem.innerText = "Lorem ipsum dolor " + oldState + ", " + newState;
            const rules = document.createElement('div');
            rules.setAttribute('class','tree-rules');
            rules.dataset.rules = morphoRules(newState);
            outputDiv.appendChild(lorem);
            outputDiv.appendChild(rules);
            drawTreeRules(rules);
        }

        if (newState.charAt(0) == '0') {
            outputDiv.appendChild(morphoHint(0));
        } else if (newState.charAt(1) == '0') {
            outputDiv.appendChild(morphoHint(1));
        } else if (newState.charAt(1) == '1' || newState.charAt(2) == '0') {
            outputDiv.appendChild(morphoHint(2));
        } else if (newState.charAt(2) == '1') {
            outputDiv.appendChild(morphoHint(3));
        } else if (newState.charAt(2) == '2') {
            outputDiv.appendChild(morphoHint(4));
        } else if (newState.charAt(1) == '2') {
            outputDiv.appendChild(morphoHint(5));
        }

        myParent.appendChild(outputDiv);
    }
    function morphoAddSelector(myParent) {
        const selector = document.createElement('select');
        selector.setAttribute('autocomplete','off');
        const choose = document.createElement('option');
        choose.setAttribute('value','choose');
        choose.innerText = "Choose an error type";
        const under = document.createElement('option');
        under.setAttribute('value','under');
        under.innerText = "Undergeneration";
        const over = document.createElement('option');
        over.setAttribute('value','over');
        over.innerText = "Overgeneration";
        selector.appendChild(choose);
        selector.appendChild(under);
        selector.appendChild(over);
        selector.addEventListener("change", (event) => {
            let stateArray = document.getElementById('modelingMorpho').dataset.state.split(';');
            const index = stateArray[0].length;
            if (event.currentTarget.value == 'choose') {
                stateArray = stateArray.slice(0,index * 4 + 2).concat(['choose','','']);
            } else if (event.currentTarget.value == 'under') {
                stateArray = stateArray.slice(0,index * 4 + 2).concat(['under','','']);
            } else if (event.currentTarget.value == 'over') {
                stateArray = stateArray.slice(0,index * 4 + 2).concat(['over','[S]','XX']);
            } else {
                alert('bad thing!');
            }
            document.getElementById('modelingMorpho').dataset.state = stateArray.toString().replace(/,/g,';');
            modelingMorphoRedraw(document.getElementById('modelingMorpho').dataset.state);
        },false);
        myParent.appendChild(selector);
    }
    function morphoAddResponse(myParent,index,responseArray) {
        const response = document.createElement('div');
        response.dataset.responseType = responseArray[0];
        const lastRuleText = Array.from(myParent.firstChild.getElementsByClassName("tree-rules")).pop().dataset.rules;
        let stateArray = document.getElementById('modelingMorpho').dataset.state.split(';');
        const currentState = stateArray[stateArray.length - 4];
        if (responseArray[0] == "under") {
            const description = document.createElement('p');
            description.innerText = 'To demonstrate that the CFG above undergenerates, please input a word below which is in the target (that is, is grammatical), but which is not generated by the CFG.'
            const inputBox = document.createElement('div');
            inputBox.setAttribute('class','input-box');
            inputBox.setAttribute('id','morpho-box-' + index);
            inputBox.dataset.text = responseArray[1];
            inputBox.dataset.editing = 'true';
            inputBox.dataset.cursorIndex = '0';
            const inputKeyboard = document.createElement('div');
            inputKeyboard.dataset.characters = 're,adapt,globe,real,al,ation,er,ize';
            inputKeyboard.dataset.for = 'morpho-box-' + index;
            const submitButton = document.createElement('button');
            submitButton.innerText = "Submit";
            submitButton.addEventListener("click", (event) => {
                const lastPart = document.getElementById('morpho-container').lastChild;
                const input = Array.from(lastPart.getElementsByClassName('input-box')).pop().dataset.text;
                const output = lastPart.getElementsByClassName('error-box').item(0);
                const outputTree = lastPart.getElementsByClassName('tree-frame').item(0);
                if (input == '') {
                    output.innerText = 'Please enter a string above that you think is in the target, but is not generated by the current CFG.';
                    output.style.display = 'block';
                    outputTree.parentNode.style.display = 'none';
                } else if (morphoCheck(input) != 'good') {
                    output.innerText = 'That is incorrect. The string you submitted is not in the target.';
                    output.style.display = 'block';
                    outputTree.parentNode.style.display = 'none';
                } else if (parse(lastRuleText, input) != '') {
                    output.innerText = 'That is incorrect. The string you submitted is generated by the current CFG, as shown in the tree below:';
                    output.style.display = 'block';
                    outputTree.parentNode.style.display = 'block';
                    outputTree.dataset.tree = parse(lastRuleText, input);
                    drawTrees(outputTree);
                } else {
                    output.style.display = 'none';
                    outputTree.parentNode.style.display = 'none';
                    const nexts = morphoNextStates(currentState);
                    for (let i = 0; i < nexts.length; i++) {
                        if (parse(morphoRules(nexts[i]),input) != '') {
                            stateArray[stateArray.length-2] = input;
                            stateArray = stateArray.concat([nexts[i],'choose','','']);
                            stateArray[0] = stateArray[0] + ".";
                            document.getElementById('modelingMorpho').dataset.state = stateArray.toString().replace(/,/g,';');
                            modelingMorphoRedraw(document.getElementById('modelingMorpho').dataset.state);
                            return;
                        }
                    }
                }
            });
            const errorFeedback = document.createElement('div');
            errorFeedback.setAttribute('class','error-box');
            errorFeedback.setAttribute('style','border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;');
            const errorTreeDiv = document.createElement('div');
            errorTreeDiv.style.display = 'none';
            const errorTree = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            errorTreeDiv.appendChild(errorTree);
            errorTree.setAttribute('viewbox','0 0 240 180');
            errorTree.setAttribute('width','240');
            errorTree.setAttribute('height','180');
            errorTree.setAttribute('class','tree-frame');
            errorTree.dataset.resize = true;
            errorTree.dataset.tree = '[S]';
            errorTree.dataset.selectLock = true;
            errorTree.dataset.treeType = 'error';
            response.appendChild(description);
            response.appendChild(inputBox);
            response.appendChild(inputKeyboard);
            response.appendChild(submitButton);
            response.appendChild(errorFeedback);
            response.appendChild(errorTreeDiv);
            myParent.appendChild(response);
            drawBox(inputBox);
            drawBoxLabels(inputKeyboard);
            initializeTree(errorTree);
        } else if (responseArray[0] == "over") {
            const description = document.createElement('p');
            description.innerText = 'To demonstrate that the CFG above overgenerates, please input a tree for a string which is not in the target (that is, is ungrammatical), but which is consistent with the CFG.';
            const treeDiv = document.createElement('div');
            const treeFrame = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            treeDiv.appendChild(treeFrame);
            treeFrame.setAttribute('viewbox','0 0 240 180');
            treeFrame.setAttribute('width','240');
            treeFrame.setAttribute('height','180');
            treeFrame.setAttribute('class','tree-frame');
            treeFrame.dataset.resize = true;
            treeFrame.dataset.minHeight = '130';
            treeFrame.dataset.tree = responseArray[1];
            treeFrame.dataset.index = index;
            treeFrame.dataset.treeType = 'draw';
            const treeLabels = document.createElement('div');
            treeLabels.setAttribute('class','tree-labels');
            treeLabels.dataset.nonterminals = rulesFromRuleText(lastRuleText)[0];
            treeLabels.dataset.terminals = 're,adapt,globe,real,ize,ation,al,er';
            treeLabels.dataset.index = index;
            const treeManips = document.createElement('div');
            treeManips.setAttribute('class','tree-manipulations');
            treeManips.dataset.index = index;
            const submitButton = document.createElement('button');
            submitButton.innerText = "Submit";
            submitButton.addEventListener("click", (event) => {
                const terms = ['re','adapt','globe','real','ize','ation','al','er'];
                const lastPart = document.getElementById('morpho-container').lastChild;
                const inputTree = Array.from(lastPart.getElementsByClassName('tree-frame')).pop();
                const input = readString(inputTree.dataset.tree, terms);
                const output = lastPart.getElementsByClassName('error-box').item(0);
                let newStateArray = document.getElementById('modelingMorpho').dataset.state.split(';');
                if (inputTree.dataset.tree.includes('\u2026')) {
                    output.innerText = 'Please label all nodes in the tree.';
                    output.style.display = 'block';
                } else if (input[0]) {
                    output.innerText = 'Please ensure all nonterminal nodes have children.';
                    output.style.display = 'block';
                } else if (frameErrors(inputTree, lastRuleText)[0] != 0) {
                    let errors = frameErrors(inputTree, lastRuleText);
                    if (errors[1][errors[1].length - 1] == 'start') {
                        output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
                    } else {
                        output.innerText = 'That is incorrect. There is no rule in the last CFG that would allow the highlighted node to have the child(ren) that it has in the tree.';
                        output.style.display = 'block';
                        newStateArray[index + 1] = errors[1][0];
                        document.getElementById('modelingMorpho').dataset.state = newStateArray.toString().replace(/,/g,';');
                        modelingMorphoRedraw(document.getElementById('modelingMorpho').dataset.state);
                    }
                    
                } else if (morphoCheck(input[1]) == 'good') {
                    output.innerText = 'That is incorrect. The string read off of the tree you submitted is in the target.';
                    output.style.display = 'block';
                } else {
                    output.style.display = 'none';
                    newStateArray[index + 1] = 'XX';
                    const nexts = morphoNextStates(currentState);
                    for (let i = 0; i < nexts.length; i++) {
                        if (currentState.charAt(0) == '0' && nexts[i].charAt(0) == '1' && morphoCyclic(input[1])) {
                            continue;
                        }
                        if (parse(morphoRules(nexts[i]),input[1]) == '') {
                            newStateArray = newStateArray.concat([nexts[i],'choose','','']);
                            newStateArray[0] = newStateArray[0] + ".";
                            document.getElementById('modelingMorpho').dataset.state = newStateArray.toString().replace(/,/g,';');
                            modelingMorphoRedraw(document.getElementById('modelingMorpho').dataset.state);
                            return;
                        }
                    }
                }
            });
            const errorFeedback = document.createElement('div');
            errorFeedback.setAttribute('class','error-box');
            errorFeedback.setAttribute('style','border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;');
            response.appendChild(description);
            response.appendChild(treeDiv);
            response.appendChild(treeLabels);
            response.appendChild(treeManips);
            response.appendChild(submitButton);
            response.appendChild(errorFeedback);
            myParent.appendChild(response);
            initializeTree(treeFrame);
            drawTreeLabel(treeLabels);
            drawManipulation(treeManips);
        } else {
            myParent.appendChild(response);
        }
    }
    sectionStarts.set('modelingMorpho',modelingMorphoStart);
    sectionRedraws.set('modelingMorpho',modelingMorphoRedraw);
</script>
<h2>Modeling data with CFGs</h2>

<p>Until now, you've been learning how to use CFGs on their own terms. In this section, we will see how to build CFGs in order to model different parts of languages. That means that we will make CFGs which generate all of the words or phrases found in that part, and nothing else. You will look at five different domains: First, some English morphology; second, palindromes; third, English number words; fourth; Yoruba number words; and fifth, Swiss German embedded clauses and case-marking. In the first domain, you will learn to find mistakes in CFGs by criticizing the proposals of an imaginary student. In the following three domains, you will build your own CFGs, each with less help than the one before. In the last domain, you will see a way in which CFGs <em>fail</em> to model language.</p>

<h3>Overgenerating and undergenerating</h3>

<p>Just as we want a road map to include all of the roads that actually exist, and no additional roads, when modeling some target part of language with a CFG, we want the CFG to generate everything in that target and nothing else.</p>

<p>There are two ways that the CFG model can fail, in principle. First, it might <em>undergenerate</em>. This happens when some word or sentence is found in the target, but is not generated by the CFG: when the CFG doesn&rsquo;t generate enough. Second, it might <em>overgenerate</em>. This happens when the CFG generates a word or sentence that is not found in the target: when the CFG generates too much.</p>

<p>Being able to recognize when a model undergenerates or overgenerates is an important ability for anyone who wants to build models, because it lets the modeler find problems that need to be fixed. The first exercise in this section focuses on this ability. You will be playing the role of a critic, pointing out problems as an imaginary student tries to build a CFG model for a piece of English. At each step you will point out a way in which the proposed CFG either undergenerates or overgenerates, after which the student will change their model to fix that error. Together, you will ultimately build a successful model that neither undergenerates nor overgenerates.</p>

<p>The student is attempting to model part of English <em>morphology</em>, the way in which new English words can be built up from smaller parts. The target includes all grammatical words in English which are made of the following eight parts (ignoring spelling rules):</p>

<p>Three basic words:</p>

<ol>
    <li>&ldquo;adapt&rdquo;</li>
    <li>&ldquo;globe&rdquo;</li>
    <li>&ldquo;real&rdquo;</li>
</ol>

<p>One prefix:</p>

<ol start="4">
    <li>&ldquo;re-&rdquo;, which can appear before a word &ldquo;X&rdquo; to make the word &ldquo;re-X&rdquo; with the meaning &ldquo;X again&rdquo;. For example, &ldquo;re-adapt&rdquo; means &ldquo;adapt again&rdquo;</li>
</ol>

<p>Four suffixes:</p>

<ol start="5">
    <li>&ldquo;-al&rdquo;, which can appear after a word &ldquo;X&rdquo; to make the word &ldquo;X-al&rdquo; with the meaning &ldquo;relating to X&rdquo;. For example, &ldquo;globe-al&rdquo; means &ldquo;relating to (the) globe&rdquo;</li>
    <li>&ldquo;-ation&rdquo;, which can appear after a word &ldquo;X&rdquo; to make the word &ldquo;X-ation&rdquo; with the meaning &ldquo;the process of Xing&rdquo;. For example, &ldquo;adapt-ation&rdquo; means &ldquo;the process of adapting&rdquo;</li>
    <li>&ldquo;-ize&rdquo;, which can appear after a word &ldquo;X&rdquo; to make the word &ldquo;X-ize&rdquo; with the meaning &ldquo;make something X&rdquo;. For example, &ldquo;real-ize&rdquo; means &ldquo;make something real&rdquo;</li>
    <li>&ldquo;-er&rdquo;, which can appear after a word &ldquo;X&rdquo; to make the word &ldquo;X-er&rdquo; with the meaning &ldquo;someone who Xs&rdquo;. For example, &ldquo;adapt-er&rdquo; means &ldquo;someone who adapts&rdquo;</li>
</ol>

<p>As a small complication, we will <em>not</em> include words in our target which are formed with the suffix &ldquo;-er&rdquo; with the meaning &ldquo;more&rdquo;, like the word &ldquo;real-er&rdquo;, meaning &ldquo;more real&rdquo;. If a proposed CFG generated the word &ldquo;real-er&rdquo;, then we would say that the model overgenerates, even though &ldquo;realler&rdquo; is a good English word.</p>

<p>While you may have heard or used some combinations of the above parts, there are many more that you've never heard before. Some of these new strings are terribly ungrammatical in English, like &ldquo;re-ize-globe-er-er&rdquo;. However, many of these new strings follow the structure of English and, given the right context, may be understandable. These are included in our target. A few examples are included below:</p>

<ul>
    <li>&ldquo;re-re-adapt&rdquo; means &ldquo;adapt again, again&rdquo;. You may imagine that someone frustrated with constantly moving to new environments might get mad about having to &ldquo;re-adapt&rdquo; again. Similarly, &ldquo;re-re-re-adapt&rdquo; means &ldquo;re-re-adapt again&rdquo;. While it becomes harder and harder to imagine situations in which stacks of &ldquo;re-&rdquo;s would be used, for the purposes of this exercise we consider them <em>all</em> good.</li>
    <li>You may have heard or read the word &ldquo;globe-al-ize-ation&rdquo;, which means &ldquo;the process of making something relating to the globe&rdquo;. A company may have a globalization team which studies how the company's products can be used worldwide. Such a team could be described as &ldquo;globe-al-ize-ation-al&rdquo;. If the company wants to make a team globalizational which is currently not, the company would have to go through a process to &ldquo;globe-al-ize-ation-al-ize&rdquo; it. That process itself is &ldquo;globe-al-ize-ation-al-ize-ation&rdquo;. The management team that directs that process is &ldquo;globe-al-ize-ation-al-ize-ation-al&rdquo;. This process of stacking suffixes is again pragmatically difficult, but we put no limit on it in our target.</li>
</ul>

<p>You can input any sequence of word-parts in the following textbox, and press the &ldquo;Check&rdquo; button to check whether it is considered grammatical in the target or not for the purposes of this exercise.</p>

<div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index="0" id='morpho-test-box' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='re,adapt,globe,real,ize,ation,al,er' data-for='morpho-test-box' id='morpho-test-labels' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="{
    const input = document.getElementById('morpho-test-box').dataset.text;
    const output = document.getElementById('morpho-test-response');
    if (input == '') {
        output.innerText = 'Enter a string and press \u201CCheck\u201D to see if it is a grammatical English word in the target';
        return;
    }
    const result = morphoCheck(input);
    if (result == 'bad') {
        output.innerText = 'That is not a grammatical word in the target';
    } else if (result == 'Aer') {
        output.innerText = 'That is not a grammatical word in the target. It is a grammatical word if you interpret the suffix \u2018-er\u2019 as meaning \u201Cmore\u201D, but we are not including that sense here.';
    } else if (result == 'erize') {
        output.innerText = 'That is not a grammatical word in the target. You might find it acceptable in certain contexts, but for the purposes of this exercise we exclude it.';
    } else {
        let interpretation = '';
        const inputArray = input.split(' ');
        const morphemeArray = ['adapt','globe','real','ize','ation','al','er'];
        const meaningArray = ['adapt','the globe','real','make something ','the process of ','relating to ','someone who '];
        for (let i = 0; i < inputArray.length; i++) {
            if (inputArray[inputArray.length-1-i] == 're') {
                interpretation = interpretation + ', again';
            } else {
                interpretation = interpretation + meaningArray[morphemeArray.indexOf(inputArray[inputArray.length-1-i])];
            }
        }
        interpretation = interpretation.replaceAll('who make','who makes').replaceAll('who adapt','who adapts').replaceAll('of make','of making').replaceAll('of adapt','of adapting');
        output.innerText = 'That is a grammatical word, and is in the target. It means \u201C' + interpretation + '\u201D';
    }
}">Check</button></div>
<div id='morpho-test-response'></div>
</div>

<p>Play around with the form above until you have a good sense of what the target is. Once you&rsquo;re ready, let&rsquo;s begin. Remember that you can always come back to check more strings.</p>

<div id="morpho-container"></div>

<!--
<div><button type="button" id="morpho-iterate" onclick="
    //..;-1;choose;;;0001;choose;;;0002;choose;;;
    const section = document.getElementById('modelingMorpho');
    const stateArray = section.dataset.state.split(';');
    const nextArray = morphoNextStates(stateArray[5]);
    if (nextArray.indexOf(stateArray[9]) == nextArray.length - 1) {
        stateArray[5] = morphoStates[morphoStates.indexOf(stateArray[5]) + 1];
        stateArray[9] = morphoNextStates(stateArray[5])[0];
    } else {
        stateArray[9] = nextArray[nextArray.indexOf(stateArray[9]) + 1];
    }
    section.dataset.state = stateArray.toString().replace(/,/g,';');
    modelingMorphoStart(section.dataset.state);
    modelingMorphoRedraw(section.dataset.state);
">Next</button></div>
-->

<div id="morpho-outro">
    <p>And that CFG models the target exactly! By pointing out where a series of CFGs undergenerated and overgenerated, you were able to guide the imaginary student to a successful CFG. In the coming sections, you will have more opportunities to practice identifying problems with CFGs in this way, sometimes on CFGs that you have constructed yourself.</p>
    
    <button id="morpho-button" onclick="parentSection(this).dataset.state='X' + parentSection(this).dataset.state.slice(1); state.push('modelingPalindromes'); redrawSections();">Continue</button>
    
</div>

</section>

<section id="modelingPalindromes" data-state=";[S];XX;[S];XX;;;;[S];XX;;;" data-initial-state=";[S];XX;[S];XX;;;;[S];XX;;;">
<script type="text/javascript">
    function modelingPalindromesStart(sectionState) {
        const toHide = ['palindrome-q1-output','palindrome-q2-output','palindrome-rule-output-1','palindrome-rule-output-2','palindrome-rule-output-3','palindrome-rule-disproof-1','palindrome-rule-disproof-2'];
        for (let i = 0; i < toHide.length; i++) {
            document.getElementById(toHide[i]).style.display = 'none';
        }
        const toErase = ['palindrome-rule-box-1','palindrome-rule-box-2','palindrome-rule-box-3','palindrome-rule-box-4','palindrome-test'];
        for (let i = 0; i < toErase.length; i++) {
            document.getElementById(toErase[i]).dataset.text = '';
        }
    }
    function modelingPalindromesRedraw(sectionState) {
        let stateArray = sectionState.split(";");
        for (let i = 0; i < 9; i++) {
            const part = document.getElementById('palindrome-part-'+(i+1));
            if (i < stateArray[0].length) {
                part.style.display = "block";
                disableButtons(part);
            } else if (i == stateArray[0].length) {
                part.style.display = "block";
                enableButtons(part);
            } else {
                part.style.display = "none";
            }
        }
        // Skip subsection on shortening rules if the rule is already short enough
        if (stateArray[5].length == 9) {
            document.getElementById('palindrome-part-4').style.display = "none";
        }
        // Fill all ruleboxes with the saved submitted rules
        if (stateArray[0].length > 2) {
            document.getElementById('palindrome-rule-box-1').dataset.text = stateArray[5];
            drawBox(document.getElementById('palindrome-rule-box-1'));
        }
        if (stateArray[0].length > 3) {
            document.getElementById('palindrome-rule-box-2').dataset.text = stateArray[6];
            drawBox(document.getElementById('palindrome-rule-box-2'));
        }
        if (stateArray[0].length > 5) {
            document.getElementById('palindrome-rule-box-3').dataset.text = stateArray[10];
            drawBox(document.getElementById('palindrome-rule-box-3'));
        }
        if (stateArray[0].length > 6) {
            document.getElementById('palindrome-rule-box-4').dataset.text = stateArray[11];
            drawBox(document.getElementById('palindrome-rule-box-4'));
        }
        // Draw all trees with data in the state
        const treeList = ['palindrome-tree-1','palindrome-tree-2','palindrome-tree-3'];
        const treeIndices = [1,3,8]
        for (let i = 0; i < treeList.length; i++) {
            const myTree = document.getElementById(treeList[i]);
            myTree.dataset.tree = stateArray[treeIndices[i]];
            myTree.dataset.selected = stateArray[treeIndices[i]+1];
            drawTrees(myTree);
        }
        // Draw all trees in the shortening rules subsection
        if (stateArray[5].length > 9) {
            //"S > a b c S c b a"
            let rule = stateArray[5];
            let sides = rule.split('\u2192')[1].split(' S');
            // [' a b c',' c b a']
            let newRule = "S \u2192" + sides[0] + sides[0] + " S" + sides[1] + sides[1];
            let lTree = ' [' + sides[0].trim().replaceAll(' ','] [') + ']';
            let rTree = ' [' + sides[1].trim().replaceAll(' ','] [') + ']';
            // [' [a] [b] [c]',' [c] [b] [a]']
            let complexTree = '[S' + lTree + lTree + ' [S [e] [v] [e]]' + rTree + rTree + ']';
            //[S [a] [b] [c] [a] [b] [c] [S [e] [v] [e]] [c] [b] [a] [c] [b] [a]]
            let simpleTree = '[S' + lTree + ' [S' + lTree + ' [S [e] [v] [e]]' + rTree + ']' + rTree + ']';
            //[S [a] [b] [c] [S [a] [b] [c] [S [e] [v] [e]] [c] [b] [a]] [c] [b] [a]]
            let lSide = (sides[0] + sides[0]).replaceAll(' ','');
            let rSide = (sides[1] + sides[1]).replaceAll(' ','');
            let generated = lSide + 'eve' + rSide;
            
            document.getElementById('palindrome-big-rule').innerText = rule;
            document.getElementById('palindrome-bigger-rule').innerText = newRule;
            document.getElementById('palindrome-bigger-generated').innerText = generated;
            document.getElementById('palindrome-tree-bigger').dataset.tree = complexTree;
            document.getElementById('palindrome-tree-big').dataset.tree = simpleTree;
            document.getElementById('palindrome-bigger-left').innerText = lSide;
            document.getElementById('palindrome-bigger-right').innerText = rSide;
        }
        // Make sure references to submitted rule has the right letters
        let myLetter = "e";
        if (stateArray[5].length == 9) {
            myLetter = stateArray[5].charAt(8);
        } else if (stateArray[6].length == 9) {
            myLetter = stateArray[6].charAt(8);
        }
        const letters = ["e","l","v"];
        const eRule = 'S \u2192 e S e';
        document.getElementById('palindrome-letter').innerText = myLetter;
        document.getElementById('palindrome-other-rule-1').innerText = eRule.replaceAll("e",letters[(letters.indexOf(myLetter) + 1) % 3]);
        document.getElementById('palindrome-other-rule-2').innerText = eRule.replaceAll("e",letters[(letters.indexOf(myLetter) + 2) % 3]);
        // Fill all radio buttons with saved values
        if (stateArray[7].length > 0) {
            document.getElementById('pal-q-' + stateArray[7].replaceAll(" ","")).checked = true;
        }
        if (stateArray[12].length > 0) {
            document.getElementById('pal-q2-' + stateArray[12]).checked = true;
        }
        // Draw all trees with data not in the state
        const moreTreesList = ['palindrome-tree-big','palindrome-tree-bigger','palindrome-tree-eve'];
        for (let i = 0; i < treeList.length; i++) {
            drawTrees(document.getElementById(moreTreesList[i]));
        }
        
        if (stateArray[0].charAt(0) == "X") {
            document.getElementById('palindrome-button').style.display = "none";
        } else {
            document.getElementById('palindrome-button').style.display = "block";
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionStarts.set('modelingPalindromes',modelingPalindromesStart);
    sectionRedraws.set('modelingPalindromes',modelingPalindromesRedraw);
    function palindromeBadFeedback(index) {
        let tree = document.getElementById('palindrome-tree-' + index);
        let rules = document.getElementById('palindrome-rules-' + index).dataset.rules;
        let output = document.getElementById('palindrome-q' + index + '-output');
        let stateArray = document.getElementById('modelingPalindromes').dataset.state.split(';');
        if (tree.dataset.tree.includes('\u2026')) {
            output.innerText = 'Please label all nodes in the tree.';
        } else if (frameErrors(tree,rules)[0] != 0) {
            let errors = frameErrors(tree,rules);
            if (errors[1][errors[1].length - 1] == 'start') {
                output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
            } else {
                output.innerText = 'That is incorrect. There is no rule in the proposed CFG that would allow the highlighted node to have the child(ren) that it has in the tree.';
                stateArray[index*2] = errors[1][0];
                document.getElementById('modelingPalindromes').dataset.state = stateArray.toString().replace(/,/g,';');
                sectionRedraws.get('modelingPalindromes')(document.getElementById('modelingPalindromes').dataset.state);
            }
            
        } else if (readString(tree.dataset.tree, ['e','l','v'])[0]) {
            output.innerText = 'Please ensure all nonterminal nodes have children.';
        } else if (isPalindrome(readString(tree.dataset.tree, ['e','l','v'])[1])) {
            output.innerText = 'That is incorrect. The string read off of this tree is a palindrome. Since you are trying to demonstrate that the CFG overgenerates, you want a string generated by the CFG which is not a palindrome.';
        } else {
            output.style.display = 'none';
            stateArray[0] = stateArray[0] + '.';
            document.getElementById('modelingPalindromes').dataset.state = stateArray.toString().replace(/,/g,';');
            sectionRedraws.get('modelingPalindromes')(document.getElementById('modelingPalindromes').dataset.state);
            return;
        }
        output.style.display = 'block';
    }
    function palindromeRuleFeedback(index) {
        let input = document.getElementById('palindrome-rule-box-' + index).dataset.text;
        let output = document.getElementById('palindrome-rule-output-' + index);
        if (input == '') {
            output.innerText = 'Please enter a rule above.';
        } if (!input.includes('\u2192')) {
            output.innerText = 'That is incorrect. A rule needs to include the symbol \u2192 to separate the left side from the right side.';
        } else if (input.split('\u2192').length != 2) {
            output.innerText = 'That is incorrect. A rule can only include one copy of the symbol \u2192 to separate the left side from the right side.';
        } else if (input.charAt(2)!='\u2192' || input.charAt(0) != 'S') {
            output.innerText = 'That is incorrect. The left side of the rule (to the left of the symbol \u2192) must be exactly one nonterminal symbol.';
        } else if (input.includes('\u03B5') && input.length > 5) {
            output.innerText = 'That is incorrect. The character \u03B5 can only be used on the right side of a rule on its own, when writing a rule that doesn\u2019t add any terminal symbols.';
        } else if (input.length < 5) {
            output.innerText = 'That is incorrect. You must have some sequence of terminal and nonterminal symbols on the right side of the rule.';
        } else if (input.split('S').length > 3) {
            output.innerText = 'That is incorrect. You demonstrated above that the rule \u2018S \u2192 S S\u2019 overgenerates because the two \u2018S\u2019s on the right side can be chosen in a context-free way. Your proposed rule runs into the same issue. Try a rule with only one \u2018S\u2019 on the right side.';
        } else if (input.split('S').length < 3) {
            output.innerText = 'That is incorrect. Your proposed rule needs to allow for recursion, which means that it needs an \u2018S\u2019 on the right side.';
        } else if (input.length == 5) {
            output.innerText = 'That is incorrect. While your proposed rule doesn\u2019t cause the CFG to overgenerate, it also doesn\u2019t allow the CFG to generate any new palindromes. Any rule that has the same right and left side will never change what a CFG can generate.';
        } else if (input.split('S')[2].length == 0) {
            output.innerText = 'That is incorrect. You demonstrated above that the rule \u2018S \u2192 e v S\u2019 overgenerates because we can\u2019t be certain that the symbol of the last child of \u2018S\u2019 will be the same as the the first terminal symbol in our rule, \u2018e\u2019. Your proposed rule runs into the same issue. Try a rule that has nonterminal symbols on both sides of the \u2018S\u2019 on the right side.';
        } 
        else if (!isPalindrome(input.slice(4))) {
            document.getElementById('palindrome-rule-disproof-' + index).style.display='block';
            let rightSide = input.slice(4);
            let treeString = '[S [' + rightSide.replaceAll(' ','] [') + ']]';
            document.getElementById('palindrome-disproof-tree-' + index).dataset.tree='[S [o] [o] [p] [s]]';
            const words = ['e v e','l e v e l','v e e v','l l l l l l'];
            for (s of words) {
                if (!isPalindrome(rightSide.replace('S',s))) {
                    treeString = treeString.replace('S]','S [' + s.replaceAll(' ','] [') + ']]');
                    document.getElementById('palindrome-disproof-tree-' + index).dataset.tree=treeString;
                    break;
                }
            }
            drawTrees(document.getElementById('palindrome-disproof-tree-' + index));
            let splits = rightSide.split("S");
            let superbad = false;
            if (splits[0].length > splits[1].length) {
                if (!isPalindrome(splits[0].slice(0,splits[1].length) + splits[1])) {
                    superbad = true;
                }
            } else if (splits[0].length < splits[1].length) {
                if (!isPalindrome(splits[0] + splits[1].slice(splits[1].length - splits[0].length))) {
                    superbad = true;
                }
            } else {
                superbad = true;
            }
            if (superbad) {
                output.innerText = 'That is incorrect: Your rule makes the CFG overgenerate. Below is a tree for a string which isn\u2019t a palindrome that can be built using your rule. In fact, there are no children that could be given to the \u2018S\u2019 node created by your rule to generate a palindrome, because the nonterminal nodes at the start and end of your rule don\u2019t match.';
            } else {
                output.innerText = 'That is incorrect: Your rule makes the CFG overgenerate. Below is a tree for a string which isn\u2019t a palindrome that can be built using your rule. The issue here is that your rule only works for certain choices of children given to the \u2018S\u2019 node created by your rule. To be a palindrome, a nonterminal symbol generated by your rule would have to match with a nonterminal child of \u2018S\u2019, but the children of \u2018S\u2019 can be chosen in a context-free way.';
            }
            
            output.style.display = 'block';
            return;
        } else if (index == 2 && input.length != 9) {
            output.innerText = 'That is incorrect. For this rule, you can only use three symbols on the right side.'
        } else {
            const stateArray = document.getElementById('modelingPalindromes').dataset.state.split(';'); 
            stateArray[4+index] = input;
            stateArray[0] = stateArray[0] + '.';
            if (input.length == 9 && index == 1) {
                stateArray[0] = stateArray[0] + '.';
            }
            document.getElementById('modelingPalindromes').dataset.state = (stateArray.toString()).replace(/,/g,';');
            output.style.display='none';
            document.getElementById('palindrome-rule-disproof-' + index).style.display='none';
            sectionRedraws.get('modelingPalindromes')(document.getElementById('modelingPalindromes').dataset.state);
            return;
        }
        output.style.display = 'block';
        document.getElementById('palindrome-rule-disproof-' + index).style.display='none';
    }

</script>

<h3>Palindromes</h3>

<p>A <em>palindrome</em> is something which is read the same forwards as backwards. That is, if you flip the order of the letters in a palindrome, so that the last letter becomes the first letter, the second-to-last letter becomes the second letter, and so on, then you get back the original text. Another way to say this is that the first letter is the same as the last letter, the second letter is the same as the second-to-last letter, and so on: The letters at the beginning and end <em>match</em>. The English language contains many words which are palindromes, like the ones listed below:</p>

<ul>
<li>noon</li>
<li>madam</li>
<li>redder</li>
<li>racecar</li>
<li>deleveled</li>
</ul>

<p>Daring wits have constructed sentence-length palindromes (where spaces are usually not considered in the reversal) as a way to show off. An early English example is &ldquo;Lewd did I live, & evil I did dwel&rdquo;, attributed to poet John Taylor (which has not aged well as English spelling standards have changed); a more recent example is mathematician Peter Hilton&rsquo;s &ldquo;Doc, note: I dissent. A fast never prevents a fatness. I diet on cod.&rdquo;</p>

<p>In this exercise, you will construct a CFG for all strings of the letters &lsquo;e&rsquo;, &lsquo;l&rsquo;, and &lsquo;v&rsquo; which are palindromes. Two of those strings are also common English words: namely, &ldquo;level&rdquo; and &ldquo;eve&rdquo;. There are many other strings which are not English words, but will still be included in the target, such as &ldquo;veev&rdquo; and &ldquo;llllll&rdquo;.</p>

<p>If you are uncertain about what is or is not a palindrome, you can test any string of letters below:</p>

<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='palindrome-test' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='e,l,v' data-for='palindrome-test' id='elv-input' style='margin-bottom:5px'></div>
<div><button type="button" id="palindrome-test-button" onclick="
if (document.getElementById('palindrome-test').dataset.text == '') {
    document.getElementById('palindrome-test-output').innerText = 'The string containing no letters is technically a palindrome';
} else if (isPalindrome(document.getElementById('palindrome-test').dataset.text)){
    document.getElementById('palindrome-test-output').innerText = '&ldquo;' + document.getElementById('palindrome-test').dataset.text.replaceAll(' ','') + '&rdquo; is a palindrome';
} else {
    document.getElementById('palindrome-test-output').innerText = '&ldquo;' + document.getElementById('palindrome-test').dataset.text.replaceAll(' ','') + '&rdquo; is not a palindrome';
}
">Test</button></div>
<div><span id="palindrome-test-output">Enter a string of letters above and hit the Test button to check if it is a palindrome</span></div>

<p>A useful hint is that a palindrome CFG can be written without using any nonterminal symbols other than &lsquo;S&rsquo;, the starting symbol. Any rule you consider will have &lsquo;S&rsquo; on the left side, and some sequence of &lsquo;S&rsquo;s, &lsquo;e&rsquo;s, &lsquo;l&rsquo;s, and &lsquo;v&rsquo;s on the right side.</p>

<p>We will start off using the small set of rules below:</p>

<div class='tree-rules' data-rules='S>e v e|l e v e l|v e e v|l l l l l l' id='palindrome-starters'></div>

<p>Even if new rules that you add allow for other ways to generate these palindromes, it can&rsquo;t hurt to include them at first. If adding a new rule to the CFG causes the CFG to overgenerate, then it must be the fault of the new rule.</p>

<p>This CFG, though, dramatically undergenerates. It only generates four strings. The target includes strings of unbounded length (for instance, any number of &lsquo;l&rsquo;s in a row). This means that we need to add rules that allow for recursion, which will have the nonterminal symbol &lsquo;S&rsquo; on the right side.</p>

<p>To start this activity, you will demonstrate that a couple proposed rules are no good because they cause the CFG to overgenerate. These demonstrations will eliminate a number of possible rules, so that you know where to look when proposing rules yourself.</p>

<div id='palindrome-part-1'>
<p><strong>Proposal #1:</strong> <q>If I have a palindrome like &ldquo;eve&rdquo; and repeat it twice, I still get a palindrome (&ldquo;eveeve&rdquo;). So I&rsquo;ll add the new rule &lsquo;S &rarr; S S&rsquo; to my CFG.</q></p>

<div class='tree-rules' data-rules='S>e v e|l e v e l|v e e v|l l l l l l|S S' id='palindrome-rules-1'></div>
<p>Demonstrate that this CFG overgenerates by submitting a tree for a string that isn&rsquo;t a palindrome, but which is consistent with the rules.</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-min-height="130" data-tree='' data-index="1" id='palindrome-tree-1' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S' data-terminals='e,l,v' data-index='1' id='palindrome-labels-1'></div>
<div class='tree-manipulations' data-index='1' id='palindrome-manips-1'></div>
<div><button type="button" onclick="palindromeBadFeedback(1);">Submit</button></div>
<div id='palindrome-q1-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id='palindrome-part-2'>
<p>Correct! Proposal #1 went wrong in assuming that the two nonterminal S nodes added by the rule &lsquo;S &rarr; S S&rsquo; would always have the same child nodes. Since CFGs are context-free, the two &lsquo;S&rsquo;s are totally unconstrained, and so you can generate plenty of non-palindromes. More generally, any rule added to our system that has two or more &lsquo;S&rsquo; symbols on the right side will fail, since you can&rsquo;t be certain that the letters generated by each will match those in the other. Since we need at least one &lsquo;S&rsquo; on the right side in order to allow for recursion, that means that our rule will have <em>exactly</em> one &lsquo;S&rsquo; on the right side.</p>

<p><strong>Proposal #2:</strong> <q>The word &ldquo;eve&rdquo; is a palindrome. If I add &ldquo;ev&rdquo; to the start of it, I still get a palindrome (&ldquo;eveve&rdquo;). So I&rsquo;ll add the new rule &lsquo;S &rarr; e v S&rsquo; to my CFG.</q></p>
    
<div class='tree-rules' data-rules='S>e v e|l e v e l|v e e v|l l l l l l|e v S' id='palindrome-rules-2'></div>
<p>Demonstrate that this CFG overgenerates by submitting a tree for a string that isn&rsquo;t a palindrome, but which is consistent with the rules.</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-min-height="130" data-tree='' data-index="3" id='palindrome-tree-2' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S' data-terminals='e,l,v' data-index='3' id='palindrome-labels-2'></div>
<div class='tree-manipulations' data-index='3' id='palindrome-manips-2'></div>
<div><button type="button" onclick="palindromeBadFeedback(2);">Submit</button></div>
<div id='palindrome-q2-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id='palindrome-part-3'>

<p>Correct! Proposal #2 went wrong by only reasoning about one palindrome (&ldquo;eve&rdquo;), and not considering whether the proposed rule would work with other palindromes. Since the first terminal symbol in that rule is &lsquo;e&rsquo; and the rule ends with &lsquo;S&rsquo;, the rule can only ever generate palindromes if the last letter generated by the right-hand &lsquo;S&rsquo; is &lsquo;e&rsquo; (to match the starting &lsquo;e&rsquo;). Since CFGs are context-free, that may not always happen, which means that the rule causes overgeneration. More generally, the right side of any rule added to our system can&rsquo;t start with a non-terminal if it ends with the terminal &lsquo;S&rsquo;, because we can&rsquo;t know that the last letter generated by that &lsquo;S&rsquo; will match the starting non-terminal.</p> 

<p>Now that you&rsquo;ve seen two ways that a proposed rule can fail, it&rsquo;s time for you to submit a proposal. This rule must have an &lsquo;S&rsquo; on the right side, in order to allow for recursion, and must not cause the CFG to overgenerate. Submit your proposed rule in the box below:</p>

<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='palindrome-rule-box-1' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,e,v,l,&epsilon;,&rarr;' data-for='palindrome-rule-box-1' id='rule-from-tree-labels-1' style='margin-bottom:5px'></div>
<div><button type="button" onclick="palindromeRuleFeedback(1);">Submit</button></div>
<div id='palindrome-rule-output-1' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div id='palindrome-rule-disproof-1' style='display:none'><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' id='palindrome-disproof-tree-1' class='tree-frame' data-select-lock="true"></svg></div>

</div>

<div id='palindrome-part-4'>
<p>Correct! Using your rule &lsquo;<span id="palindrome-big-rule">ASDF</span>&rsquo;, our CFG can generate an unbounded number of palindromes without generating anything that isn&rsquo;t a palindrome. The trick here is using the same symbols to the right side of the nonterminal symbol as to the left side of the nonterminal symbol, but in a reversed order. Since all of the added terminal letters match, as long as the center &lsquo;S&rsquo; generates a palindrome, the entire string will also be a palindrome.</p>

<p>However, there&rsquo;s a way to generate an even larger set of palindromes while using a rule that is simpler than your proposal.</p>

<p>To understand how your proposal could be simplified, first consider the rule proposal &lsquo;<span id="palindrome-bigger-rule">ASDF</span>&rsquo;. It also works, in that it allows the CFG to generate an unbounded number of palindromes without overgenerating. However, it both is more complex than your rule (because it uses many more symbols than yours) and is also weaker. By that, I mean that any string the CFG can generate using the more complex rule can also be generated by the CFG with your simpler rule. For example, we can generate the string &lsquo;<span id="palindrome-bigger-generated">ASDF</span>&rsquo; with the more complex rule, as seen in the following tree:</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='[S [l] [S [e] [v] [e]] [l]]' id='palindrome-tree-bigger' class='tree-frame'></svg></div>

<p>Using your simpler rule instead, we can build the following tree for the same string:</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='[S [l] [S [e] [v] [e]] [l]]' id='palindrome-tree-big' class='tree-frame'></svg></div>

<p>On the other hand, any instances of strings that are generated by using your rule just once<span class="collapse-note">, or, more generally, any odd number of times,</span> cannot be generated using the more complex rule, because the more complex rule treats the sequences &ldquo;<span id="palindrome-bigger-left">ASDF</span>&rdquo; and &ldquo;<span id="palindrome-bigger-right">ASDF</span>&rdquo; as chunks that cannot be broken down any more.</p>

<p>Similarly, there is a way to break down your rule in a way that makes things simpler and also more powerful. Below, submit a rule which uses only three symbols on the right side of the arrow, which doesn&rsquo;t cause the CFG to overgenerate.</p>

<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='palindrome-rule-box-2' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,e,v,l,&epsilon;,&rarr;' data-for='palindrome-rule-box-2' id='rule-from-tree-labels-2' style='margin-bottom:5px'></div>
<div><button type="button" onclick="palindromeRuleFeedback(2);">Submit</button></div>
<div id='palindrome-rule-output-2' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div id='palindrome-rule-disproof-2' style='display:none'><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' id='palindrome-disproof-tree-2' class='tree-frame' data-select-lock="true"></svg></div>

</div>

</div>

<div id='palindrome-part-5' style="display:none">
<p>Correct! By adding a single letter &lsquo;<span id="palindrome-letter">X</span>&rsquo; to the left edge and the same letter to the right edge, we preserve the edge-matching property of palindromes, while adding the fewest number of new letters.</p>

<p>By the same argument, we can also add the rules &lsquo;<span id="palindrome-other-rule-1">Y</span>&rsquo; and &lsquo;<span id="palindrome-other-rule-2">Z</span>&rsquo; to the CFG without overgenerating. If we include all of these rules, our new CFG includes the following rules:</p>

<div class='tree-rules' data-rules='S>e v e|l e v e l|v e e v|l l l l l l|e S e|l S l|v S v' id='palindrome-rules-3'></div>

<p>Which of the following rules can we now remove from the CFG without changing which strings the CFG can generate?</p>


<input type="radio" id="pal-q-eve" name="pal-q" value="e v e">
<label for="pal-q-eve" style="margin:0 2em 0 0">&lsquo;S &rarr; e v e&rsquo;</label><br>
<input type="radio" id="pal-q-level" name="pal-q" value="l e v e l">
<label for="pal-q-level" style="margin:0 2em 0 0">&lsquo;S &rarr; l e v e l&rsquo;</label><br>
<input type="radio" id="pal-q-veev" name="pal-q" value="v e e v">
<label for="pal-q-veev" style="margin:0 2em 0 0">&lsquo;S &rarr; v e e v&rsquo;</label><br>
<input type="radio" id="pal-q-llllll" name="pal-q" value="l l l l l l">
<label for="pal-q-llllll" style="margin:0 2em 0 0">&lsquo;S &rarr; l l l l l l&rsquo;</label><br>

<p>Normally you would use the rule you chose to generate the string on the right side of the rule. In order to demonstrate that the rule can be removed, submit a tree for the exact same string, which doesn&rsquo;t use that rule.</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-min-height="130" data-tree='' data-index="8" id='palindrome-tree-3' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S' data-terminals='e,l,v' data-index='8' id='palindrome-labels-3'></div>
<div class='tree-manipulations' data-index='8' id='palindrome-manips-3'></div>

<div><button type="submit" onclick="
{
    const tree = document.getElementById('palindrome-tree-3');
    const output = document.getElementById('palindrome-q3-output');
    const qs = document.querySelector('input[name=\'pal-q\']:checked');
    if (qs == null) {
        return;
    }
    const treeString = readString(tree.dataset.tree,['e','l','v'])[1];
    if (treeString != qs.value) {
        output.style.display = 'block';
        output.innerText = 'That is incorrect. In order to demonstrate that the rule \u2018S \u2192 ' + qs.value + '\u2019 is unnecessary, you need to show that you can generate the same string as it, without using it, but the string \u201C' + treeString + '\u201D is read off of your tree instead. Please submit a tree for the string on the right side of your selected rule.';
        return;
    }
    const fullRules = document.getElementById('palindrome-rules-3').dataset.rules;
    const prunedRules = fullRules.replace(qs.value + '|','');
    const fullErrors = frameErrors(tree, fullRules);
    const prunedErrors = frameErrors(tree, prunedRules);
    if (fullErrors[0] != 0 && fullErrors[1][fullErrors[1].length - 1] == 'start') {
        output.style.display = 'block';
        output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
        return;
    } else if (fullErrors[0] != 0) {
        output.style.display = 'block';
        output.innerText = 'That is incorrect. There is no rule that would allow the highlighted node to have the child(ren) that it has in the tree.';
        const section = document.getElementById('modelingPalindromes');
        let stateArray = section.dataset.state.split(';');
        stateArray[9] = fullErrors[1][0];
        section.dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('modelingPalindromes')(section.dataset.state);
        return;
    } else if (prunedErrors[0] != 0) {
        output.style.display = 'block';
        output.innerText = 'That is incorrect. In order to demonstrate that the rule \u2018S \u2192 ' + qs.value + '\u2019 is unnecessary, you need to show that you can generate the same string as it, without using it, but your tree uses that rule on the highlighted node.';
        const section = document.getElementById('modelingPalindromes');
        let stateArray = section.dataset.state.split(';');
        stateArray[9] = prunedErrors[1][0];
        section.dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('modelingPalindromes')(section.dataset.state);
        return;
    }
    output.style.display = 'none';
    const section = document.getElementById('modelingPalindromes');
    let stateArray = section.dataset.state.split(';');
    stateArray[7] = qs.value;
    stateArray[0] = stateArray[0] + '.';
    section.dataset.state = stateArray.toString().replace(/,/g,';');
    modelingPalindromesRedraw(parentSection(this).dataset.state);
}
">Submit</button></div>
<div id='palindrome-q3-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id='palindrome-part-6' style="display:none">
<p>That&rsquo;s correct! Now I want to play the same trick to remove the rule &lsquo;S &rarr; e v e&rsquo; from our CFG. What rule could we replace it with that has fewer symbols on the right side, without preventing the CFG from generating the palindrome &ldquo;eve&rdquo;?</p>

<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='palindrome-rule-box-3' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,e,v,l,&epsilon;,&rarr;' data-for='palindrome-rule-box-3' id='rule-from-tree-labels-3' style='margin-bottom:5px'></div>
<div><button type="button" onclick="
{
    const section = document.getElementById('modelingPalindromes');
    let stateArray = section.dataset.state.split(';');
    let input = document.getElementById('palindrome-rule-box-3').dataset.text;
    let output = document.getElementById('palindrome-rule-output-3');
    if (input == '') {
        output.innerText = 'Please enter a rule above.';
    } else if (!input.includes('\u2192')) {
        output.innerText = 'That is incorrect. A rule needs to include the symbol \u2192 to separate the left side from the right side.';
    } else if (input.split('\u2192').length != 2) {
        output.innerText = 'That is incorrect. A rule can only include one copy of the symbol \u2192 to separate the left side from the right side.';
    } else if (input.charAt(2)!='\u2192' || input.charAt(0) != 'S') {
        output.innerText = 'That is incorrect. The left side of the rule (to the left of the symbol \u2192) must be exactly one nonterminal symbol.';
    } else if (input.includes('\u03B5') && input.length > 5) {
        output.innerText = 'That is incorrect. The character \u03B5 can only be used on the right side of a rule on its own, when writing a rule that doesn\u2019t add any terminal symbols.';
    } else if (input.length < 5) {
        output.innerText = 'That is incorrect. You must have some sequence of terminal and nonterminal symbols on the right side of the rule.';
    } else if (input.split('\u2192')[1] == ' e v e') {
        output.innerText = 'That is incorrect. We want to replace the rule you just submitted! Find some other rule that will still let the CFG generate &ldquo;eve&rdquo;.';
    } else if (parse('S>e S e|l S l|v S v|' + input.split(' \u2192 ')[1],'e v e') == '') {
        output.innerText = 'That is incorrect. Adding that rule while won&rsquo;t let the CFG generate &ldquo;eve&rdquo; without the rule &lsquo;S &rarr; e v e&rsquo;.';
    } else {
        output.style.display = 'none';
        let stateArray = section.dataset.state.split(';');
        stateArray[0] = stateArray[0] + '.';
        stateArray[10] = input;
        section.dataset.state = stateArray.toString().replace(/,/g,';');
        modelingPalindromesRedraw(parentSection(this).dataset.state);
        return;
    }
    output.style.display = 'block';
}
">Submit</button></div>
<div id='palindrome-rule-output-3' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id='palindrome-part-7' style="display:none">
<p>Correct! Once again, we can &ldquo;peel off&rdquo; the outer two letters and see that, if we add the rule &lsquo;S &rarr; v&rsquo;, we can generate the string &ldquo;eve&rdquo; according to the following tree:</p>

<div><svg viewbox='0 0 240 180' width='240' height='180' data-tree='[S [e] [S [v]] [e]]' id='palindrome-tree-eve' class='tree-frame'></svg></div>

<p>And, as before, there&rsquo;s no reason to limit ourselves to just &lsquo;S &rarr; v&rsquo;: We can add &lsquo;S &rarr; e&rsquo; and &lsquo;S &rarr; l&rsquo;, too. Combining these with our earlier rules gives us the following CFG:</p>

<div class='tree-rules' data-rules='S>v e e v|l l l l l l|e S e|l S l|v S v|e|l|v' id='palindrome-rules-4'></div>

<p>These new rules aren&rsquo;t enough for us to remove rules &lsquo;S &rarr; v e e v&rsquo; or &lsquo;S &rarr; l l l l l l&rsquo;, because if we repeatedly peel off the outer pairs of letters from the palindromes &ldquo;veev&rdquo; and &ldquo;llllll&rdquo;, we don&rsquo;t end up with a single letter in the middle.</p>

<p>One way to simplify those rules is by replacing them with &lsquo;S &rarr; e e&rsquo; and &lsquo;S &rarr; l l&rsquo;. With a &ldquo;seed&rdquo; of two identical letters, you can build up to palindromes with even numbers of letters.</p>

<p>However, there&rsquo;s an even simpler way to remove those rules. What <em>single</em> rule can we add to the CFG that allows us to generate the strings &ldquo;veev&rdquo; and &ldquo;llllll&rdquo; without using the rules &lsquo;S &rarr; v e e v&rsquo; or &lsquo;S &rarr; l l l l l l&rsquo;, or overgenerating?</p>

<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='palindrome-rule-box-4' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='S,e,v,l,&epsilon;,&rarr;' data-for='palindrome-rule-box-4' id='rule-from-tree-labels-4' style='margin-bottom:5px'></div>
<div><button type="button" onclick="
{
    const section = document.getElementById('modelingPalindromes');
    let stateArray = section.dataset.state.split(';');
    let input = document.getElementById('palindrome-rule-box-4').dataset.text;
    let output = document.getElementById('palindrome-rule-output-4');
    if (input == '') {
        output.innerText = 'Please enter a rule above.';
    } else if (!input.includes('\u2192')) {
        output.innerText = 'That is incorrect. A rule needs to include the symbol \u2192 to separate the left side from the right side.';
    } else if (input.split('\u2192').length != 2) {
        output.innerText = 'That is incorrect. A rule can only include one copy of the symbol \u2192 to separate the left side from the right side.';
    } else if (input.charAt(2)!='\u2192' || input.charAt(0) != 'S') {
        output.innerText = 'That is incorrect. The left side of the rule (to the left of the symbol \u2192) must be exactly one nonterminal symbol.';
    } else if (input.includes('\u03B5') && input.length > 5) {
        output.innerText = 'That is incorrect. The character \u03B5 can only be used on the right side of a rule on its own, when writing a rule that doesn\u2019t add any terminal symbols.';
    } else if (input.length < 5) {
        output.innerText = 'That is incorrect. You must have some sequence of terminal and nonterminal symbols on the right side of the rule.';
    } else if (input.split('S').length > 3 || !isPalindrome(input.split(' \u2192 ')[1])) {
        output.innerText = 'That is incorrect. Adding that rule would make the CFG overgenerate.';
    } else if (parse('S>e S e|l S l|v S v|e|l|v|' + input.split(' \u2192 ')[1],'v e e v') == '' || parse('S>e S e|l S l|v S v|e|l|v|' + input.split(' \u2192 ')[1],'l l l l l l') == '') {
        const veev = (parse('S>e S e|l S l|v S v|e|l|v|' + input.split(' \u2192 ')[1],'v e e v') == '');
        const llllll = (parse('S>e S e|l S l|v S v|e|l|v|' + input.split(' \u2192 ')[1],'l l l l l l') == '');
        if (veev && !llllll) {
            output.innerText = 'That is incorrect. While you can generate &ldquo;llllll&rdquo; with that rule, you cannot generate &ldquo;veev&rdquo; with it.';
        } else if (!veev && llllll) {
            output.innerText = 'That is incorrect. While you can generate &ldquo;veev&rdquo; with that rule, you cannot generate &ldquo;llllll&rdquo; with it.';
        } else {
            output.innerText = 'That is incorrect. Adding that rule won&rsquo;t let the CFG generate either of &ldquo;veev&rdquo; or &ldquo;llllll&rdquo; without their particular rules.';
        }
    } else {
        output.style.display = 'none';
        let stateArray = section.dataset.state.split(';');
        stateArray[0] = stateArray[0] + '.';
        stateArray[11] = input;
        section.dataset.state = stateArray.toString().replace(/,/g,';');
        modelingPalindromesRedraw(parentSection(this).dataset.state);
        return;
    }
    output.style.display = 'block';
}
">Submit</button></div>
<div id='palindrome-rule-output-4' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>

</div>

<div id="palindrome-part-8">
<p>Correct! Our CFG now includes the following rules:</p>

<div class='tree-rules' data-rules='S>e S e|l S l|v S v|e|l|v|&epsilon;' id='palindrome-rules-5'></div>

<p>This set of rules lets us generate any palindrome made of the letters &lsquo;e&rsquo;, &lsquo;l&rsquo;, and &lsquo;v&rsquo;. To generate any palindrome from the starting node &lsquo;S&rsquo;, we work our way from the outside in, using a rule to add the first and last letters, then the second and second-to-last letters, and so on. If the palindrome contains an odd number of letters, then we use one of &lsquo;S &rarr; e&rsquo;, &lsquo;S &rarr; l&rsquo;, or &lsquo;S &rarr; v&rsquo; to add the middle letter and finish the tree. If the palindrome contains an even number of letters, then we use the recursive rules to add all of the letters, then use &lsquo;S &rarr; &epsilon;&rsquo; to finish the tree.</p>

<p>If we wanted to generate palindromes that included other letters, then we&rsquo;d just need to add a pair of rules for each additional letter: One recursive rule to add that letter to the beginning and end, and one single-symbol rule to add that letter in the middle of odd-length palindromes. For example, to add the letter &lsquo;d&rsquo; (to generate palindromes like &ldquo;deleveled&rdquo;), we&rsquo;d have to add the rules &lsquo;S &rarr; d S d&rsquo; and &lsquo;S &rarr; d&rsquo;</p>

<p> Maybe there&rsquo;s a way to simplify our rules so that you only have to add one rule for each new letter? After all, the rules are all pretty repetitive, and we&rsquo;ve been able to remove repetitions with CFGs before. Let&rsquo;s try adding a new nonterminal symbol &lsquo;LETTER&rsquo;, and use that instead of individual letters in our current rules (removing the repetitions). Then we need to include a rule for each letter, adding it as a child of &lsquo;LETTER&rsquo;. With our current set of letters, this gives us the following CFG:</p>

<div class='tree-rules' data-rules='S>LETTER S LETTER|LETTER|&epsilon;,LETTER>e|l|v' id='palindrome-rules-6'></div>

<p>Comprehension question: Would the above ruleset work instead to generate the same set of palindromes?</p>

<input type="radio" id="pal-q2-yes" name="pal-q2" value="yes">
<label for="pal-q2-yes" style="margin:0 2em 0 0">Yes</label>
<input type="radio" id="pal-q2-no" name="pal-q2" value="no">
<label for="pal-q2-no" style="margin:0 2em 0 0">No</label>
<button type="submit" id="pal-q2-submit" onclick="
{
    const qs = document.querySelector('input[name=\'pal-q2\']:checked');
    if (qs == null) {
        return;
    }
    parentSection(this).dataset.state = '.' + parentSection(this).dataset.state + qs.value;
    modelingPalindromesRedraw(parentSection(this).dataset.state);
}
">Submit</button>
</div>

<div id="palindrome-part-9">
<p>The above rules wouldn&rsquo;t work at all! This one was a bit of a trick question. This idea falls for the same mistake as the &lsquo;S &rarr; S S&rsquo; rule that you rejected earlier: Since each &lsquo;LETTER&rsquo; node can have <em>any</em> letter added as a child in a context-free way, there&rsquo;s no way to ensure that the letters added to the edges match. There&rsquo;s no better way to generate palindromes than the CFG that you came up with.</p>

<button id="palindrome-button" onclick="parentSection(this).dataset.state='X' + parentSection(this).dataset.state; state.push('modelingEnglishNumbers'); redrawSections();">Continue</button>

</div>


</section>


<section id="modelingEnglishNumbers" data-state=";;;;;[S];XX" data-initial-state=";;;;;[S];XX">
<script type="text/javascript">
    const units = ['','one','two','three','four','five','six','seven','eight','nine'];
    function numeralPronunciation(num) {
        num = parseInt(num,10);
        var out = '';

        if (Math.floor(num/1000000000)%1000 != 0) {
            out = out + hundredPronunciation(Math.floor(num/1000000000)%1000) + 'billion ';
        }
        if (Math.floor(num/1000000)%1000 != 0) {
            out = out + hundredPronunciation(Math.floor(num/1000000)%1000) + 'million ';
        }
        if (Math.floor(num/1000)%1000 != 0) {
            out = out + hundredPronunciation(Math.floor(num/1000)%1000) + 'thousand ';
        }
        if (num%1000 != 0) {
            out = out + hundredPronunciation(num%1000);
        }
        return out.trim();
    }
    function hundredPronunciation(num) {
        var out = '';
        if (num > 99) {
            out = units[Math.floor(num/100)%10] + ' hundred ';
        }
        if (num%100 != 0) {
            if (Math.floor(num/10)%10 > 1) {
            out = out + ['twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety'][Math.floor(num/10)%10-2] + ' ' + units[num%10] + ' ';
            } else if (Math.floor(num/10)%10 == 1) {
            out = out + ['ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen'][num%100-10] + ' ';
            } else {
            out = out + units[num%10] + ' ';
            }
        }
        return out;
    }
    function modelingEnglishNumbersStart(sectionState) {
        let stateArray = sectionState.split(";");
        const seed = Math.floor(parseInt(document.getElementById('frontmatter').dataset.state,10));
        document.getElementById("number-output").style.display = "none";
        document.getElementById("number-output-tree-div").style.display = "none";
        for (let i = 1; i <= 4; i++) {
            let box = document.getElementById('number-input-'+i);
            box.dataset.text = "";
            drawBox(box);
        }
        let slots = ["fifty","five hundred","five hundred fifty five"];
        const randSlots = permuteIndices(Math.floor(seed/720), slots);
        let targetNum = randSlots[0] + " million " + randSlots[1] + " thousand " + randSlots[2];
        document.getElementById("number-tree-target").innerText = targetNum;
        document.getElementById("number-tree-output").style.display = "none";
    }
    function modelingEnglishNumbersRedraw(sectionState) {
        const stateArray = sectionState.split(";");
        const startRules = "SUB-TEN>one|two|three|four|five|six|seven|eight|nine,TEENS>ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen,-TY>twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety";
        document.getElementById('number-rules-1').dataset.rules = startRules + ((stateArray[1] == "") ? "" : "," + stateArray[1].replaceAll('.',','));
        drawTreeRules(document.getElementById('number-rules-1'));
        for (let i = 2; i <= 4; i++) {
            document.getElementById('number-rules-'+i).dataset.rules = document.getElementById('number-rules-'+(i-1)).dataset.rules + ((stateArray[i] == "") ? "" : "," + stateArray[i].replaceAll('.',','));
            drawTreeRules(document.getElementById('number-rules-'+i));
        }
        for (let i = 0; i <= 5; i++) {
            if (i < stateArray[0].length) {
                document.getElementById("number-part-"+(i+1)).style.display = "block";
                disableButtons(document.getElementById("number-part-"+(i+1)));
            } else if (i == stateArray[0].length) {
                document.getElementById("number-part-"+(i+1)).style.display = "block";
                enableButtons(document.getElementById("number-part-"+(i+1)));
            } else {
                document.getElementById("number-part-"+(i+1)).style.display = "none";
            }
        }
        document.getElementById('number-tree').dataset.tree = stateArray[5];
        document.getElementById('number-tree').dataset.selected = stateArray[6];
        drawTrees(document.getElementById('number-tree'));

        if (stateArray[0].charAt(0) == "X") {
            document.getElementById('numbers-button').style.display = "none";
        } else {
            document.getElementById('numbers-button').style.display = "block";
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionStarts.set('modelingEnglishNumbers',modelingEnglishNumbersStart);
    sectionRedraws.set('modelingEnglishNumbers',modelingEnglishNumbersRedraw);
    function numberAddRule(index) {
        // Check for valid rule
        const input = document.getElementById('number-input-' + index).dataset.text;
        const inputArray = input.split(" ");
        const labels = document.getElementById('number-labels-'+index).dataset.characters.split(',');
        const output = document.getElementById('number-rule-output-' + index);
        if (input == "") {
            output.innerText = 'Please enter a rule to add to the CFG above.';
        } else if (!input.includes('\u2192')) {
            output.innerText = 'That rule is invalid. A rule needs to include the symbol \u2192 to separate the left side from the right side.';
        } else if (input.split('\u2192').length != 2) {
            output.innerText = 'That rule is invalid. A rule can only include one copy of the symbol \u2192 to separate the left side from the right side.';
        } else if (inputArray.length < 3) {
            output.innerText = 'That rule is invalid. You must have something on both sides of the rule.';
        } else if (inputArray[1] != '\u2192' || 
                    (labels.indexOf(inputArray[0]) > labels.indexOf(inputArray[1]))) {
            output.innerText = 'That rule is doesn\u2019t work. The left side of the rule (to the left of the symbol \u2192) has to be the new nonterminal symbol.';
        } else {
            addRuleToState(parentSection(event.target),index,input);
            output.style.display = "none";
            return;
        }
        output.style.display = "block";
    }
    function numberCFGFeedback(index) {
        const nonterminals = ["S","SUB-HUND","SUB-THOU","SUB-MILL","SUB-BILL","SUB-TEN","TEENS","-TY"];
        const backrules = ["SUB-TEN>five,TEENS>fifteen,-TY>fifty,S","SUB-TEN>five,TEENS>fifteen,-TY>fifty,SUB-HUND>fifty five,S","SUB-TEN>five,TEENS>fifteen,-TY>fifty,SUB-HUND>fifty five,SUB-THOU>five hundred,S","SUB-TEN>five,TEENS>fifteen,-TY>fifty,SUB-HUND>fifty five,SUB-THOU>five hundred,SUB-MILL>five thousand,S"];
        const targets = [["five","fifteen","fifty","fifty five"],["fifty five","five hundred","five hundred fifty five"],["five hundred","five hundred thousand","five hundred thousand five hundred"],["five thousand","five hundred million","five hundred million five thousand"]];
        const lengths = [4,3,3,3];
        const stateArray = document.getElementById('modelingEnglishNumbers').dataset.state.split(";");
        const output = document.getElementById("number-output");
        const treeOutput = document.getElementById("number-output-tree");
        const treeOutputDiv = document.getElementById("number-output-tree-div");
        const input = document.getElementById("number-rules-" + index).dataset.rules.replaceAll("?","");
        if (!input.includes(nonterminals[index])) {
          treeOutputDiv.style.display = "none";
          output.style.display = "block";
            output.innerText = "Please add rules to the CFG above one at a time by typing a rule in using the buttons and pressing \u201CAdd rule\u201D."
            return;
        }
        const newInput = input.substring(input.indexOf(nonterminals[index])+nonterminals[index].length).replaceAll(nonterminals[index],"S");
        const ruleCount = newInput.split("|").length;
        const ruleText = backrules[index-1] + newInput;
        const rules = rulesFromRuleText(ruleText);
        const productions = findProductions(ruleText, nonterminals, true);
        const cleanRules = removeUnproductive(rules, nonterminals, productions);
        const recursionOut = findRecursion(cleanRules, nonterminals, productions).replaceAll("[S","[" + nonterminals[index]);
        if (recursionOut != "") {
            treeOutputDiv.style.display = "block";
            treeOutput.dataset.tree = recursionOut;
            drawTrees(treeOutput);
            const treeText = readString(recursionOut, [])[1];
            output.style.display = "block";
            output.innerText = "Your CFG overgenerates. It generates the bad string \u201C" + treeText + "\u201D, as seen in the tree below. In particular, your CFG allows for recursion, and so the generation of infinitely many unboundedly long strings."
            return;
        }
        const extensionSet = breadthGeneration(cleanRules, nonterminals, productions);
        function validNumber(stringNum) {
            const stringArray = stringNum.split(" ");
            let current = 0;
            let sum = 0;
            for (let i = 0; i < stringArray.length; i++) {
                switch(stringArray[i]) {
                    case "five":
                        current += 5;
                        break;
                    case "fifteen":
                        current += 15;
                        break;
                    case "fifty":
                        current += 50;
                        break;
                    case "hundred":
                        current *= 100;
                        break
                    case "thousand":
                        sum += current*1000;
                        current = 0;
                        break;
                    case "million":
                        sum += current*1000000;
                        current = 0;
                        break;
                    default:
                        return true;
                }
            }
            sum = sum + current;
            return (numeralPronunciation(sum).trim() == stringNum);
        }
        for (const production of extensionSet) {
            if (!validNumber(production)) {
                output.innerText = "Your CFG overgenerates. It generates the bad string \u201C" + production + "\u201D, as seen in the tree below."
                output.style.display = "block";
                treeOutputDiv.style.display = "block";
                treeOutput.dataset.tree = parse(ruleText,production).replaceAll("[S","[" + nonterminals[index]);
                drawTrees(treeOutput);
                return;
            }
        }
        const targetSet = new Set(targets[index - 1]);
        const underGen = setDifference(targetSet,extensionSet);
        if (underGen.size > 0) {
            const badString = underGen.values().next().value;
            treeOutputDiv.style.display = "none";
            output.style.display = "block";
            output.innerText = "Your CFG undergenerates. It doesn\u2019t generate the string \u201C" + badString + "\u201D."
            return;
        }
        if (ruleCount > lengths[index-1]) {
            treeOutputDiv.style.display = "none";
            output.style.display = "block";
            output.innerText = "Your CFG generates the correct strings, but uses more rules than are necessary. Look for cases where a rule doesn\u2019t add anything beyond what the other rules already do, or where multiple rules could be rewritten as a single rule using a different nonterminal.";
            return;
        }
        output.style.display = "none";
        treeOutputDiv.style.display = "none";
        stateArray[0] = stateArray[0] + ".";
        if (index != 4) {
          //stateArray[index+1] = stateArray[index].replaceAll("?","");
        }
        stateArray[index] = stateArray[index].replaceAll("?","");
        document.getElementById('modelingEnglishNumbers').dataset.state = (stateArray.toString()).replace(/,/g,';');
        sectionRedraws.get('modelingEnglishNumbers')(document.getElementById('modelingEnglishNumbers').dataset.state);
    }
    function numberTreeFeedback() {
        const target = document.getElementById("number-tree-target").innerText;
        const rules = "S>SUB-BILL," + document.getElementById("number-rules-4").dataset.rules;
        const tree = document.getElementById('number-tree');
        const output = document.getElementById('number-tree-output');
        const terminals = ["one,two,three,four,five,six,seven,eight,nine,ten,eleven,twelve,thirteen,fourteen,fifteen,sixteen,seventeen,eighteen,nineteen,twenty,thirty,forty,fifty,sixty,seventy,eighty,ninety,hundred,thousand,million"];
        const section = document.getElementById('modelingEnglishNumbers');
        if (tree.dataset.tree.includes('\u2026')) {
            output.innerText = 'Please label all nodes in the tree.';
        } else if (readString(tree.dataset.tree, terminals)[1] != target) {
            output.innerText = 'That is incorrect. The string \u201C' + readString(tree.dataset.tree, terminals)[1] + '\u201D is read off of your tree, not the target string of \u201C' + target + '\u201D.';
        } else if (frameErrors(tree, rules)[0] != 0) {
            const errors = frameErrors(tree, rules);
            if (errors[1][errors[1].length - 1] == 'start') {
                output.innerText = 'That is incorrect. The root node of the tree needs to be labeled with the special symbol \u2018S\u2019.';
            } else {
                output.innerText = 'That is incorrect. There is no rule in your CFG that would allow the highlighted node to have the child(ren) that it has in the tree.';
                var stateArray = section.dataset.state.split(';');
                stateArray[6] = errors[1][0];
                section.dataset.state = stateArray.toString().replace(/,/g,';');
                sectionRedraws.get('modelingEnglishNumbers')(section.dataset.state);
            }
        } else {
            output.style.display = 'none';
            section.dataset.state = '.' + section.dataset.state;
            sectionRedraws.get('modelingEnglishNumbers')(section.dataset.state);
            return;
        }
        output.style.display = 'block';
    }
</script>

<h3>English counting numbers</h3>

<p>Speakers of many languages all over the world use the same system to write down numbers, but every language has its own system to <em>pronounce</em> numbers. For example, the number 2714 is pronounced in English as &ldquo;two thousand seven hundred fourteen&rdquo;. In this activity, you will construct a CFG that generates English pronunciations for all of the counting numbers (starting at &ldquo;one&rdquo;) below one billion.</p>

<p>If you aren't a native English speaker (or even just want to check your judgments against my assumptions), feel free to use the following input form. This form lets you <em>elicit</em> (or ask for) different number words, as though you were working with an English speaker whose language you want to model.</p>

<div><input type="number" id="numeral-input" name="numeral-input" min="1" max="999999999"> <button type="submit" onclick="document.getElementById('numeral-output').innerText = numeralPronunciation(document.getElementById('numeral-input').value);if(!document.getElementById('numeral-input').checkValidity()){document.getElementById('numeral-output').innerText ='Please enter a number greater than zero and less than one billion';}">Submit</button><br><span id="numeral-output">Enter a number and press &ldquo;Submit&rdquo; to elicit an English pronunciation</span></div>

<p>This version of the English number word system uses &ldquo;one&rdquo; in all contexts where &ldquo;a&rdquo; may be possible (it uses &ldquo;one hundred&rdquo;, not &ldquo;a hundred&rdquo;), and also doesn't use &ldquo;and&rdquo; when it may be possible to (it uses &ldquo;one hundred five&rdquo;, not &ldquo;one hundred and five&rdquo;). Some numbers may be pronounced differently by English speakers depending on context; for example, the number 1990 is pronounced as &ldquo;one thousand nine hundred ninety&rdquo; in general, but as &ldquo;nineteen hundred ninety&rdquo; or &ldquo;nineteen ninety&rdquo; when it is a year. This version eliminates these extra options, and sticks with the general pronunciation.</p>

<p>I've provided the rules below as a starting-point. These include three nonterminal nodes, with names that reflect which terminal nodes can appear as their children (for example, &lsquo;-TY&rsquo; can have as a child any number ending in &ldquo;-ty&rdquo;).</p>

<div class='tree-rules' data-rules='SUB-TEN>one|two|three|four|five|six|seven|eight|nine,TEENS>ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen,-TY>twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety' id='numeral-starters'></div>

<p>Below, you will gradually build up to larger and larger sets of numbers. At each step, I will give you a new nonterminal symbol, and you will come up with all the rules that are needed to let it generate the right set of pronunciations. You must specifically find the <em>fewest</em> rules that work, and you will be prompted to simplify your CFG if you use too many. However, you shoudn&rsquo;t be afraid to submit a larger CFG while you&rsquo;re still working out how to structure your rules, because any feedback on over- or undergeneration will be shown first. You will also only be given buttons for terminal symbols that are necessary for that step, which narrows your possible options.</p>


<div id="number-part-1">
<p>In this step, I introduce the new nonterminal symbol &lsquo;SUB-HUND&rsquo;. Your task is to add rules to the CFG which can apply to &lsquo;SUB-HUND&rsquo; so that any number below one hundred can be generated by a node labeled &lsquo;SUB-HUND&rsquo;. To add an individual rule, enter the rule in the input box, then press the &ldquo;Add rule&rdquo; button. To remove an individual rule that you&rsquo;ve already added, click on the round &ldquo;X&rdquo; button to its right. Once you&rsquo;re happy with your new additions, press the &ldquo;Submit CFG&rdquo; button.</p>

<div class='tree-rules' data-rules='' data-index='1' id='number-rules-1'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='number-input-1' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='SUB-HUND,&rarr;,SUB-TEN,TEENS,-TY' data-for='number-input-1' id='number-labels-1' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="numberAddRule(1);" id="number-add-1">Add rule</button></div>
<div id='number-rule-output-1' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="numberCFGFeedback(1);" id="number-submit-1" style="margin-top:1em">Submit CFG</button></div>
</div>

<div id="number-part-2">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>In this step, I introduce the new nonterminal symbol &lsquo;SUB-THOU&rsquo;. Your task is to add rules to the CFG which can apply to &lsquo;SUB-THOU&rsquo; so that any number below one thousand can be generated by a node labeled &lsquo;SUB-THOU&rsquo;.</p>

<div class='tree-rules' data-rules='' data-index='2' id='number-rules-2'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='number-input-2' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='SUB-THOU,&rarr;,SUB-TEN,TEENS,-TY,SUB-HUND,hundred' data-for='number-input-2' id='number-labels-2' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="numberAddRule(2);" id="number-add-2">Add rule</button></div>
<div id='number-rule-output-2' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="numberCFGFeedback(2);" id="number-submit-2" style="margin-top:1em">Submit CFG</button></div>
</div>

<div id="number-part-3">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>In this step, I introduce the new nonterminal symbol &lsquo;SUB-MILL&rsquo;. Your task is to add rules to the CFG which can apply to &lsquo;SUB-MILL&rsquo; so that any number below one million can be generated by a node labeled &lsquo;SUB-MILL&rsquo;.</p>

<div class='tree-rules' data-rules='' data-index='3' id='number-rules-3'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='number-input-3' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='SUB-MILL,&rarr;,SUB-TEN,TEENS,-TY,SUB-HUND,SUB-THOU,thousand' data-for='number-input-3' id='number-labels-3' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="numberAddRule(3);" id="number-add-3">Add rule</button></div>
<div id='number-rule-output-3' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="numberCFGFeedback(3);" id="number-submit-3" style="margin-top:1em">Submit CFG</button></div>
</div>

<div id="number-part-4">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>In this step, I introduce the new nonterminal symbol &lsquo;SUB-BILL&rsquo;. Your task is to add rules to the CFG which can apply to &lsquo;SUB-BILL&rsquo; so that any number below one billion can be generated by a node labeled &lsquo;SUB-BILL&rsquo;.</p>

<div class='tree-rules' data-rules='' data-index='4' id='number-rules-4'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='number-input-4' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='SUB-BILL,&rarr;,SUB-TEN,TEENS,-TY,SUB-HUND,SUB-THOU,SUB-MILL,million' data-for='number-input-4' id='number-labels-4' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="numberAddRule(4);" id="number-add-4">Add rule</button></div>
<div id='number-rule-output-4' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="numberCFGFeedback(4);" id="number-submit-4" style="margin-top:1em">Submit CFG</button></div>
</div>

<div id='number-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div id='number-output-tree-div'><svg viewbox='0 0 240 180' width='240' height='180' data-tree='' id='number-output-tree' class='tree-frame' data-resize='true'></svg></div>

<div id="number-part-5">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>Great work! Now by simply adding the rule &rsquo;S &rarr; SUB-BILL&rdquo;, you&rsquo;ve successfully constructed a CFG that can generate any number below one billion (and it wouldn&rsquo;t be hard to extend it to larger numbers). Let&rsquo;s try this CFG out for a spin, by constructing the tree structure for the English number pronunciation &ldquo;<span id="number-tree-target"></span>&rdquo;</p>

<div style="width: 100%;overflow-x:scroll;margin:.5em 0"><svg viewbox='0 0 240 180' width='240' height='180' data-resize="true" data-tree='' data-index="5" id='number-tree' class='tree-frame'></svg></div>
<div class='tree-labels' data-nonterminals='S,SUB-BILL,SUB-MILL,SUB-THOU,SUB-HUND,SUB-TEN,TEENS,-TY' data-terminals='five,fifteen,fifty,hundred,thousand,million' data-index='5' id='number-tree-labels'></div>
<div class='tree-manipulations' data-index='5' id='number-tree-manips'></div>
<div><button type="button" onclick="numberTreeFeedback();">Submit</button></div>
<div id='number-tree-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>


</div>

<div id="number-part-6">
<p>Correct! That&rsquo;s the biggest tree you&rsquo;ll have to submit for this activity.</p>
    
<p>There are a lot of nodes in that tree, compared to the number of words in the string read off of it (for example, you needed the chain of nodes &lsquo;SUB-THOU&rsquo;, parent of &lsquo;SUB-HUND&rsquo;, parent of &lsquo;-TY&rsquo;, parent of &lsquo;fifty&rsquo;). While it&rsquo;s possible to construct a CFG for this target that uses fewer nodes (by using more rules), I&rsquo;m using this example to demonstrate a common occurrence in models of syntax, in which a short word or sentence needs to be parsed by a very complicated tree structure within a particular model. This common occurrence has led to a common criticism of these kinds of models: <em>Do we really think that humans are building all of these complex structures in their minds when they use simple language?</em>
    
<p>There are three possible responses to this criticism. One is to accept the criticism, and to look for models of language that use simpler structures. Another is to argue that this complex structure is, in fact, generated by the mind for even simple words and sentences, and to look for evidence of this complexity. The last is to deny that the particular parts of the structure, like nodes and edges, are actually created in the human mind: The structures are somehow related to what the mind does, but not identical to it. All three of these responses have been made by linguists.</p>

<p>Having opened up but not dealt with a philosophical can of worms, let&rsquo;s return to our CFG practice, by looking beyond English.</p>

<button id="numbers-button" onclick="parentSection(this).dataset.state='X' + parentSection(this).dataset.state; state.push('modelingYorubaNumbers'); redrawSections();">Continue</button>

</div>




</section>
<section id="modelingYorubaNumbers" data-state=";;;;;;A;B;C;D;E;F;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;" data-initial-state=";;;;;;A;B;C;D;E;F;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;">
<!-- State is: Position; 5xRules ; 7xNonterminal Labels ; 40xNumber chart  -->
<script type="text/javascript">
    const yorubaTableNumbers = [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14],[10,20,30,40,50,60,70,80,90,100],[5,15,25,35,45,55,65,75,85,95],[30,31,32,33,34,35,36,37,38,39,40]];
    const yorubaNumbersList = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,20,25,30,31,32,33,34,35,36,37,38,39,40,45,50,55,60,65,70,75,80,85,90,95,100];
    const yorubaNumberOffset = 13;
    const yorubaNonterminalsOffset = 5;
    const yorubaRuleCount = [10,13,28,32,38];
    function modelingYorubaNumbersStart(sectionState) {
        let stateArray = sectionState.split(";");
        document.getElementById("yoruba-output").style.display = "none";
        document.getElementById("yoruba-output-tree-div").style.display = "none";
        for (let i = 1; i <= 5; i++) {
            // Fill texts
            let a = document.getElementById('y-numeral-output-'+i).innerText = "Enter a number and press \u2018Submit\u2019 to elicit a Yoruba pronunciation";
            // Empty boxes
            let box = document.getElementById('yoruba-input-'+i);
            box.dataset.text = "";
            drawBox(box);
            // Draw each table
            const table = document.getElementById("yoruba-table-" + i);
            while (table.hasChildNodes()) {
                table.removeChild(table.lastChild);
            }
            table.style = "width: 100%; table-layout: fixed; margin:1em;";
            // Draw table header
            const header = document.createElement("tr");
            table.appendChild(header);
            const n1 = document.createElement("th");
            const y1 = document.createElement("th");
            n1.style = "width: 10%";
            y1.style = "width: 40%; text-align: left;";
            header.appendChild(n1);
            header.appendChild(y1);
            n1.innerText = "#";
            y1.innerText = "Yoruba";
            header.appendChild(n1.cloneNode(true));
            header.appendChild(y1.cloneNode(true));
            // Draw all table values
            for (let j = 0; j < yorubaTableNumbers[i-1].length/2; j++) {
                const row = document.createElement("tr");
                table.appendChild(row);
                const num1 = document.createElement("td");
                num1.style = "text-align:center";
                num1.innerText = yorubaTableNumbers[i-1][2*j] + ":";
                const yor1 = document.createElement("td");
                row.appendChild(num1);
                row.appendChild(yor1);
                if (2*j+1 < yorubaTableNumbers[i-1].length) {
                    const num2 = num1.cloneNode(true);
                    num2.innerText = yorubaTableNumbers[i-1][2*j+1] + ":";
                    const yor2 = document.createElement("td");
                    row.appendChild(num2);
                    row.appendChild(yor2);
                }
            }
        }
    }
    function modelingYorubaNumbersRedraw(sectionState) {
        let stateArray = sectionState.split(";");
        for (let i = 1; i <= 7; i++) {
            document.getElementById('yoruba-nonterminal-'+i).value = stateArray[yorubaNonterminalsOffset+i];
        }
        const labelsArray = ['S,\u2192,kan,me,ma,ji,ta,rin,run,-un,fa,je,jo,san,-an,waa,\u03B5',
            'S,1,2,\u2192,kan,me,ma,ji,ta,rin,run,-un,fa,je,jo,san,-an,waa,mo,la,\u03B5',
            'S,1,2,3,4,\u2192,kan,me,ma,ji,ta,rin,run,-un,fa,je,jo,san,-an,waa,mo,la,ogun,ogbon,ogo,aado,\u03B5',
            'S,1,2,3,4,5,\u2192,kan,me,ma,ji,ta,rin,run,-un,fa,je,jo,san,-an,waa,mo,la,ogun,ogbon,ogo,aado,meed,dinl,\u03B5',
            'S,1,2,3,4,5,6,7,\u2192,kan,me,ma,ji,ta,rin,run,-un,fa,je,jo,san,-an,waa,mo,la,ogun,ogbon,ogo,aado,meed,dinl,lel,\u03B5'];
        for (let i = 1; i <= 5; i++) {
            let characterList = labelsArray[i-1];
            for (let j = 1; j <= 7; j++) {
                characterList = characterList.replace(j,stateArray[yorubaNonterminalsOffset + j]);
            }
            document.getElementById('yoruba-labels-'+i).dataset.characters = characterList;
            drawBoxLabels(document.getElementById('yoruba-labels-'+i));
        }
        
        for (let i = 1; i <= 5; i++) {
            document.getElementById('yoruba-rules-'+i).dataset.rules = stateArray[i].replaceAll('.',',');
            drawTreeRules(document.getElementById('yoruba-rules-'+i));
            const table = document.getElementById("yoruba-table-" + i);
            for (let j = 0; j < yorubaTableNumbers[i-1].length; j++) {
                table.childNodes[Math.floor(j/2)+1].childNodes[(j%2)*2+1].innerText = stateArray[yorubaNumberOffset + yorubaNumbersList.indexOf(yorubaTableNumbers[i-1][j])];
                //table.childNodes[Math.floor(j/2)+1].childNodes[(j%2)*2+1].innerText = "A";
            }
        }
        for (let i = 0; i <= 5; i++) {
          if (i < stateArray[0].length) {
            document.getElementById("yoruba-part-"+(i+1)).style.display = "block";
            if (i < 5) {
                document.getElementById("yoruba-submit-"+(i+1)).disabled = true;
                document.getElementById("yoruba-add-"+(i+1)).disabled = true;
                disableButtons(document.getElementById("yoruba-labels-"+(i+1)));
            }
          } else if (i == stateArray[0].length) {
            document.getElementById("yoruba-part-"+(i+1)).style.display = "block";
            if (i != 5) {
              document.getElementById("yoruba-submit-"+(i+1)).disabled = false;
              document.getElementById("yoruba-add-"+(i+1)).disabled = false;
              enableButtons(document.getElementById("yoruba-labels-"+(i+1)));
            }
          } else {
            document.getElementById("yoruba-part-"+(i+1)).style.display = "none";
          }
        }

        if (stateArray[0].charAt(0) == "X") {
            document.getElementById('yoruba-button').style.display = "none";
        } else {
            document.getElementById('yoruba-button').style.display = "block";
        }

        document.getElementById('banner-out').innerText = getSectionStates();
    }
    sectionStarts.set('modelingYorubaNumbers',modelingYorubaNumbersStart);
    sectionRedraws.set('modelingYorubaNumbers',modelingYorubaNumbersRedraw);
    function yorubaSubsets(level) {
        let output = new Array();
        if (level == 5) {
            for (let i = 1; i <= 194; i++) {
                output.push(i);
            }
            return output;
        }
        for (let i = 1; i <= 10; i++) {
            output.push(i);
        }
        if (level > 1) {
            for (let i = 11; i <= 14; i++) {
                output.push(i);
            }
        }
        if (level > 2) {
            for (let i = 20; i <= 190; i+= 10) {
                output.push(i);
            }
        }
        if (level > 3) {
            for (let i = 15; i <= 190; i+= 10) {
                output.push(i);
            }
        }
        return output;
    }
    function yorubaAddRule(index) {
        // Check for valid rule
        const input = document.getElementById('yoruba-input-' + index).dataset.text;
        const inputArray = input.split(" ");
        const labels = document.getElementById('yoruba-labels-'+index).dataset.characters.split(',');
        const output = document.getElementById('yoruba-rule-output-' + index);
        if (input == "") {
            output.innerText = 'Please enter a rule to add to the CFG above.';
        } else if (!input.includes('\u2192')) {
            output.innerText = 'That rule is invalid. A rule needs to include the symbol \u2192 to separate the left side from the right side.';
        } else if (input.split('\u2192').length != 2) {
            output.innerText = 'That rule is invalid. A rule can only include one copy of the symbol \u2192 to separate the left side from the right side.';
        } else if (inputArray.length < 3) {
            output.innerText = 'That rule is invalid. You must have something on both sides of the rule.';
        } else if (inputArray[1] != '\u2192' || 
                    (labels.indexOf(inputArray[0]) > labels.indexOf(inputArray[1]))) {
            output.innerText = 'That rule is invalid. The left side of the rule (to the left of the symbol \u2192) must be exactly one nonterminal symbol.';
        } else if (input.includes('\u03B5') && inputArray.length > 3) {
            output.innerText = 'That rule is invalid. The character \u03B5 can only be used on the right side of a rule on its own, when writing a rule that doesn\u2019t add any terminal symbols.';
        } else {
            addRuleToState(parentSection(event.target),index,input);
            output.style.display = "none";
            return;
        }
        output.style.display = "block";
    }
    function yorubaCFGFeedback(index) {
        // yoruba-output is red div, yoruba-output-tree is tree output
        const output = document.getElementById("yoruba-output");
        const treeOutput = document.getElementById("yoruba-output-tree");
        const treeOutputDiv = document.getElementById("yoruba-output-tree-div");
        const input = document.getElementById("yoruba-rules-" + index).dataset.rules.replaceAll("?","");
        if (input == "") {
          treeOutputDiv.style.display = "none";
          output.style.display = "block";
            output.innerText = "Please add rules to the CFG above one at a time by typing a rule in using the buttons and pressing \u201CAdd rule\u201D."
            return;
        }
        const rules = rulesFromRuleText(input);
        const stateArray = document.getElementById('modelingYorubaNumbers').dataset.state.split(";");
        const nonterminals = ["S"].concat(stateArray.slice(yorubaNonterminalsOffset+1,yorubaNonterminalsOffset+8));
        let productions = findProductions(input, nonterminals, true);
        //alert(JSON.stringify(Array.from(productions.entries())))
        //alert(JSON.stringify(rulesFromRuleText(input)));
        let cleanRules = removeUnproductive(rules, nonterminals, productions);
        //alert(JSON.stringify(cleanRules));
        const recursionOut = findRecursion(cleanRules, nonterminals, productions);
        if (recursionOut != "") {
            treeOutputDiv.style.display = "block";
            treeOutput.dataset.tree = recursionOut;
            drawTrees(treeOutput);
            const treeText = readString(recursionOut, [])[1];
            output.style.display = "block";
            output.innerText = "Your CFG overgenerates. It generates the string \u201C" + treeText + "\u201D, which is not the Yoruba pronunciation of any number, as seen in the tree below. In particular, your CFG allows for recursion, and so the generation of infinitely many unboundedly long strings."
            return;
        }
        //alert('start');
        productions = findProductions(input, nonterminals, false);
        cleanRules = removeUnproductive(rules, nonterminals, productions);
        const extensionSet = breadthGeneration(cleanRules, nonterminals, productions);
        //alert(JSON.stringify(Array.from(extensionSet)));
        const targetNumbers = yorubaSubsets(index);
        const targetPronunciations = targetNumbers.map((x) => yorubaNumeralPronunciation(x));
        const targetStrings = targetPronunciations.map((x) => decomposeYoruba(x));
        const targetSet = new Set(targetStrings);
        //alert(JSON.stringify(Array.from(targetSet)));
        const overGen = setDifference(extensionSet,targetSet);
        //alert(JSON.stringify(Array.from(overGen)));
        if (overGen.size > 0) {
            const allNumbers = yorubaSubsets(5);
            const allYoruba = allNumbers.map((x) => decomposeYoruba(yorubaNumeralPronunciation(x)));
            const superWrong = setDifference(overGen,allYoruba)
            let badString = "";
            if (superWrong.size > 0) {
                badString = superWrong.values().next().value;
                if (badString == "") {
                    output.innerText = "Your CFG overgenerates. It generates the string containing nothing (using a rule with \u03B5 on the right side), which is not the Yoruba pronunciation of any number, as seen in the tree below."
                } else {
                    output.innerText = "Your CFG overgenerates. It generates the string \u201C" + badString + "\u201D, which is not the Yoruba pronunciation of any number, as seen in the tree below."
                }
            } else {
                badString = overGen.values().next().value;
                output.innerText = "Your CFG overgenerates. It generates the string \u201C" + badString + "\u201D, as seen in the tree below. While that is the Yoruba pronunciation of the number " + allNumbers[allYoruba.indexOf(badString)] + ", that number isn\u2019t included in your current target set."
            }
            output.style.display = "block";
            treeOutputDiv.style.display = "block";
            treeOutput.dataset.tree = parse(input,badString);
            drawTrees(treeOutput);
            return;
        }
        const underGen = setDifference(targetSet,extensionSet);
        if (underGen.size > 0) {
            const badString = underGen.values().next().value;
            treeOutputDiv.style.display = "none";
            output.style.display = "block";
            output.innerText = "Your CFG undergenerates. It doesn\u2019t generate the string \u201C" + badString + "\u201D, which is the Yoruba pronunciation of the number " + targetNumbers[targetStrings.indexOf(badString)] + "."
            return;
        }
        if (deepCount(rules[1]) > yorubaRuleCount[index-1]) {
          treeOutputDiv.style.display = "none";
          output.style.display = "block";
            output.innerText = "Your CFG uses " + deepCount(rules[1]) + " rules, but you can only use " + yorubaRuleCount[index-1] + " rules for this section. Please remove unused rules, or find new ways to eliminate repetitions by finding patterns.";
            return;
        }
        output.style.display = "none";
        treeOutputDiv.style.display = "none";
        stateArray[0] = stateArray[0] + ".";
        if (index != 5) {
          stateArray[index+1] = stateArray[index];
        }
        stateArray[index] = stateArray[index].replaceAll("?","");
        document.getElementById('modelingYorubaNumbers').dataset.state = (stateArray.toString()).replace(/,/g,';');
        sectionRedraws.get('modelingYorubaNumbers')(document.getElementById('modelingYorubaNumbers').dataset.state);
        //alert(JSON.stringify(stateArray));
        // You did it!
    }
    function yorubaRename(index) {
        // Check if name is valid
        let name = document.getElementById('yoruba-nonterminal-'+index).value.toUpperCase();
        let stateArray = document.getElementById('modelingYorubaNumbers').dataset.state.split(";");
        let subArray = stateArray.slice(yorubaNonterminalsOffset + 1,yorubaNumberOffset);
        if (subArray.includes(name) || name == "") {
            sectionRedraws.get('modelingYorubaNumbers')(document.getElementById('modelingYorubaNumbers').dataset.state);
            return;
        }
        // Update name in textboxes
        for (let i = 1; i <= 5; i++) {
            let box = document.getElementById('yoruba-input-'+i);
            let text = " " + box.dataset.text.replaceAll(" ","  ") + " ";
            text = text.replaceAll(" " + stateArray[yorubaNonterminalsOffset+index] + " "," " + name + " ");
            box.dataset.text = text.replaceAll("  "," ").trim();
            drawBox(box);
        }
        // Store name in state
        for (let i = 0; i < 5; i++) {
            const regex = new RegExp("([\? \.\|])" + stateArray[yorubaNonterminalsOffset+index] + "(?=[\| \.>])", "g");
            stateArray[i+1] = (" " + stateArray[i+1] + " ").replace(regex,"$1" + name).trim();
        }
        stateArray[yorubaNonterminalsOffset+index] = name;
        // Update state
        document.getElementById('modelingYorubaNumbers').dataset.state = stateArray.toString().replace(/,/g,';');
        sectionRedraws.get('modelingYorubaNumbers')(document.getElementById('modelingYorubaNumbers').dataset.state);
    }
    function yorubaElicitation(index) {
        const output = document.getElementById('y-numeral-output-'+index);
        const input = document.getElementById('y-numeral-input-'+index);
        const inValue = parseInt(input.value,10);
        if (input.value == "") {
            output.innerText ='Enter a number above and hit the submit button to elicit a Yoruba pronunciation';
        } else if (!input.checkValidity()) {
            output.innerText ='Please enter a number greater than zero and less than 195';
        } else {
            output.innerText = yorubaNumeralPronunciation(inValue);
        }
        if (yorubaNumbersList.includes(inValue)) {
            let stateArray = document.getElementById('modelingYorubaNumbers').dataset.state.split(';');
            stateArray[yorubaNumberOffset+yorubaNumbersList.indexOf(inValue)] = output.innerText;
            document.getElementById('modelingYorubaNumbers').dataset.state = (stateArray.toString()).replace(/,/g,';');
            sectionRedraws.get('modelingYorubaNumbers')(document.getElementById('modelingYorubaNumbers').dataset.state);
        }
    }
    function decomposeYoruba(word) {
        const removals = ["\u0300","\u0301","\u0323"];
        const parts = ["ogun","ogbon","ogo","aado","meed","dinl","lel","mo","la","kan",
                        "ma","ji","ta","rin","run","-un","fa","je","jo","san","-an","waa"]
        for (let i = 0; i < removals.length; i++) {
            word = word.replaceAll(removals[i],"");
        }
        for (let i = 0; i < parts.length; i++) {
            word = word.replaceAll(parts[i],parts[i] + " ");
        }
        word = word.replace(/me([^e])/g,"me $1");
        word = word.trim();
        return word;
    }
</script>

<h3>Yoruba counting numbers</h3> 

<p>Yoruba is one of the most widely-spoken indigenous languages of Africa, used by millions of speakers primarily in Nigeria. It is a close cousin of the nearby Itsekiri and Igala languages, and a more distant cousin of many of the most-spoken languages of Africa, such as Swahili, Igbo, and Fula.</p>

<p>While speakers of Yoruba use the same digits to write numbers as speakers of English, they pronounce those numbers in a different way. In this activity, you will construct a CFG that generates Yoruba pronunciations for all of the counting numbers up to 194.<span class="collapse-note"> More specifically, the CFG will generate the pronunciations of numbers when used with a noun, analogous to the English &ldquo;two apples&rdquo;. Beyond 194, the system becomes more complicated than is helpful for this exercise, and also includes a lot more optionality, in which there are multiple ways to pronounce a single number.</span></p>

<p>Because this is your last big CFG to construct, I won&rsquo;t provide you with any rules to begin with, or limit the types of rules you can suggest. However, I will help you in two ways.</p>

<p>First, I have fixed the terminal symbols. This is a big hint, because it tells you how to split up the number words into parts. For example, the number 14 is pronounced as &ldquo;me&#769;&#803;ri&#768;nla&#769;&rdquo;, which looks like a single part. However, the list of terminal symbols includes &lsquo;me&rsquo;, &lsquo;rin&rsquo;, and &lsquo;la&rsquo;, which tells us that it&rsquo;s made of three parts, and suggests that those parts may show up in other numbers. These terminal symbols also don&rsquo;t include any accents or diacritics, and you shouldn&rsquo;t worry about modeling them with the CFG.<span class="collapse-note"> The accents above vowels represent <em>tones</em>, which tell you what pitch to pronounce the vowel at, and are affected by nearby tones in what is called &ldquo;tone sandhi&rdquo;. The dots below vowels change the vowel sounds entirely (like the difference between English &ldquo;bait&rdquo; and &ldquo;bet&rdquo;), but are also affected by nearby vowels in what is called &ldquo;vowel harmony&rdquo;. Having to include tone sandhi or vowel harmony in the CFG makes things less clear and less interesting, but they are very interesting in their own right!</span></p>

<p>Second, I will provide a little structure for you by asking you to construct a sequence of CFGs for gradually larger and larger sets of numbers, just like I did for the English numbers. However, this time you will be able to remove and revise rules from previous steps. This freedom is needed because, unlike in the English number problem, there are a few reasonable solutions for each step, and you don&rsquo;t always want to be limited to the decisions you made earlier. However, since one possible solution is simply listing 194 rules for each of the 194 numbers, and I don&rsquo;t want you to do that, I will limit the total number of rules you can include at each step, which will force you to eliminate redundancy using rules with nonterminal symbols.</p>

<p>At each step, there will be a form to elicit pronunciations and a chart that will permanently store relevant pronunciations, once elicited. In each table, the pronunciation of the Yoruba number is found to the right of the corresponding number.</p>

<div id="yoruba-part-1">
<p>For the first CFG, include rules that allow you to generate pronunciations for numbers 1 through 10. The chart below will include those pronunciations once you elicit them from the form above it. You can&rsquo;t use more than 10 rules, and you will need all of them. You won&rsquo;t use any nonterminal symbols other than &lsquo;S&rsquo;.</p>

<div><input type="number" id="y-numeral-input-1" min="1" max="194"> <button type="submit" onclick="yorubaElicitation(1);">Submit</button><br><span id="y-numeral-output-1"></span></div>

<table id="yoruba-table-1"></table>

<div class='tree-rules' data-rules='' data-index='1' id='yoruba-rules-1'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='yoruba-input-1' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='' data-for='yoruba-input-1' id='yoruba-labels-1' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="yorubaAddRule(1);" id="yoruba-add-1">Add rule</button></div>
<div id='yoruba-rule-output-1' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="yorubaCFGFeedback(1);" id="yoruba-submit-1" style="margin-top:1em">Submit CFG</button></div>

</div>

<div id="yoruba-part-2">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>For the next CFG, change your rules to add pronunciations for all numbers from 11 to 14. The chart below will include those pronunciations once you elicit them from the form. Just using one rule per pronunciation would take a total of 14 rules, but I won&rsquo;t let you use more than 13 rules. You will need to use at least one nonterminal symbol, and you can use up to two nonterminal symbols. The nonterminal symbols for this entire activity are the letters &lsquo;A&rsquo; through &lsquo;G&rsquo; by default, but you can rename them to any sequence of capital letters and hyphens (-) up to 10 characters long. New terminal symbols &lsquo;mo&rsquo; and &lsquo;la&rsquo; have been added to the end of your list.</p>

<div><input type="number" id="y-numeral-input-2" min="1" max="194"> <button type="submit" onclick="yorubaElicitation(2);">Submit</button><br><span id="y-numeral-output-2"></span></div>

<table id="yoruba-table-2"></table>

<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-1" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(1);">Rename</button> </div>
<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-2" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(2);">Rename</button> </div>

<div class='tree-rules' data-rules='' data-index='2' id='yoruba-rules-2'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='yoruba-input-2' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='' data-for='yoruba-input-2' id='yoruba-labels-2' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="yorubaAddRule(2);" id="yoruba-add-2">Add rule</button></div>
<div id='yoruba-rule-output-2' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="yorubaCFGFeedback(2);" id="yoruba-submit-2" style="margin-top:1em">Submit CFG</button></div>

</div>

<div id="yoruba-part-3">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>For the next CFG, change your rules to add pronunciations for all numbers that end in 0 (e.g. 20, 30, and so on, up to 190). The chart below will include those pronunciations up to 100 once you elicit them from the form above, although those are not <em>all</em> of the pronunciations you need to add. You cannot use more than 28 rules in total, and can use up to two additional nonterminal symbols. New terminal symbols &lsquo;ogun&rsquo;, &lsquo;ogbon&rsquo;, &lsquo;ogo&rsquo; and &lsquo;aado&rsquo; have been added to the end of your list.<span class="collapse-note" data-label="Hint"> What nonterminals can appear after &lsquo;ogo&rsquo; and &lsquo;aado&rsquo;? How do they relate to the numbers up to 10?</span></p>

<div><input type="number" id="y-numeral-input-3" min="1" max="194"> <button type="submit" onclick="yorubaElicitation(3);">Submit</button><br><span id="y-numeral-output-3"></span></div>

<table id="yoruba-table-3"></table>

<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-3" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(3);">Rename</button> </div>
<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-4" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(4);">Rename</button> </div>

<div class='tree-rules' data-rules='' data-index='3' id='yoruba-rules-3'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='yoruba-input-3' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='' data-for='yoruba-input-3' id='yoruba-labels-3' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="yorubaAddRule(3);" id="yoruba-add-3">Add rule</button></div>
<div id='yoruba-rule-output-3' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="yorubaCFGFeedback(3);" id="yoruba-submit-3" style="margin-top:1em">Submit CFG</button></div>

</div>

<div id="yoruba-part-4">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>For the next CFG, add rules to add pronunciations for all numbers that end in 5 (e.g. 15, 25, 35, and so on, up to 185). The chart below will include those pronunciations under 100 once you elicit them from the form above. You cannot use more than 32 rules in total, and can use up to one additional nonterminal symbol. New terminal symbols &lsquo;meed&rsquo; and &lsquo;dinl&rsquo; have been added to the end of your list.</p>

<div><input type="number" id="y-numeral-input-4" min="1" max="194"> <button type="submit" onclick="yorubaElicitation(4);">Submit</button><br><span id="y-numeral-output-4"></span></div>

<table id="yoruba-table-4"></table>

<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-5" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(5);">Rename</button> </div>

<div class='tree-rules' data-rules='' data-index='4' id='yoruba-rules-4'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='yoruba-input-4' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='' data-for='yoruba-input-4' id='yoruba-labels-4' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="yorubaAddRule(4);" id="yoruba-add-4">Add rule</button></div>
<div id='yoruba-rule-output-4' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="yorubaCFGFeedback(4);" id="yoruba-submit-4" style="margin-top:1em">Submit CFG</button></div>

    
</div>

<div id="yoruba-part-5">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>Now for the hardest part! For the last CFG, add rules to add pronunciations for all remaining numbers up to 194. The chart below will include pronunciations for numbers 30 through 40 once you elicit them from the form above. You cannot use more than 38 rules in total, and can use up to two additional nonterminal symbols. The new terminal symbol &lsquo;lel&rsquo; has been added to the end of your list.</p>

<div><input type="number" id="y-numeral-input-5" min="1" max="194"> <button type="submit" onclick="yorubaElicitation(5);">Submit</button><br><span id="y-numeral-output-5"></span></div>

<table id="yoruba-table-5"></table>

<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-6" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(6);">Rename</button> </div>
<div>Nonterminal symbol: <input type="text" class="normal" id="yoruba-nonterminal-7" size="15" maxlength="10" style="text-transform:uppercase" onkeydown="return /[a-z\-]/i.test(event.key)"/> <button type="submit" onclick="yorubaRename(7);">Rename</button> </div>

<div class='tree-rules' data-rules='' data-index='5' id='yoruba-rules-5'></div>
<div class='input-box' data-text='' data-editing='true' data-cursor-index='0' id='yoruba-input-5' style='margin-bottom:5px'></div>
<div class='box-labels' data-characters='' data-for='yoruba-input-5' id='yoruba-labels-5' style='margin-bottom:5px'></div>
<div><button type="submit" onclick="yorubaAddRule(5);" id="yoruba-add-5">Add rule</button></div>
<div id='yoruba-rule-output-5' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div><button type="submit" onclick="yorubaCFGFeedback(5);" id="yoruba-submit-5" style="margin-top:1em">Submit CFG</button></div>

</div>

<div id='yoruba-output' style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(150,0,0); display:none;"></div>
<div id='yoruba-output-tree-div'><svg viewbox='0 0 240 180' width='240' height='180' data-tree='' id='yoruba-output-tree' class='tree-frame' data-resize='true'></svg></div>


<div id="yoruba-part-6">
<p style="border-style:solid; padding:.05em .2em; margin:.5em 0; border-color:rgb(0,150,0);">Correct!</p>
<p>Fantastic work! In this exercise, you demonstrated a powerful ability to use CFGs as a model for a language that you (probably) don&rsquo;t speak. This was the most complex CFG I&rsquo;ll ask you to think about. In the next and last section, we will explore the limits of CFGs.</p>

<button id="yoruba-button" onclick="parentSection(this).dataset.state='X' + parentSection(this).dataset.state; state.push('tempDone'); redrawSections();">Continue</button>
    
</div>

<!-- addRuleToState(state, index, newRule) -->

<p></p>


</section>


<section id="tempDone">
<h3>That&rsquo;s all!</h3>
<p>I will finish this section after I&rsquo;ve hashed things out with a Swiss German speaker.</p>
</section>
    

<section id="modelingSwissGerman" data-state="" data-initial-state="">

<h3>Context-Sensitivity in Language and Z&#252;rich German</h3>

<p>Recall that CFGs are called context-free because the how rules are applied depends only on the symbols of nonterminal nodes, and not on any other context from the rest of the tree. In this section we will explore some aspects of languages that seem to depend on surrounding context, and the extent to which those aspects can or cannot be modeled using CFGs.</p>

<p>Consider the fragment of English that is generated by the following CFG:</p>


<div class='tree-rules' data-rules='S>the NOUN VERB,NOUN>cat|cats|person|people|sheep,VERB>call|calls|hiss|hisses|cry|cries' id='no-agreement'></div>


<p>This CFG generates a few grammatical English sentences, but also generates many sentences that aren&rsquo; grammatical in standard English. Demonstrate that this CFG overgenerates below by submitting a tree that follows the rules above, but which generates a string that isn&rsquo;t grammatical in English.</p>

<!--
    Tree input
-->

<p>Correct! This CFG doesn&rsquo;t include the pattern in English which is called <em>subject-verb agreement</em>. In these sentences, the noun is called a subject, and may be either singular, representing just one individual (&lsquo;cat&rsquo;, &lsquo;person&rsquo;, and &lsquo;sheep&rsquo;) or plural, representing a group (&lsquo;cats&rsquo;, &lsquo;people&rsquo;, and &lsquo;sheep&rsquo;). In English, a sentence with a singular subject must be followed by a verb which ends in the letter &lsquo;s&rsquo; (&lsquo;calls&rsquo;, &lsquo;hisses&rsquo;, and &lsquo;cries&rsquo;), while a plural subject must be followed by a verb which doesn&rsquo;t (&lsquo;call&rsquo;, &lsquo;hiss&rsquo;, and &lsquo;cry&rsquo;). Based on this pattern, we see that the sentences &ldquo;the cat hisses&rdquo; and &ldquo;the cats hiss&rdquo; are grammatical, while the sentences &ldquo;the cat hiss&rdquo; and &ldquo;the cats hisses&rdquo; are ungrammatical.</p>

<p>This seems like a context-sensitivity: The choice of subject and verb depend on each other. This alone is enough to push some researchers away from CFGs as a choice for modeling language, and many modern theories of agreement use different mechanisms to explain agreement and to explain how phrases fit together MORE.</p>

<p>However, it&rsquo;s important to note that we <em>are</em> able to model only the grammatical English sentences in our fragment using a CFG. Look at the rules below, understanding &lsquo;SG&rsquo; as an abbreviation for &ldquo;singular&rdquo; and &lsquo;PL&rsquo; as an abbreviation for &ldquo;plural&rdquo;.</p>

<div class='tree-rules' data-rules='S>the SG-NOUN SG-VERB|the PL-NOUN PL-VERB,SG-NOUN>cat|person|sheep,PL-NOUN>cats|people|sheep,SG-VERB>calls|hisses|cries,PL-VERB>call|hiss|cry' id='with-agreement'></div>

<p>In CFGs, how rules are applied depends only on the symbols of nonterminal nodes. However, if we are able to include information about context in the symbols of nonterminal nodes, then even apparently context-sensitive patterns can be modeled using a context-free system.</p>

<p>As far as I am aware, all syntactic structures in English can be represented in this way, if not in a particularly clean or pleasant way. This is part of the reason that CFGs continue to be used in natural language processing to represent the structure of English. In order to push the bounds of CFGs, we will need to turn to languages other than English.</p>

<p>Swiss German refers to the variety of German spoken in ASDF Switzerland. It is part of a broad range of dialects of German, and is most similar to ASDF.</p>

<p>Swiss German, as with other forms of German, includes a case system. A case system is something like the subject-verb agreement that we saw in English, where there is a particular way that nouns and verbs match. In languages with a case system, nouns will appear in different forms depending on their relationships to verbs.</p>

<p>English pronouns like &ldquo;he&rdquo;, &ldquo;she&rdquo;, and &ldquo;they&rdquo; show a limited case system. In a sentence following the template &ldquo;&mldr; saw &mldr;&rdquo;, &ldquo;he&rdquo;, &ldquo;she&rdquo;, and &ldquo;they&rdquo; appear before the verb, but &ldquo;him&rdquo;, &ldquo;her&rdquo;, and &ldquo;them&rdquo; appear after the verb.</p>

<p>Swiss German has a more complicated system.</p>


</section>

</main>

<script type="text/javascript">



//document.getElementById('frontmatter').dataset.state=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER);
document.getElementById('frontmatter').dataset.state=5;

arrangeSections();
startSections();
redrawSections();

function parentSection(node) {
  var current = node;
  while (current.parentNode != null) {
    if (current.nodeName == "SECTION") {
      return current;
    }
    current = current.parentNode;
  }
  return null;
}

function disableButtons(node) {
    Array.from(node.getElementsByTagName('button')).forEach((element) => element.disabled = (element.className == "collapse-button") ? false : true);
    Array.from(node.getElementsByTagName('select')).forEach((element) => element.disabled = true);
    Array.from(node.getElementsByTagName('input')).forEach((element) => element.disabled = (element.getAttribute('type') == 'radio'));
}

function enableButtons(node) {
    Array.from(node.getElementsByTagName('button')).forEach((element) => element.disabled = false);
    Array.from(node.getElementsByTagName('select')).forEach((element) => element.disabled = false);
    Array.from(node.getElementsByTagName('input')).forEach((element) => element.disabled = !(element.getAttribute('type') == 'radio'));
}

// Return a version of the indices array permuted according to the given seed
function permuteIndices(seed, indices) {
    const base = indices.length;
    var indicesCopy = [...indices];
    var seedCopy = seed;
    var newIndices = new Array(0);
    for (let i = base; i > 0; i--) {
        newIndices.push(indicesCopy[seedCopy%i]);
        indicesCopy.splice(seedCopy%i,1);
        seedCopy = Math.floor(seedCopy/i);
    }
    return newIndices
}

function substitute(original, replacement, inputString) {
    var output = "";
    for (let i = 0; i < inputString.length; i++) {
        var matched = false;
        for (let j = 0; j < original.length; j++) {
            if (inputString.slice(i,i+original[j].length) == original[j]) {
                output = output + replacement[j];
                matched = true;
                i += original[j].length-1;
                break;
            }
        }
        if (!matched) {
            output = output + inputString.charAt(i);
        }
    }
    return output;
}

function arrangeSections() {
    var allSections = document.querySelectorAll("section");
    for (let i = 0; i < state.length; i++) {
        if (allSections[i].id != state[i]) {
            document.getElementById("main").insertBefore(document.getElementById(state[i]),document.getElementById(allSections[i].id));
            allSections = document.querySelectorAll("section");
        }
        allSections[i].style.display="block"
    }
    for (let i = state.length; i < allSections.length; i++) {
        allSections[i].style.display="none";
    }
}

function startSections() {
    var allSections = document.querySelectorAll("section");
    for (let section of allSections) {
        if (sectionStarts.has(section.id)) {
            sectionStarts.get(section.id)(section.dataset.state);
        }
    }
}

function redrawSections() {
    arrangeSections();
    count = 0;
    var allSections = document.querySelectorAll("section");
    for (let section of allSections) {
        if (sectionRedraws.has(section.id) && section.style.display == 'block') {
            sectionRedraws.get(section.id)(section.dataset.state);
            count ++;
        }
    }
    document.getElementById('banner-out').innerText = getSectionStates();
    renderProgressBar(count);
}

function getSectionStates() {
  var allSections = document.querySelectorAll("section");
  const sectionStates = new Array(state.length);
  for (let i = 0; i < sectionStates.length; i++) {
    sectionStates[i] = allSections[i].dataset.state;
  }
  return sectionStates;
}

function putSectionStates(statesArray) {
  var allSections = document.querySelectorAll("section");
  for (let i = 0; i < allSections.length; i++) {
    if (i < statesArray.length) {
        allSections[i].dataset.state = statesArray[i];
        if (sectionRedraws.has(allSections[i].id)) {
            sectionRedraws.get(allSections[i].id)(allSections[i].dataset.state);
        }
    } else {
        allSections[i].dataset.state = allSections[i].dataset.initialState;
    }
  }
}

function renderProgressBar(currentSection) {
    const progressBar = document.getElementById("progressBar");
    progressBar.innerHTML = "";
    let sectionIndex = 0;

    progressBarChunks.forEach((block) => {
        const blockDiv = document.createElement("div");
        blockDiv.classList.add("progress-block");
        if (sectionIndex + block.length <= currentSection) {
            blockDiv.classList.add("complete-block");
            const sectionDiv = document.createElement("div");
            length = block.reduce((a, b) => a + b, 0)
            sectionDiv.style.width = `${length + block.length*.1 - .1}em`;
            sectionDiv.classList.add("progress-section");
            sectionIndex += block.length
            blockDiv.appendChild(sectionDiv);
        } else {
            block.forEach((length) => {
                const sectionDiv = document.createElement("div");
                sectionDiv.style.width = `${length}em`;
                sectionDiv.classList.add("progress-section");
                if (sectionIndex < currentSection) {
                    sectionDiv.classList.add("complete-section");
                } else {
                    sectionDiv.classList.add("incomplete-section");
                }
                sectionIndex++;
                blockDiv.appendChild(sectionDiv);
            });
        }
        blockDiv.lastChild.style.borderRight = '0px';
        progressBar.appendChild(blockDiv);
    });
}

var allLinks = document.getElementsByTagName('a');
for (let link of allLinks) {
    link.setAttribute("target","_blank");
    link.setAttribute("rel","noopener noreferrer");
}

var allNotes = document.getElementsByClassName("collapse-note");
for (let note of allNotes) {
    drawNote(note);
}
function drawNote(note) {
    const expandText = (typeof note.dataset.label == 'string') ? '['+note.dataset.label+']' : '[More]';
    note.style.display = 'none';
    note.style.backgroundColor = 'rgba(180,180,180,.25)';
    var moreSup = document.createElement("sup");
    var moreButton = document.createElement("button");
    moreButton.setAttribute('class','collapse-button');
    moreSup.appendChild(moreButton);
    moreButton.innerText = expandText;
    moreButton.style.backgroundColor = 'none';
    moreButton.style.border = 'none';
    moreButton.style.padding = '0';
    moreButton.style.fontSize = 'smaller';
    note.parentNode.insertBefore(moreSup,note);
    moreButton.addEventListener("click", (event) => {
        var myButton = event.currentTarget;
        var myNote = myButton.parentNode.nextSibling;
        if (myNote.style.display == 'none') {
        myNote.style.display = 'inline';
        myButton.innerText = '[Less]';
        } else {
        myNote.style.display = 'none';
        myButton.innerText = expandText;
        }
    },false);
    innerSup = moreSup.cloneNode(true);
    note.appendChild(innerSup);
    innerSup.firstChild.innerText = '[Less]';
    innerSup.firstChild.addEventListener("click", (event) => {
        var myNote = event.currentTarget.parentNode.parentNode;
        myNote.style.display = 'none';
        myNote.previousSibling.firstChild.innerText = expandText;
    },false);
}

var allOutputBoxes = document.getElementsByClassName("output-box");
for (let box of allOutputBoxes) {
  drawBox(box);
}

function populateDiv(d, wordArray) {
    if (wordArray.length == 1 && wordArray[0] == "") {
        wordArray = []
    }
    for (let i = 0; i < wordArray.length; i++) {
        if (d.childElementCount <= 2*(i+1)) {
            newText = document.createElement("span");
            newText.dataset.index = i;
            newText.style = "display: inline-block;";
            newText.addEventListener("click", (event) => {
                const myBox = event.target.parentNode.parentNode;
                const rect = event.target.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const midpoint = rect.width / 2;
                if (clickX < midpoint) {
                    myBox.dataset.cursorIndex = parseInt(event.target.dataset.index);
                    drawBox(myBox);
                } else {
                    myBox.dataset.cursorIndex = parseInt(event.target.dataset.index) + 1;
                    drawBox(myBox);
                }
                event.stopPropagation()
            });
            d.appendChild(newText);
            spaceText = document.createElement("span");
            spaceText.dataset.index = i+1;
            spaceText.innerText = " ";
            spaceText.style = "display: inline-block; white-space: pre;"
            spaceText.addEventListener("click", (event) => {
                const myBox = event.target.parentNode.parentNode;
                myBox.dataset.cursorIndex = parseInt(event.target.dataset.index);
                drawBox(myBox);
                event.stopPropagation()
            });
            d.appendChild(spaceText);
        }
        d.children[2*i+1].innerText = wordArray[i]
    }
    while (d.childElementCount > 2*wordArray.length+1) {
        d.removeChild(d.lastChild);
    }
}

function drawBox(f) {
    wordArray = f.dataset.text.split(" ");
    if (!f.hasChildNodes()) {
        var newText = document.createElement("div");
        newText.setAttribute('class','drawn-box');
        newText.style.outline = "2px inset black";
        newText.style.minHeight = "1.2em";
        newText.style.width = "400px";
        newText.style.padding = ".2em .3em";
        spaceText = document.createElement("span");
        spaceText.dataset.index = 0;
        spaceText.innerText = " ";
        if (f.dataset.editing == "true") {
            spaceText.style.whiteSpace = "pre";
        }
        spaceText.addEventListener("click", (event) => {
            const myBox = event.target.parentNode.parentNode;
            myBox.dataset.cursorIndex = parseInt(event.target.dataset.index);
            drawBox(myBox);
            event.stopPropagation()
        });
        newText.appendChild(spaceText);
        f.appendChild(newText);
        f.style.marginTop = '.5em';
        f.style.marginBottom = '.5em';
        let cursor = document.createElement("div");
        cursor.classList.add("input-cursor");
        f.appendChild(cursor);
        if (f.dataset.editing == "true") {
            newText.setAttribute("tabindex","0");
            newText.addEventListener("click", (event) => {
                var myBox = event.currentTarget.parentNode;
                let innerText = myBox.dataset.text.split(" ");
                if (innerText.length == 1 && innerText[0] == "") {
                    innerText = [];
                }
                myBox.dataset.cursorIndex = innerText.length;
                drawBox(myBox);
            });
            newText.addEventListener("keydown", (event) => {
                var myBox = event.target.parentNode;
                if (myBox.dataset.editing != "true") {
                    return;
                }
                var pressed = event.key;
                var currentIndex = parseInt(myBox.dataset.cursorIndex);
                if (pressed == "ArrowLeft") {
                    myBox.dataset.cursorIndex = Math.max(0,currentIndex-1);
                    drawBox(myBox);
                } else if (pressed == "ArrowRight") {
                    let innerText = myBox.dataset.text.split(" ");
                    if (innerText.length == 1 && innerText[0] == "") {
                        innerText = [];
                    }
                    myBox.dataset.cursorIndex = Math.min(innerText.length,currentIndex+1);
                    drawBox(myBox);
                } else if (pressed == "Backspace") {
                    boxBackspace(myBox.id);
                    drawBox(myBox);
                }
            });
            newText.addEventListener('focus', function() {
                event.target.nextSibling.style.animation = "blink 1s step-start infinite";
            });
            newText.addEventListener('blur', function() {
                event.target.nextSibling.style.animation = "";
            });
        }
    }
    populateDiv(f.firstChild,wordArray)
    if (f.dataset.editing == "true") {
        spaceIndex = Math.min(2*parseInt(f.dataset.cursorIndex),f.firstChild.children.length - 1)
        const targetSpace = f.firstChild.children[spaceIndex]
        const spanWidth = targetSpace.getBoundingClientRect().width;
        f.lastChild.style.width = spanWidth/3 + "px"
        f.lastChild.style.top = (targetSpace.offsetTop) + "px";
        f.lastChild.style.left = (targetSpace.offsetLeft + spanWidth/3) + "px";
    } else {
        f.lastChild.style.display = "none";
    }
}

function updateTemplate(selectObject, updateFlag) {
  var outputBox = document.getElementById(selectObject.dataset.for);
  var blanks = outputBox.dataset.blanks.split(',');
  var empties = false;
  for (let i = 0; i < blanks.length; i++) {
    if (document.getElementById(blanks[i]).value == 'empty' && document.getElementById(blanks[i]).nodeName == "SELECT"
        || document.getElementById(blanks[i]).value == '' && document.getElementById(blanks[i]).nodeName == "INPUT") {
      empties = true;
    }
  }
  if (empties) {
    outputBox.dataset.text = '';
    drawBox(outputBox);
  } else {
    outputBox.dataset.text = '';
    var template = document.getElementById(outputBox.dataset.template);
    for (let i = 0; i < template.children.length; i++) {
      if (template.children[i].nodeName == "SELECT") {
        outputBox.dataset.text = outputBox.dataset.text + template.children[i].options[template.children[i].selectedIndex].innerText;
      } else if (template.children[i].nodeName == "INPUT") {
        outputBox.dataset.text = outputBox.dataset.text + template.children[i].value;
      } else {
        outputBox.dataset.text = outputBox.dataset.text + template.children[i].innerText;
      }
    }
    drawBox(outputBox);
    var currentSection = parentSection(outputBox);
    if (currentSection.dataset.state.length < 6 && updateFlag) {
      currentSection.dataset.state = currentSection.dataset.state + ".";
      sectionRedraws.get(currentSection.id)(currentSection.dataset.state);
    }
  }
}

var allRules = document.getElementsByClassName("tree-rules");
for (let ruleSet of allRules) {
    drawTreeRules(ruleSet);
}
function drawTreeRules(ruleSet) {
    if (ruleSet.hasChildNodes()) {
        ruleSet.style.minHeight = ruleSet.offsetHeight + "px";
    }
    while (ruleSet.hasChildNodes()) {
        ruleSet.removeChild(ruleSet.lastChild);
    }
    ruleSet.appendChild(document.createTextNode("Rules:"));
    var ruleText = ruleSet.dataset.rules;
    if (ruleText == "") {
        return;
    }
    var byLeft = ruleText.split(/,/);
    for (let leftSide of byLeft) {
        ruleSet.appendChild(document.createElement("br"));
        var broken = leftSide.split(/[>|]/);
        ruleSet.appendChild(document.createTextNode(broken[0] + " \u2192 "));
        for (let i = 1; i < broken.length; i++) {
        var rightSide = document.createElement("span");
        rightSide.style.whiteSpace = "nowrap";
        rightSide.innerText = broken[i].replace('?','');
        ruleSet.appendChild(rightSide);
        if (broken[i].charAt(0) == '?') {
            let remove = document.createElement("button");
            remove.innerText = "X";
            remove.style.borderRadius = "100%";
            let rule = broken[0] + '>' + broken[i];
            let index = ruleSet.dataset.index;
            remove.addEventListener("click", (event) => {
                mySection = parentSection(event.target);
                let stateArray = mySection.dataset.state.split(';');
                let mainRuleset = stateArray[index];
                let rulesetArray = mainRuleset.split('.');
                for (i in rulesetArray) {
                    if (rulesetArray[i].split('>')[0] == rule.split('>')[0]) {
                        let changing = rulesetArray[i].replace('>','>|')+'|';
                        changing = changing.replace('|'+rule.split('>')[1]+'|','|');
                        changing = changing.replace('>|','>').slice(0,-1);
                        rulesetArray[i] = changing;
                        if (!changing.includes('>')) {
                            rulesetArray.splice(i,1);
                        }
                        break;
                    }
                }
                stateArray[index] = rulesetArray.toString().replace(/,/g,".");
                mySection.dataset.state = (stateArray.toString()).replace(/,/g,";");
                sectionRedraws.get(mySection.id)(mySection.dataset.state);
            });
            rightSide.innerText = rightSide.innerText + " ";
            rightSide.appendChild(remove);
        }
        if (i < broken.length - 1) {
            rightSide.appendChild(document.createTextNode(" |"));
            ruleSet.appendChild(document.createTextNode(" "));
        }
        }
    }
    ruleSet.style.minHeight = 0;
}

function addRuleToState(mySection, index, newRule) {
    if (newRule.split('\u2192').length != 2) {
        return;
    }
    let state = mySection.dataset.state;
    let stateArray = state.split(';');
    stateArray[index] = addRule(stateArray[index].replaceAll('.',','),newRule.replace(' \u2192 ','>')).replaceAll(',','.');
    mySection.dataset.state = (stateArray.toString()).replace(/,/g,";");
    sectionRedraws.get(mySection.id)(mySection.dataset.state);
}

function addRule(ruleSet, newRule) {
    let rulesetArray = ruleSet.split(',');
    if (rulesetArray[0] == "") {
        rulesetArray = [];
    }
    let added = false;
    for (i in rulesetArray) {
        if (rulesetArray[i].split('>')[0] == newRule.split('>')[0]) {
            let changing = rulesetArray[i].replace('>','>|')+'|';
            // check for duplicate
            if (changing.includes('|'+newRule.split('>')[1]+'|') || changing.includes('|?'+newRule.split('>')[1]+'|')) {
                added = true;
                break;
            }
            changing = changing + '?' + newRule.split('>')[1];
            changing = changing.replace('>|','>');
            rulesetArray[i] = changing;
            added = true;
            break;
        }
    }
    if (!added) {
        rulesetArray.push(newRule.replace('>','>?'));
    }
    return rulesetArray.toString();
}


var allTemplateFrames = document.getElementsByClassName("template-frame");
for (let template of allTemplateFrames) {
  drawMyTemplate(template);
}
function drawMyTemplate(frame) {
  frame.style.borderSpacing = "5px 0";
  var treeArray = frame.dataset.tree;
  var selected = frame.dataset.selected;
  //selected = selected.slice(1);
  var nonterminals = frame.dataset.nonterminals.split(',');
  frame.buttonArray = new Array();
  frame.style.textAlign = "center";
  const labels = treeArray.split(" ");
  var x = 1;
  var y = 0;
  var lastClose = false;
  var rows = new Array();
  var needsTop = false;
  for (let i = 0; i < 2; i++) {
    const row = document.createElement('tr');
    const newCell = document.createElement('td');
    newCell.setAttribute('colspan',1);
    var blankElement = document.createElement('div');
    blankElement.innerText = "\u00A0";
    newCell.appendChild(blankElement);
    //newCell.innerText = '&nbsp;';
    row.appendChild(newCell);
    rows.push(row);
  }
  var ancestors = new Array();
  var currentPath = "0";
  if (frame.dataset.tree.slice(0,3) == "[S " || frame.dataset.tree.slice(0,3) == "[S]") {
    currentPath = "";
  }
  
  for (let i = 0; i < labels.length; i++) {
    if (y > rows.length-1) {
      needsTop = false;
      rows.push(document.createElement('tr'));
      for (let j = 0; j < x; j++) {
        const newCell = document.createElement('td');
        newCell.setAttribute('colspan',1);
        rows[y].appendChild(newCell);
      }
    }

    if (lastClose) {
      x++;
      for (let j = y; j < rows.length; j++) {
        const newCell = document.createElement('td');
        newCell.setAttribute('colspan',1);
        rows[j].appendChild(newCell);
      }
      for (let j = 0; j < ancestors.length; j++) {
        ancestors[j].setAttribute('colspan',1+parseInt(ancestors[j].getAttribute('colspan'),10));
        //alert(ancestors[j].firstChild.innerText + " " + ancestors[j].getAttribute('colspan'));
      }
      const newIndex = parseInt(currentPath.charAt(currentPath.length-1),32)+1;
      currentPath = currentPath.slice(0,currentPath.length-1) + newIndex.toString(32);
    }
    
    const currentLabel = labels[i].replace(/[\[\]]/g,"");

    if (!nonterminals.includes(currentLabel) && y==0) {
      y++;
      labels[i] = labels[i] + "]";
      currentPath = currentPath + 'X';
    }

    var currentCell = rows[y].lastChild;
    const pos = document.createElement('div');
    if (currentCell.hasChildNodes()) {
        currentCell.removeChild(currentCell.lastChild);
    }
    currentCell.appendChild(pos);
    pos.innerText = currentLabel;
    if (currentLabel == 'S') {
        pos.innerText = '\u00A0\u00A0S\u00A0\u00A0';
    }

    if (nonterminals.includes(currentLabel)) {
      if (y == rows.length - 1) {
        needsTop = true;
      }
      currentCell.style.borderTop = '1px solid currentColor';
      pos.style.position = 'relative';

      if (parseInt(frame.dataset.index,10) >= 0) {
        const button = document.createElement('button');
        pos.appendChild(button);
        button.buttonPath = '0' + currentPath;
        button.buttonLabel = currentLabel;
        button.className = 'table-button';
        if (button.buttonPath == selected) {
          button.className = 'table-button selected';
        }

        frame.buttonArray.push(button);

        button.addEventListener("click", (event) => {
          const stateArray = parentSection(frame).dataset.state.split(';'); 
          const templateNum = parseInt(frame.dataset.index,10);
          if (stateArray[templateNum+1] != event.target.buttonPath) {
            stateArray[templateNum+1] = event.target.buttonPath;
            stateArray[templateNum+2] = event.target.buttonLabel;
          } else {
            stateArray[templateNum+1] = 'X';
            stateArray[templateNum+2] = '';
          }
          for (let button of frame.buttonArray) {
            button.className = 'table-button';
            if (button.buttonPath == stateArray[templateNum+1]) {
              button.className = 'table-button selected';
            }
          }
          parentSection(frame).dataset.state = (stateArray.toString()).replace(/,/g,";");
          if (sectionRedraws.has(parentSection(frame).id)) {
            // No redraw here! Just this line to refresh the banner with the state
            document.getElementById('banner-out').innerText = getSectionStates();
            //sectionRedraws.get(parentSection(frame).id)(parentSection(frame).dataset.state);
          }
        });
      }
    }
    
    lastClose = false;
    ancestors.push(currentCell);
    y++;
    currentPath = currentPath + '0';
    while (labels[i].charAt(labels[i].length-1) == "]") {
      currentPath = currentPath.slice(0,currentPath.length-1);
      lastClose = true;
      labels[i] = labels[i].slice(0,labels[i].length-1);
      y--;
      ancestors.pop();
    }
  }

  while (frame.hasChildNodes()) {
    frame.removeChild(frame.lastChild);
  }
  if (needsTop) {
    const topRow = document.createElement('tr');
    topRow.ariaHidden = "true";
    const topCell = document.createElement('td');
    topCell.appendChild(document.createElement('br'));
    topRow.appendChild(topCell);
    frame.appendChild(topRow);
  }
  for (let i = rows.length-1; i >= 0; i--) {
    frame.appendChild(rows[i]);
  }

  for (let button of frame.buttonArray) {
    const inner = parseInt(button.parentNode.parentNode.getBoundingClientRect().height,10);
    const borderText = button.parentNode.parentNode.parentNode.parentNode.style.borderSpacing;
    const border = parseInt(borderText.slice(borderText.indexOf(" ")+1).replace(/px/,""),10);
    button.style.bottom = (inner+border) + 'px';
  }
}

var allLabels = document.getElementsByClassName("tree-labels");
function drawTreeLabel(label) {
    var nonterminalsDiv = document.createElement("div");
    label.appendChild(nonterminalsDiv);
    nonterminalsDiv.appendChild(document.createTextNode("Nonterminal labels: "));
    var nonterminals = label.dataset.nonterminals.split(",");
    var nonterminalButtons = new Array(nonterminals.length);
    for (let i = 0; i < nonterminals.length; i++) {
        var nonterminal = nonterminals[i]
        const button = document.createElement('button');
        button.setAttribute("type","button");
        button.innerText = nonterminal;
        button.index = label.dataset.index;
        button.addEventListener("click", updateLabel);
        nonterminalButtons[i] = button;
    }
    createToolbar(nonterminalsDiv, nonterminalButtons);
    nonterminalsDiv.setAttribute("aria-label", "Nonterminal labels");

    var terminalsDiv = document.createElement("div");
    label.appendChild(terminalsDiv);
    terminalsDiv.appendChild(document.createTextNode("Terminal labels: "));
    var terminals = label.dataset.terminals.split(",");
    var terminalButtons = new Array(terminals.length);
    for (let i = 0; i < terminals.length; i++) {
        var terminal = terminals[i];
        const button = document.createElement('button');
        button.setAttribute("type","button");
        button.innerText = terminal;
        button.index = label.dataset.index;
        button.addEventListener("click", updateLabel);
        terminalButtons[i] = button;
    }
    createToolbar(terminalsDiv, terminalButtons);
    terminalsDiv.setAttribute("aria-label", "Terminal labels");
}
for (let label of allLabels) {
    drawTreeLabel(label);
}

var allRuleButtons = document.getElementsByClassName("rule-buttons");
for (let ruleSet of allRuleButtons) {
  ruleSet.appendChild(document.createTextNode("Rules:"));
  var ruleText = ruleSet.dataset.rules;
  var byLeft = ruleText.split(/,/);
  for (let leftSide of byLeft) {
    var ruleLine = document.createElement("div");
    ruleSet.appendChild(ruleLine);
    var broken = leftSide.split(/[>|]/);
    ruleLine.appendChild(document.createTextNode(broken[0] + " \u2192 "));
    var buttonArray = new Array(0);
    for (let i = 1; i < broken.length; i++) {
      var rightSide = document.createElement("button");
      rightSide.innerText = broken[i];
      rightSide.nonterminal = broken[0];
      rightSide.rewritten = broken[i];
      rightSide.addEventListener("click", (event) => {
        const stateArray = parentSection(event.target).dataset.state.split(';');
        const templateNum = parseInt(event.target.parentNode.parentNode.dataset.index,10);
        if (event.target.nonterminal == stateArray[templateNum+2]) {
          var treeString = stateArray[templateNum];
          var offset = 0;
          if (treeString.slice(0,3) != "[S " && treeString.slice(0,3) != "[S]") {
            treeString = "[S " + treeString + "]";
            offset = 3;
          }
          var nodePos = findNode(treeString, stateArray[templateNum+1]);
          stateArray[templateNum] = stateArray[templateNum].slice(0,nodePos[1]-offset) + " [" + event.target.rewritten.replace(/ /g,"] [") + "]" + stateArray[templateNum].slice(nodePos[2]-offset);
          parentSection(event.target).dataset.state = (stateArray.toString()).replace(/,/g,";");
          if (sectionRedraws.has(parentSection(event.target).id)) {
            sectionRedraws.get(parentSection(event.target).id)(parentSection(event.target).dataset.state);
          }
        } else {
          //Send an error message?
        }
      });
      buttonArray.push(rightSide);
    }
    createToolbar(ruleLine,buttonArray);
    var barNodes = ruleLine.childNodes;
    for (let i = 0; i < barNodes.length; i++) {
      if (barNodes[i].nodeValue == " ") {
        barNodes[i].nodeValue = " | ";
      }
    }
  }
}





function createToolbar(bar, buttonArray) {
  bar.setAttribute("role","toolbar");
  bar.currentFocus = 0;
  bar.addEventListener("keydown", (event) => {
    var pressed = event.key;
    if (pressed == "ArrowLeft") {
      if (bar.currentFocus > 0) {
        buttonArray[bar.currentFocus].setAttribute("tabindex","-1");
        bar.currentFocus--;
        buttonArray[bar.currentFocus].setAttribute("tabindex","0");
        buttonArray[bar.currentFocus].focus();
      }
      event.preventDefault();
    } else if (pressed == "ArrowRight") {
      if (bar.currentFocus < buttonArray.length-1) {
        buttonArray[bar.currentFocus].setAttribute("tabindex","-1");
        bar.currentFocus++;
        buttonArray[bar.currentFocus].setAttribute("tabindex","0");
        buttonArray[bar.currentFocus].focus();
      }
      event.preventDefault();
    }
  },false);
  for (let i = 0; i < buttonArray.length; i++) {
    buttonArray[i].setAttribute("tabindex","-1");
    if (i == bar.currentFocus) {
      buttonArray[i].setAttribute("tabindex","0");
      buttonArray[i].focus();
    }
    buttonArray[i].addEventListener("click", (event) => {
      buttonArray[bar.currentFocus].setAttribute("tabindex","-1");
      bar.currentFocus = i;
      buttonArray[bar.currentFocus].setAttribute("tabindex","0");
      buttonArray[bar.currentFocus].focus();
    });
    buttonArray[i].addEventListener("mouseover", (event) => {
      buttonArray[bar.currentFocus].setAttribute("tabindex","-1");
      bar.currentFocus = i;
      buttonArray[bar.currentFocus].setAttribute("tabindex","0");
      buttonArray[bar.currentFocus].focus();
    });
    bar.appendChild(buttonArray[i]);
    bar.appendChild(document.createTextNode(" "));
  }
  bar.lastChild.remove();
}

// Returns array with given positions: ["["," ","]"]
function findNode(treeString, path) {
    treeString = '[\u03A6 ' + treeString + ']';
  var pos = [0,-1,-1];
  var counter = 0;
  // Find the position of the opening bracket
  while (path.length > 0) {
    pos[0]++;
    while (treeString.charAt(pos[0]) != "[") {
      pos[0]++;
    }
    var sibling = parseInt(path.charAt(0),32);
    var currentSib = 0;
    while (currentSib < sibling) {
      // Read in a full sib
      counter = 1;
      pos[0]++;
      while (counter > 0) {
        pos[0]++;
        if (treeString.charAt(pos[0])=="[") {
          counter++;
        } else if (treeString.charAt(pos[0])=="]") {
          counter--;
        }
      }
      while (treeString.charAt(pos[0]) != "[") {
        pos[0]++;
      }
      currentSib++;
    }
    path = path.slice(1);
  }
  
  // Find the position of the space
  pos[1] = pos[0]+1;
  while (treeString.charAt(pos[1]) != " " && pos[1] < treeString.length) {
    pos[1]++;
  }

  // Find the position of the closing bracket
  counter = 1;
  pos[2] = pos[0]+1;
  while (counter > 0) {
    pos[2]++;
    if (treeString.charAt(pos[2])=="[") {
      counter++;
    } else if (treeString.charAt(pos[2])=="]") {
      counter--;
    }
  }

  pos[1] = Math.min(pos[1],pos[2]);
  pos[0] = pos[0]-3;
  pos[1] = pos[1]-3;
  pos[2] = pos[2]-3;
  return pos;
  
}

// Returns [Any nonterminals in string?, String of leaf nodes in order]
function readString(treeString, terminals) {
  var anyNonterminals = false;
  var outputArray = treeString.match(/(?<=\[)[^\[\]]*(?=\])/g);
  var output = ""
  for (let node of outputArray) {
    node = node.replace(/!/g,"");
    if (!terminals.includes(node)) {
      anyNonterminals = true;
    }
    output = output + " " + node;
  }
  output = output.replace(/ \u03B5/g,"");
  //alert(output);
  return [anyNonterminals,output.trim()];
}


var allInputBoxes = document.getElementsByClassName("input-box");
for (let box of allInputBoxes) {
  drawBox(box);
}

var allBoxLabels = document.getElementsByClassName("box-labels");
// redoing a drawBoxLabels only works if the number of characters doesn't change
function drawBoxLabels(label) {
    if (label.dataset.characters.length == "") {
        return;
    }
    if (label.childNodes.length > 0) {
        var characters = label.dataset.characters.split(",");
        const children = Array.from(label.childNodes);
        for (let i = 0; i < characters.length; i++) {
            children[2*i].innerText = characters[i]
        }
        return;
    }
    var characters = label.dataset.characters.split(",");
    var buttonArray = new Array(characters.length+1);
    for (let i = 0; i < characters.length; i++) {
        var character = characters[i];
        const button = document.createElement('button');
        button.setAttribute("type","button");
        button.innerText = character;
        button.for = label.dataset.for;
        button.addEventListener("click", addCharacter);
        buttonArray[i] = button;
    }
    const backButton = document.createElement('button');
    backButton.innerText = "\u2190 Backspace";
    backButton.for = label.dataset.for;
    backButton.addEventListener("click", (event) => {boxBackspace(event.currentTarget.for);});
    buttonArray[buttonArray.length-1] = backButton;
    createToolbar(label, buttonArray);
    label.setAttribute("aria-label", "Input box keyboard");
}
for (let label of allBoxLabels) {
    drawBoxLabels(label);
}

function addCharacter(evt) {
  box = document.getElementById(evt.currentTarget.for);
  cursorIndex = parseInt(box.dataset.cursorIndex);
  label = evt.currentTarget.innerText;
  if (box.dataset.text.length == 0) {
    box.dataset.text = label;
  } else {
    wordlist = box.dataset.text.split(" ");
    wordlist.splice(cursorIndex, 0, label);
    box.dataset.text = wordlist.join(" ");
  }
  box.dataset.cursorIndex = cursorIndex + 1;
  drawBox(box);
}

function boxBackspace(boxName) {
  box = document.getElementById(boxName);
  //box = document.getElementById(evt.currentTarget.for);
  cursorIndex = parseInt(box.dataset.cursorIndex);
  if (cursorIndex == 0) {
    return;
  }
  wordlist = box.dataset.text.split(" ");
  wordlist.splice(cursorIndex-1,1);
  box.dataset.text = wordlist.join(" ");
  box.dataset.cursorIndex = cursorIndex - 1;
  drawBox(box);
}

var allManipulations = document.getElementsByClassName("tree-manipulations");
function drawManipulation(manip) {
    var buttonArray = new Array(4);

    const delButton = document.createElement('button');
    delButton.setAttribute("type","button");
    delButton.innerText = "Delete";
    delButton.index = manip.dataset.index;
    delButton.addEventListener("click", deleteNode);
    buttonArray[0] = delButton;

    const addButton = document.createElement('button');
    addButton.setAttribute("type","button");
    addButton.innerText = "Add child";
    addButton.index = manip.dataset.index;
    addButton.addEventListener("click", addChild);
    buttonArray[1] = addButton;

    const leftButton = document.createElement('button');
    leftButton.setAttribute("type","button");
    leftButton.innerText = "Swap left";
    leftButton.index = manip.dataset.index;
    leftButton.addEventListener("click", swapLeft);
    buttonArray[2] = leftButton;

    const rightButton = document.createElement('button');
    rightButton.setAttribute("type","button");
    rightButton.innerText = "Swap right";
    rightButton.index = manip.dataset.index;
    rightButton.addEventListener("click", swapRight);
    buttonArray[3] = rightButton;

    createToolbar(manip,buttonArray);
    manip.setAttribute("aria-label", "Tree controls");
}
for (let manip of allManipulations) {
    drawManipulation(manip);
}

function updateLabel(evt) {
    var stateArray = parentSection(evt.currentTarget).dataset.state.split(';');
    const myIndex = parseInt(evt.currentTarget.index,10);
    const label = evt.currentTarget.innerText;
    if (stateArray[myIndex+1] != "XX") {
        var nodePos = findNode(stateArray[myIndex],stateArray[myIndex+1]);
        stateArray[myIndex] = (stateArray[myIndex].slice(0,nodePos[0]+1)) + (label) + (stateArray[myIndex].slice(nodePos[1]));
        parentSection(evt.currentTarget).dataset.state = stateArray.toString().replace(/,/g,";");
        sectionRedraws.get(parentSection(evt.currentTarget).id)(parentSection(evt.currentTarget).dataset.state);
    }
}

function treeWithIndex(collection, index) {
    for (let tree of collection) {
        if (tree.dataset.index == index) {
            return tree;
        }
    }
    return null;
}

function deleteNode(evt) {
    var stateArray = parentSection(evt.currentTarget).dataset.state.split(';');
    const myIndex = parseInt(evt.currentTarget.index,10);
    if (stateArray[myIndex+1] != "XX" && stateArray[myIndex+1].length > 1) {
        var nodePos = findNode(stateArray[myIndex],stateArray[myIndex+1]);
        stateArray[myIndex] = (stateArray[myIndex].slice(0,nodePos[0]-1)) + (stateArray[myIndex].slice(nodePos[2]+1));
        stateArray[myIndex+1] = "XX";
        treeWithIndex(parentSection(evt.currentTarget).getElementsByClassName('tree-frame'),evt.currentTarget.index).dataset.focus = "0";
        parentSection(evt.currentTarget).dataset.state = stateArray.toString().replace(/,/g,";");
        sectionRedraws.get(parentSection(evt.currentTarget).id)(parentSection(evt.currentTarget).dataset.state);
    }
}

function addChild(evt) {
    var stateArray = parentSection(evt.currentTarget).dataset.state.split(';');
    const myIndex = parseInt(evt.currentTarget.index,10);
    if (stateArray[myIndex+1] != "XX") {
        var nodePos = findNode(stateArray[myIndex],stateArray[myIndex+1]);
        stateArray[myIndex] = (stateArray[myIndex].slice(0,nodePos[2])) + " [\u2026]" +  (stateArray[myIndex].slice(nodePos[2]));
        parentSection(evt.currentTarget).dataset.state = stateArray.toString().replace(/,/g,";");
        sectionRedraws.get(parentSection(evt.currentTarget).id)(parentSection(evt.currentTarget).dataset.state);
    }
}

function swapLeft(evt) {
    var stateArray = parentSection(evt.currentTarget).dataset.state.split(';');
    const myIndex = parseInt(evt.currentTarget.index,10);
    var tree = treeWithIndex(Array.from(parentSection(evt.currentTarget).getElementsByClassName('tree-frame')),evt.currentTarget.index)
    if (stateArray[myIndex+1] != "XX" && tree.dataset.selectedContext.charAt(0) != "0") {
        var nodePos = findNode(stateArray[myIndex],stateArray[myIndex+1]);
        var swapper = stateArray[myIndex+1];
        swapper = swapper.slice(0,swapper.length - 1) + (parseInt(swapper.charAt(swapper.length-1), 10)-1);
        var leftPos = findNode(stateArray[myIndex], swapper);
        stateArray[myIndex] = (stateArray[myIndex].slice(0,leftPos[0])) + (stateArray[myIndex].slice(nodePos[0],nodePos[2])) + (stateArray[myIndex].slice(leftPos[2],nodePos[0])) + (stateArray[myIndex].slice(leftPos[0],leftPos[2])) + 
(stateArray[myIndex].slice(nodePos[2]));
        if (tree.dataset.focus.startsWith(stateArray[myIndex+1])) {
            tree.dataset.focus = swapper + tree.dataset.focus.slice(swapper.length);
        } else if (tree.dataset.focus.startsWith(swapper)) {
            tree.dataset.focus = stateArray[myIndex+1] + tree.dataset.focus.slice(swapper.length);
        }
        stateArray[myIndex+1] = swapper;
        parentSection(evt.currentTarget).dataset.state = stateArray.toString().replace(/,/g,";");
        sectionRedraws.get(parentSection(evt.currentTarget).id)(parentSection(evt.currentTarget).dataset.state);
    }
}

function swapRight(evt) {
    var stateArray = parentSection(evt.currentTarget).dataset.state.split(';');
    const myIndex = parseInt(evt.currentTarget.index,10);
    var tree = treeWithIndex(Array.from(parentSection(evt.currentTarget).getElementsByClassName('tree-frame')),evt.currentTarget.index)
    if (stateArray[myIndex+1] != "XX" && tree.dataset.selectedContext.charAt(1) != "0") {
        var nodePos = findNode(stateArray[myIndex],stateArray[myIndex+1]);
        var swapper = stateArray[myIndex+1];
        swapper = swapper.slice(0,swapper.length - 1) + (parseInt(swapper.charAt(swapper.length-1), 10)+1);
        var ritePos = findNode(stateArray[myIndex], swapper);
        stateArray[myIndex] = (stateArray[myIndex].slice(0,nodePos[0])) + (stateArray[myIndex].slice(ritePos[0],ritePos[2])) + (stateArray[myIndex].slice(nodePos[2],ritePos[0])) + (stateArray[myIndex].slice(nodePos[0],nodePos[2])) + 
(stateArray[myIndex].slice(ritePos[2]));
        if (tree.dataset.focus.startsWith(stateArray[myIndex+1])) {
            tree.dataset.focus = swapper + tree.dataset.focus.slice(swapper.length);
        } else if (tree.dataset.focus.startsWith(swapper)) {
            tree.dataset.focus = stateArray[myIndex+1] + tree.dataset.focus.slice(swapper.length);
        }
        stateArray[myIndex+1] = swapper;
        parentSection(evt.currentTarget).dataset.state = stateArray.toString().replace(/,/g,";");
        sectionRedraws.get(parentSection(evt.currentTarget).id)(parentSection(evt.currentTarget).dataset.state);
    }
}

function initializeTree(frame) {
    frame.setAttribute("aria-activedescendant",frame.getAttribute("id") + " ");
    frame.setAttribute("role","application");
    frame.setAttribute("tabindex","0");
    frame.setAttribute("data-focus","0");
    frame.setAttribute("data-selected","XX");
    frame.setAttribute("data-focus-context","");
    frame.setAttribute("data-selected-context","XX");
    if (frame.getAttribute("data-start-selected") != null) {
        frame.setAttribute("data-selected",frame.getAttribute("data-start-selected"));
        frame.setAttribute("data-selected-context","");
    }
    drawTrees(frame);
    addMyListener(frame);
}
var allTreeFrames = document.getElementsByClassName("tree-frame");
for (let i = 0; i < allTreeFrames.length; i++) {
    initializeTree(allTreeFrames[i]);
};

function addMyListener(frame) {
  frame.addEventListener("keydown", (event) => {
    var pressed = event.key;
    if (pressed == "ArrowLeft") {
      if (frame.dataset.focusContext.charAt(0)>0) {
        frame.dataset.focus=frame.dataset.focus.slice(0,frame.dataset.focus.length-1) + (parseInt(frame.dataset.focus.charAt(frame.dataset.focus.length-1), 10) - 1);
        //frame.dataset.focusContext = '';
        drawTrees(frame);
      }
      event.preventDefault();
    } else if (pressed == "ArrowRight") {
      if (frame.dataset.focusContext.charAt(1)>0) {
        frame.dataset.focus=frame.dataset.focus.slice(0,frame.dataset.focus.length-1) + (parseInt(frame.dataset.focus.charAt(frame.dataset.focus.length-1), 10) + 1);
        //frame.dataset.focusContext = '';
        drawTrees(frame);
      }
      event.preventDefault();
    } else if (pressed == "ArrowUp") {
        if (frame.dataset.focus != '0') {
            frame.dataset.focus=frame.dataset.focus.slice(0,frame.dataset.focus.length-1);
        }
      //frame.dataset.focusContext = '';
      drawTrees(frame);
      event.preventDefault();
    } else if (pressed == "ArrowDown") {
      if (frame.dataset.focusContext.charAt(2)>0) {
        frame.dataset.focus=frame.dataset.focus + "0";
        //frame.dataset.focusContext = '';
        drawTrees(frame);
      }
      event.preventDefault();
    } else if ((pressed == "Enter" || pressed == " ") && frame.dataset.selectLock != 'true') {
      var stateArray = parentSection(frame).dataset.state.split(';');
      const myIndex = parseInt(frame.dataset.index,10)+1;
      if (document.getElementById(frame.id + " " + frame.dataset.focus).dataset.editable == "true") {
        if (stateArray[myIndex] != frame.dataset.focus) {
            stateArray[myIndex] = frame.dataset.focus;
            parentSection(frame).dataset.state = stateArray.toString().replace(/,/g,";");
        } else {
            stateArray[myIndex] = "XX";
            parentSection(frame).dataset.state = stateArray.toString().replace(/,/g,";");
        }
        sectionRedraws.get(parentSection(frame).id)(parentSection(frame).dataset.state);
      }
      /*
      if (document.getElementById(frame.id + " " + frame.dataset.focus).dataset.editable == "true") {
        if (frame.dataset.selected != frame.dataset.focus) {
          frame.dataset.selected = frame.dataset.focus;
          //frame.dataset.selectedContext = '';
        } else {
          frame.dataset.selected = "XX";
        }
        drawTrees(frame);
      }
      */
      event.preventDefault();
    }
  },false);
}


function drawTrees(f) {
  f.style.cursor = "default";
  while (f.hasChildNodes()) {
    f.removeChild(f.lastChild);
  }
  
  var treeString = f.dataset.tree;
  treeString = '[\u03A6 ' + treeString + ']';
  var treeArray = parseTree(treeString)[1];
  var bottomUp = false;
  if (f.dataset.bottomUp == 'true') {
    bottomUp = true;
  }
  //var innerSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");

  f.dataset.selectedContext = '';
  f.dataset.focusContext = '';
  var wholeTree = drawMyTree(treeArray,f.dataset.focus,f.dataset.selected,f,f.id + ' ',bottomUp,false);
  if (f.dataset.resize) {
    let minHeight = 100;
    if (typeof(f.dataset.minHeight) == "string") {
        minHeight = parseInt(f.dataset.minHeight);
    }
    const newHeight = Math.max(minHeight,wholeTree.getBBox().height+20);
    const newWidth = Math.max(300,wholeTree.getBBox().width+40);
    f.setAttribute("height",newHeight);
    f.setAttribute("width",newWidth);
    f.setAttribute("viewBox","0 0 " + newWidth + " " + newHeight);
    wholeTree.setAttribute("transform","translate(" + ((newWidth-wholeTree.getBBox().width)/2-wholeTree.getBBox().x) + ",30)");
  } else {
    wholeTree.setAttribute("transform","translate(" + f.getAttribute("width")/2 + ",30)");
  }


  var outline = document.createElementNS("http://www.w3.org/2000/svg","rect");
  outline.setAttribute("x","0");
  outline.setAttribute("y","0");
  outline.setAttribute("width","100%");
  outline.setAttribute("height","100%");
  outline.setAttribute("fill","none");
  outline.style.stroke = "currentColor";
  f.appendChild(outline);
}


function parseTree(treeString) {
  if (treeString.slice(1).indexOf("[") < 0 || 
      treeString.indexOf("]") < treeString.slice(1).indexOf("[")) {
    return [treeString.indexOf("]")+1,[treeString.slice(1,treeString.indexOf("]"))]];
  }
  var firstSpace = treeString.indexOf(" ");
  var treeArray = new Array();
  treeArray.push(treeString.slice(1,firstSpace));
  var subTree = treeString.slice(firstSpace+1,treeString.length);
  var length = firstSpace+1;
  while (subTree.charAt(0) != "]") {
    if (subTree.charAt(subTree.length - 2) == '0') {
        alert(subTree);
    }
    var daughter = parseTree(subTree);
    treeArray.push(daughter[1]);
    subTree = subTree.slice(daughter[0]);
    length += daughter[0];
    if (subTree.charAt(0) == " ") {
      subTree = subTree.slice(1);
      length ++;
    }
  }
  return [length+1,treeArray];
}

function drawMyTree(treeArray, focus, selected, frame, path, bottomUp, isRoot) {
  var hGap = 15;
  var vGap = 40;
  var descenderSize = 4;
  var selectable = true;
  if (frame.dataset.selectLock == 'true') {
    selectable = false;
  }

  var group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  frame.appendChild(group);
  
  let childRoots = false;

  if (treeArray[0] != '\u03A6') {
    var parentNode = document.createElementNS("http://www.w3.org/2000/svg", "text");
    parentNode.dataset.editable = true;
    parentNode.setAttribute("x","0");
    parentNode.setAttribute("y","0");
    parentNode.textContent = treeArray[0];
    if (parentNode.textContent.charAt(0) == "!") {
        parentNode.textContent = parentNode.textContent.slice(1);
        parentNode.dataset.editable = false;
        parentNode.setAttribute("class","grayed-out");
        //parentNode.setAttribute("fill","gray");
        parentNode.setAttribute("aria-disabled","true");
        selectable = false;
        //parentNode.style.cursor = "pointer";
    }
    frame.appendChild(parentNode);
    var textWidth = parentNode.getBBox().width;
    parentNode.setAttribute("dx",-textWidth/2);
    parentNode.id = path;
    group.appendChild(parentNode);

    parentNode.addEventListener('mouseover', function(e) {
        var myPath = path.slice(path.indexOf(" ")+1);
        if (frame.dataset.focus != myPath) {
        frame.dataset.focus = myPath;
        drawTrees(frame);
        }
    });

    parentNode.addEventListener('click', function(e) {
        var myPath = parentNode.id.slice(parentNode.id.indexOf(" ")+1);
        if (frame.dataset.selectLock == 'true') {
        return;
        }


        var stateArray = parentSection(frame).dataset.state.split(';');
        const myIndex = parseInt(frame.dataset.index,10)+1;
        if (stateArray[myIndex] != myPath && parentNode.dataset.editable == "true") {
            stateArray[myIndex] = myPath;
            parentSection(frame).dataset.state = stateArray.toString().replace(/,/g,";");
            sectionRedraws.get(parentSection(frame).id)(parentSection(frame).dataset.state);
        } else if (stateArray[myIndex] == myPath) {
            stateArray[myIndex] = "XX";
            parentSection(frame).dataset.state = stateArray.toString().replace(/,/g,";");
            sectionRedraws.get(parentSection(frame).id)(parentSection(frame).dataset.state);
        }
        /*
        if (frame.dataset.selected != myPath && parentNode.dataset.editable == "true") {
        frame.dataset.selected = myPath;
        drawTrees(frame);
        } else if (frame.dataset.selected == myPath) {
        frame.dataset.selected = "XX";
        drawTrees(frame);
        }
        */
    });
  } else {
    childRoots = true;
  }
  

  if (focus.length == 1) {
    frame.dataset.focusContext = focus + (treeArray.length-2 - parseInt(focus.charAt(0), 10)).toString();
  }
  if (selected.length == 1) {
    frame.dataset.selectedContext = selected + (treeArray.length-2 - parseInt(selected.charAt(0), 10)).toString();
  }

  var childNodes = new Array(treeArray.length-1);
  for (let i = 0; i < childNodes.length; i++) {
    var newFocus = "XX";
    var newSelected = "XX"
    if (i == parseInt(focus.charAt(0), 10)) {
      newFocus = focus.slice(1);
    }
    if (i == parseInt(selected.charAt(0), 10)) {
      newSelected = selected.slice(1);
    }
    childNodes[i] = drawMyTree(treeArray[i+1],newFocus,newSelected,frame, path + i, bottomUp, childRoots);
  }
  var gaps = new Array(childNodes.length);
  var totalGap = 0;
  for (let i = 0; i < gaps.length-1; i++) {
    gaps[i] = childNodes[i].getBBox().x+childNodes[i].getBBox().width-childNodes[i+1].getBBox().x;
    totalGap += gaps[i];
  }
  totalGap += (gaps.length-1)*hGap
  var currentX = -totalGap/2;
  var maxHeight = -1;
  let childHeights = new Array(childNodes.length);
  for (let i = 0; i < childNodes.length; i++) {
    childHeights[i] = childNodes[i].getBBox().height;
    if (maxHeight < childHeights[i]) {
        maxHeight = childHeights[i];
    }
  }
  for (let i = 0; i < childNodes.length; i++) {
    let extraLength = 0;
    if (bottomUp) {
        extraLength = maxHeight-childHeights[i];
    }
    if (treeArray[0] == '\u03A6') {
        extraLength -= vGap;
    }
    childNodes[i].setAttribute("transform","translate("+currentX+","+(vGap+extraLength)+")");
    if (treeArray[0] != '\u03A6') {
        var edge = document.createElementNS("http://www.w3.org/2000/svg", "line");
        edge.setAttribute("x1",0);
        edge.setAttribute("y1",descenderSize);
        edge.setAttribute("x2",currentX);
        edge.setAttribute("y2",vGap-parentNode.getBBox().height+descenderSize+extraLength);
        edge.style.stroke = "currentColor";
        edge.style.strokeWidth = 1;
        group.appendChild(edge);
    }
    
    currentX += gaps[i]+hGap;
  }

  if (focus == "" && treeArray[0] != '\u03A6') {
    var outline = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    outline.setAttribute("x",parentNode.getBBox().x);
    outline.setAttribute("y",parentNode.getBBox().y);
    outline.setAttribute("height",parentNode.getBBox().height);
    outline.setAttribute("width",parentNode.getBBox().width);
    outline.style.fill = "none";
    outline.style.stroke = "gray";
    outline.style.strokeWidth = 1;
    outline.style.strokeDasharray = "2,2";
    if (selectable) {
      outline.style.fill = "currentColor";
      outline.style.fillOpacity = "0.2";
      outline.style.stroke = "currentColor";
    }
    //group.appendChild(outline);
    group.insertBefore(outline,parentNode);
    if (frame.dataset.focusContext == "") {
      frame.dataset.focusContext = "00"
    }
    frame.dataset.focusContext = frame.dataset.focusContext + (childNodes.length).toString();
    frame.setAttribute("aria-activedescendant",parentNode.id);
    parentNode.focus();
    parentNode.setAttribute("aria-roledescription","Node");
    parentNode.setAttribute("aria-label",parentNode.textContent);
    if (selected=="") {
      parentNode.setAttribute("aria-label", "Selected " + parentNode.textContent);
    }
    if (parentNode.dataset.editable == "false") {
      parentNode.setAttribute("aria-label", "Locked " + parentNode.textContent);
    }
    parentNode.focus();

    

    var contextDescription = "Has ";
    var describeSib = "sibling";
    if (isRoot) {
        contextDescription = "Is root and has ";
        describeSib = "root"
    }
    contextDescription = contextDescription + frame.dataset.focusContext.charAt(0);
    if (contextDescription.charAt(contextDescription.length-1) == 1) {
      contextDescription = contextDescription + " left " + describeSib + " ";
    } else {
      contextDescription = contextDescription + " left " + describeSib + "s ";
    }
    contextDescription = contextDescription + frame.dataset.focusContext.charAt(1);
    if (contextDescription.charAt(contextDescription.length-1) == 1) {
      contextDescription = contextDescription + " right " + describeSib + " ";
    } else {
      contextDescription = contextDescription + " right " + describeSib + "s ";
    }
    contextDescription = contextDescription + frame.dataset.focusContext.charAt(2);
    if (contextDescription.charAt(contextDescription.length-1) == 1) {
      contextDescription = contextDescription + " child";
    } else {
      contextDescription = contextDescription + " children";
    }
    parentNode.setAttribute("aria-description",contextDescription);
  }
  if (selected == "" && treeArray[0] != '\u03A6') {
    var outline = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    outline.setAttribute("x",parentNode.getBBox().x);
    outline.setAttribute("y",parentNode.getBBox().y);
    outline.setAttribute("height",parentNode.getBBox().height);
    outline.setAttribute("width",parentNode.getBBox().width);
    outline.setAttribute("class","selection-color");
    group.insertBefore(outline,parentNode);
    if (frame.dataset.selectedContext == "") {
      frame.dataset.selectedContext = "00"
    }
    frame.dataset.selectedContext = frame.dataset.selectedContext + (childNodes.length).toString();
    parentNode.setAttribute('class','invert-color');
    parentNode.setAttribute("aria-selected","true");
  }
  
  for (let i = 0; i < childNodes.length; i++) {
    group.appendChild(childNodes[i]);
  }  
  return group;
  
}

// 2 if the selected node isn't rewritten
// 1 if the selected node is rewritten according to the ruleText
// 0 if the selected node is not rewritten according to the ruleText
// -1 if no node is selected in the treeFrame
function validNode(treeFrame, ruleText) {
  var treeString = treeFrame.dataset.tree;
  if (treeFrame.dataset.selected == "XX") {
    return -1;
  }
  var nodePos = findNode(treeString, treeFrame.dataset.selected);
  var nodeString = treeString.slice(nodePos[0],nodePos[2]+1);
  if (!nodeString.includes(" ")) {
    return 2;
  }
  var parent = nodeString.slice(1,nodeString.indexOf(" "));
  if (parent.charAt(0) == "!") {
    parent = parent.slice(1);
  }
  var children = "";
  var counter = 0;
  for (let i = nodeString.indexOf(" "); i < nodeString.length; i++) {
    if (nodeString.charAt(i) == "[") {
      counter++;
    } else if (nodeString.charAt(i) == "]") {
      counter--;
      children = children.concat(" ");
    } else if (counter == 1) {
      children = children.concat(nodeString.charAt(i));
    }
  }
  children = children.replace(/ +/g, ' ').trim();
  if (checkRule(parent,children,ruleText)) {
    return 1;
  }
  return 0;
}

// returns the rule used to rewrite the selected node
// -1 if no selected node
// 0 if terminal node
function nodeRule(treeFrame) {
  var treeString = treeFrame.dataset.tree;
  if (treeFrame.dataset.selected == "XX") {
    return -1;
  }
  var nodePos = findNode(treeString, treeFrame.dataset.selected);
  var nodeString = treeString.slice(nodePos[0],nodePos[2]+1);
  if (!nodeString.includes(" ")) {
    return 0;
  }
  var parent = nodeString.slice(1,nodeString.indexOf(" "));
  if (parent.charAt(0) == "!") {
    parent = parent.slice(1);
  }
  var children = "";
  var counter = 0;
  for (let i = nodeString.indexOf(" "); i < nodeString.length; i++) {
    if (nodeString.charAt(i) == "[") {
      counter++;
    } else if (nodeString.charAt(i) == "]") {
      counter--;
      children = children.concat(" ");
    } else if (counter == 1) {
      children = children.concat(nodeString.charAt(i));
    }
  }
  children = children.replace(/ +/g, ' ').trim();
  return parent + " \u2192 " + children;
}

// [# errors, array of errors]
// Each error is a path; last is if start node isn't "S"
function frameErrors(treeFrame, ruleText) {
    let treeString = treeFrame.dataset.tree
    treeString = '[\u03A6 ' + treeString + ']';
    var treeArray = parseTree(treeString)[1];
    var errors = treeErrors(treeArray, ruleText, "");
    if (treeArray[1][0] != "S" && treeArray[1][0] != "!S") {
        errors.push("start");
    }
    return [errors.length,errors];
}

function treeErrors(treeArray, ruleText, path) {
  if (treeArray.length == 1) {
    return [];
  }
  var parent = treeArray[0].replace(/!/g,"");
  var children = "";
  var errors = [];
  for (let i = 1; i < treeArray.length; i++) {
    children = children + " " + treeArray[i][0].replace(/!/g,"");
  }
  children = children.trim();
  if (parent!='\u03A6' && !checkRule(parent,children,ruleText)) {
    errors.push(path);
  }
  for (let i = 1; i < treeArray.length; i++) {
    errors = errors.concat(treeErrors(treeArray[i],ruleText,path + (i-1)));
  }
  return errors;
}

// true iff the parent is rewritten to the children somewhere in the rules
// children are a single string with spaces inbetween labels
function checkRule(parent, children, ruleText) {
  var byLeft = ruleText.split(/,/);
  // Iterate through each parent node
  for (let leftSide of byLeft) {
    var broken = leftSide.split(/[>|]/);
    if (parent == broken[0]) {
      // Iterate through each rewrite rule for the parent node
      for (let i = 1; i < broken.length; i++) {
        if (children == broken[i]) {
          return true;
        }
      }
    }
  }
  return false;
}

function parse(ruleText, string) {
    // Parse the ruleset
    let rules = rulesFromRuleText(ruleText);
    /*
    let rules = ruleText.split(",");
    let nonterms = new Array(rules.length);
    let ruleArray = new Array(rules.length);
    for (i in rules) {
        let sides = rules[i].split(">");
        nonterms[i] = sides[0];
        ruleArray[i] = sides[1].split("|");
    }
    alert(JSON.stringify(ruleArray));
    alert(JSON.stringify(rulesFromRuleText(ruleText)[1]));
    */
    if (string == "") {
        return earleyParser(rules[0], rules[1], []);
    }
    return earleyParser(rules[0], rules[1], string.split(" "));
}


// As described in Earley (1970), with zero lookahead and some fudges that might break performance guarantees
// Empty string rules are handled as in Aycock & Horspool (2002)
function earleyParser(nonterms,ruleArray,string) {
    
    let stateSets = new Array(string.length+1);
    stateSets[0] = new earleyStateSet();
    stateSets[0].add(new earleyState("","S",0,0,[]));
    const nullables = findNullables([nonterms,ruleArray],nonterms);
    // Parse
    for (let i = 0; i < string.length+1; i++) {
        stateSets[i+1] = new earleyStateSet();
        let j = 0;
        while (j < stateSets[i].size()) {
            let state = stateSets[i].get(j);
            if (state.progress >= state.rightSideArray.length) {
                // Completer
                stateSets[state.start].complete(state,stateSets[i]);
            } else if (nonterms.includes(state.rightSideArray[state.progress])) {
                // Predictor
                let leftSide = state.rightSideArray[state.progress];
                let index = nonterms.indexOf(leftSide);
                for (let k = 0; k < ruleArray[index].length; k++) {
                    stateSets[i].add(new earleyState(leftSide,ruleArray[index][k],0,i,[]));
                }
                if (nullables.has(leftSide)) {
                    let epsilonState = new earleyState(leftSide,nullables.get(leftSide),1,i,[]);
                    stateSets[i].add(state.increment().addPointer(epsilonState));
                }
            } else {
                // Scanner
                if (string[i] == state.rightSideArray[state.progress]) {
                    stateSets[i+1].add(state.increment());
                }
            }
            j++;
        }
    }
    // Read off tree
    for (let i = 0; i < stateSets[string.length].size(); i++) {
        if (stateSets[string.length].get(i).leftSide == "" && stateSets[string.length].get(i).progress == 1) {
            let potential = buildStateTree(nonterms, stateSets[string.length].get(i).pointers[0]);
            if (readString(potential, [])[1] == string.toString().replaceAll(","," ")) {
                return potential;
            }
        }
    }
    return "";
}

function buildStateTree(nonterms, state) {
    if (state.pointers.length == 0) {
        return ("[" + state.leftSide + " [" + state.rightSide.replaceAll(" ","] [") + "]]");
    }
    let out = "[" + state.leftSide;
    let counter = 0;
    for (i in state.rightSideArray) {
        if (nonterms.includes(state.rightSideArray[i])) {
            out = out + " " + buildStateTree(nonterms, state.pointers[counter]);
            counter++;
        } else {
            out = out + " [" + state.rightSideArray[i] + "]";
        }
    }
    return out + "]";
}

class earleyState {
    constructor(leftSide, rightSide, progress, start, pointers) {
        this.leftSide = leftSide;
        this.rightSide = rightSide;
        this.rightSideArray = rightSide.split(" ");
        this.progress = progress;
        this.start = start;
        this.pointers = pointers;
    }
    increment() {
        return new earleyState(this.leftSide, this.rightSide, this.progress + 1, this.start, this.pointers.slice());
    }
    addPointer(p) {
        this.pointers.push(p);
        return this;
    }
    same(otherState) {
        return (this.leftSide == otherState.leftSide &&
        this.rightSide == otherState.rightSide &&
        this.progress == otherState.progress &&
        this.start == otherState.start);
    }
    toString() {
        let tempArray = this.rightSideArray.slice();
        tempArray.splice(this.progress,0,"*");
        return (this.leftSide + ">" + tempArray.toString().replaceAll(","," ") + " " + this.start + " (" + this.pointers + ")");
    }
}

class earleyStateSet {
    constructor() {
        this.stateList = new Array();
    }
    add(newState) {
        for (let i = 0; i < this.stateList.length; i++) {
            if (newState.same(this.stateList[i])) {
                return;
            }
        }
        this.stateList.push(newState);
    }
    complete(state, newSet) {
        for (let i = 0; i < this.stateList.length; i++) {
            if (this.stateList[i].rightSideArray[this.stateList[i].progress] == state.leftSide) {
                newSet.add(this.stateList[i].increment().addPointer(state));
            }
        }
    }
    size() {
        return this.stateList.length;
    }
    get(i) {
        return this.stateList[i];
    }
}

function rulesFromRuleText(ruleText) {
    let ruleStrings = ruleText.split(",");
    let rules = new Array(2);
    rules[0] = new Array(ruleStrings.length);
    rules[1] = new Array(ruleStrings.length);
    for (let i = 0; i < ruleStrings.length; i++) {
        let ruleString = ruleStrings[i].split(">");
        rules[0][i] = ruleString[0];
        rules[1][i] = ruleString[1].split("|");
    }
    return rules;
}

// Sees if some deep element of outer includes inner
function deepIncludes(outer, inner) {
    if (Array.isArray(outer)) {
        for (let i = 0; i < outer.length; i++) {
            if (deepIncludes(outer[i], inner)) {
                return true;
            }
        }
        return false;
    }
    return outer.includes(inner);
}

function deepCount(array) {
  let count = 0;
  for (let i = 0; i < array.length; i++) {
    if (Array.isArray(array[i])) {
      count += deepCount(array[i]);
    } else {
      count ++;
    }
  }
  return count;
}

// Return a map from each nonterminal label to a tree descending from it
// which generates a string of only terminals.
// If none exists, nonterminal isn't in map
function findProductions(ruleText, nonterminals, excludeEpsilon) {
    let rules = rulesFromRuleText(ruleText);
    // Find productive generations
    let productions = new Map();
    // Run until convergence
    for (let i = 0; i < nonterminals.length; i++) {
        // Consider each left side
        leftLoop: for (let j = 0; j < rules[0].length; j++) {
            if (!productions.has(rules[0][j])) {
                // Consider each right side
                for (let k = 0; k < rules[1][j].length; k++) {
                    if (rules[1][j][k] == "\u03B5" && excludeEpsilon) {
                        continue;
                    }
                    let rightLabels = rules[1][j][k].split(" ");
                    let complete = true;
                    for (l = 0; l < rightLabels.length; l++) {
                        if (!nonterminals.includes(rightLabels[l])) {
                            rightLabels[l] = "[" + rightLabels[l] + "]";
                        } else if (!productions.has(rightLabels[l])) {
                            complete = false;
                            break;
                        } else {
                            rightLabels[l] = productions.get(rightLabels[l]);
                        }
                    }
                    if (complete) {
                        productions.set(rules[0][j],"[" + rules[0][j] + " " + rightLabels.toString().replaceAll(","," ") + "]");
                        continue leftLoop;
                    }
                }
            }
        }
    }
    return productions;
}

// Return an array stating whether each nonterminal can be rewritten to the empty string
function findNullables(rules, nonterminals) {
    // Find productive generations
    let nullables = new Map();
    // Run until convergence
    for (let i = 0; i < nonterminals.length; i++) {
        // Consider each left side
        leftLoop: for (let j = 0; j < rules[0].length; j++) {
            if (!nullables.has(rules[0][j])) {
                // Consider each right side
                rightLoop: for (let k = 0; k < rules[1][j].length; k++) {
                    if (rules[1][j][k] == "\u03B5") {
                        nullables.set(rules[0][j],"\u03B5");
                        continue leftLoop;
                    }
                    let rightLabels = rules[1][j][k].split(" ");
                    for (l = 0; l < rightLabels.length; l++) {
                        if (!nonterminals.includes(rightLabels[l])) {
                            continue rightLoop;
                        } else if (!nullables.has(rightLabels[l])) {
                            continue rightLoop;
                        } else {
                            rightLabels[l] = rightLabels[l] + " [" + nullables.get(rightLabels[l]) + "] ";
                        }
                    }
                    nullables.set(rules[0][j],rightLabels.toString().trim().replaceAll(","," "));
                    continue leftLoop;
                }
            }
        }
    }
    return nullables;
}

// Return a new ruleText that doesn't include unproductive rules
function removeUnproductive(rules, nonterminals, productions) {
    let output = new Array(2);
    output[0] = new Array();
    output[1] = new Array();
    for (let i = 0; i < rules[0].length; i++) {
        if (!productions.has(rules[0][i])) {
            continue;
        }
        let rightSide = new Array();
        ruleLoop: for (let j = 0; j < rules[1][i].length; j++) {
            let ruleArray = rules[1][i][j].split(" ");
            for (let k = 0; k < ruleArray.length; k++) {
                if (nonterminals.includes(ruleArray[k]) && !productions.has(ruleArray[k])) {
                    continue ruleLoop;
                }
            }
            rightSide.push(rules[1][i][j]);
        }
        if (rightSide.length > 0) {
            output[0].push(rules[0][i]);
            output[1].push(rightSide);
        }
    }
    return output;
}

// Find any instances of recursion that generate unboundedly long strings
// If there is one, return a tree generated by going through the recursion three times
// If none, return the empty string
function findRecursion(rules, nonterminals, productions) {
    let start = nonterminals.indexOf("S");
    // arcs is adjacency matrix: arcs[x][y] is rule with X on left, Y on right, else undefined
    // multilabels is all rules with a nonterminal and something else on the right side
    let arcs = new Array(nonterminals.length);
    let multilabels = new Array();
    let visited = new Array(nonterminals.length);
    let component = new Array(nonterminals.length);
    let reachable = new Array(nonterminals.length);
    for (let i = 0; i < nonterminals.length; i++) {
        arcs[i] = new Array(nonterminals.length);
        visited[i] = false;
        component[i] = -1;
        reachable[i] = false;
    }
    for (let i = 0; i < rules[0].length; i++) {
        let left = nonterminals.indexOf(rules[0][i]);
        for (let j = 0; j < rules[1][i].length; j++) {
            let right = rules[1][i][j].split(" ");
            // Add all edges generated by this rule
            // 'added' determines if the rule is a multilabel one
            for (let k = 0; k < right.length; k++) {
                let added = false;
                if (nonterminals.includes(right[k])) {
                    arcs[left][nonterminals.indexOf(right[k])] = right;
                    if (!added && right.length > 1) {
                        added = true;
                        multilabels.push(rules[0][i] + ">" + rules[1][i][j]);
                    }
                }
            }
        }
    }
    if (multilabels.length == 0) {
      return "";
    }
    //alert("arcs: " + JSON.stringify(arcs));
    // Find all nonterminals which can be reached from the start symbol
    reachable[start] = [];
    let frontier = [start];
    while (frontier.length != 0) {
        let newFrontier = new Array();
        for (let i = 0; i < frontier.length; i++) {
            for (let j = 0; j < nonterminals.length; j++) {
                if (!reachable[j] && arcs[frontier[i]][j] !== undefined) {
                    newFrontier.push(j);
                    reachable[j] = reachable[frontier[i]].concat(frontier[i]);
                }
            }
        }
        frontier = newFrontier;
    }
    //alert("reachable: " + JSON.stringify(reachable));
    // Find strongly-connected components, using Kosaraju's algorithm
    let traversal = new Array();
    function visit(i) {
        if (!visited[i]) {
            visited[i] = true;
            for (let j = 0; j < nonterminals.length; j++) {
                if (arcs[i][j] !== undefined) {
                    visit(j);
                }
            }
            traversal.push(i);
        }
    }
    function assign(i, compLabel) {
        if (component[i] == -1) {
            component[i] = compLabel;
            for (let j = 0; j < nonterminals.length; j++) {
                if (arcs[j][i] !== undefined) {
                    assign(j,compLabel);
                }
            }
        }
    }
    for (let i = 0; i < nonterminals.length; i++) {
        visit(i);
    }
    for (let i = 0; i < nonterminals.length; i++) {
        assign(traversal[traversal.length-1-i], traversal[traversal.length-1-i]);
    }
    // Look for bad loops
    function generateBadString(parent, child, rule) {
        //alert('starting generation');
        // First, find the loop
        // Find path from child to target via breadth-first search
        let labelPaths = new Array(nonterminals.length);
        for (let i = 0; i < nonterminals.length; i++) {
            labelPaths[i] = false;
        }
        labelPaths[child] = [];
        frontier = [child];
        let counter = 0;
        while (!labelPaths[parent]) {
          counter++;
          if (counter == 100) {
            alert("Bad thing!");
            alert(JSON.stringify(rules));
            alert(JSON.stringify(nonterminals));
            //alert(JSON.stringify(productions.entries()));
            alert(JSON.stringify(arcs));
            alert(JSON.stringify(reachable));
            alert(JSON.stringify(component));
            alert(parent);
            alert(child);
            alert(JSON.stringify(rule));
            throw new Error('ya dun goofed');
          }
            let newFrontier = new Array();
            for (let i = 0; i < frontier.length; i++) {
                for (let j = 0; j < nonterminals.length; j++) {
                    if (!labelPaths[j] && arcs[frontier[i]][j] !== undefined) {
                        newFrontier.push(j);
                        labelPaths[j] = labelPaths[frontier[i]].concat(frontier[i]);
                    }
                }
            }
            frontier = newFrontier;
        }
        // Make string containing recursion
        function buildTreeFromPath(inside, insideRoot, path) {
            let output = inside;
            let currentRoot = insideRoot;
            while (path.length > 0) {
                let parentIndex = path.pop();
                let childIndex = nonterminals.indexOf(currentRoot);
                let appliedRule = arcs[parentIndex][childIndex].toString().replaceAll(","," ");
                let myRuleTree = "[" + nonterminals[parentIndex] + " [" + appliedRule.replaceAll(" ","] [") + "]]";
                output = myRuleTree.replace("[" + currentRoot + "]",output);
                currentRoot = nonterminals[parentIndex];
            }
            return output;
        }
        let ruleTree = "[" + nonterminals[parent] + " [" + rule[1].replaceAll(" ","] [") + "]]";
        let output = buildTreeFromPath(ruleTree, nonterminals[parent], labelPaths[parent]);
        //alert("output " + output + " will go into " + ruleTree + " replacing [" + nonterminals[child] + "]");
        output = ruleTree.replace("[" + nonterminals[child] + "]",output);
        output = ruleTree.replace("[" + nonterminals[child] + "]",output);
        //alert("output 2 " + output);
        // Then, work up to S
        output = buildTreeFromPath(output, nonterminals[parent], reachable[parent]);
        // Populate remaining nonterminals with productions
        //alert("output 2 " + output);
        for (let i = 0; i < nonterminals.length; i++) {
            //alert(nonterminals[i] + " has production:");
            output = output.replaceAll("[" + nonterminals[i] + "]",productions.get(nonterminals[i]));
        }
        return output;
    }
    for (let i = 0; i < multilabels.length; i++) {
        //alert("Candidate: " + multilabels[i]);
        let rule = multilabels[i].split(">");
        let right = rule[1].split(" ");
        if (reachable[nonterminals.indexOf(rule[0])]) {
            for (let j = 0; j < right.length; j++) {
                if (nonterminals.includes(right[j])) {
                    if (component[nonterminals.indexOf(rule[0])] == component[nonterminals.indexOf(right[j])]) {
                        //alert("Candidate: " + rule[0] + ">" + rule[1]);
                        return generateBadString(nonterminals.indexOf(rule[0]),nonterminals.indexOf(right[j]),rule);
                    }
                }
            }
        }
    }
    return "";
}

// Generate all strings of a ruleset, with trees - will hang if non-trivially recursive
// ASDF WILL BREAK IF UNPRODUCTIVE RULE ON RIGHT SIDE
function breadthGeneration(rules, nonterminals) {
    let frontier = ["S"];
    let allStrings = new Set();
    allStrings.add("S");
    let extension = new Set();
    //alert(JSON.stringify(rules));
    //let distribute = (a, b) => [].concat(...a.map(x => b.map(y => "".concat(x," ",y).trim())));
    while (frontier.length > 0) {
        let newFrontier = new Array();
        for (let i = 0; i < frontier.length; i++) {
            let s = frontier[i].split(" ");
            let outcomes = [""];
            let terminal = true;
            for (let j = 0; j < s.length; j++) {
                if (!nonterminals.includes(s[j])) {
                    outcomes = distribute(outcomes, [s[j]], ' ');
                } else {
                    //alert(JSON.stringify(rules[1][rules[0].indexOf(s[j])]));
                    //alert(JSON.stringify(rules[0]) + " " + s[j]);
                    outcomes = distribute(outcomes, rules[1][rules[0].indexOf(s[j])], ' ');
                    terminal = false;
                }
            }
            if (terminal) {
                //alert("terminal " + outcomes[0]);
                extension.add(outcomes[0]);
            } else {
                //alert("nonterminal(s)");
                for (let j = 0; j < outcomes.length; j++) {
                    if (!allStrings.has(outcomes[j])) {
                        newFrontier.push(outcomes[j]);
                        allStrings.add(outcomes[j]);
                    }
                }
                //alert(JSON.stringify(newStrings));
            }
        }
        frontier = newFrontier;
    }
    //alert("Final: " + JSON.stringify(Array.from(extension)));
    let output = new Set();
    for (string of extension) {
        output.add(string.replaceAll("\u03B5","").replace(/\s+/g, " ").trim());
    }
    return output;
}

/*
alert('hi');
let myRuleText = "S>x A|x B|y B|z C,A>x|y|A A,B>y|z|C B,C>z|B C|C C";
let myNonterminals = ["S","A","B","C"];
let myProductions = findProductions(myRuleText,myNonterminals);
alert(myProductions.get("A"));
let clean = removeUnproductive(rulesFromRuleText(myRuleText),myNonterminals,myProductions);
//breadthGeneration(clean,myNonterminals);
alert(findRecursion(clean,myNonterminals,myProductions));
*/

function yorubaNumeralPronunciation(num) {
    num = parseInt(num,10);
    if (num <= 10) {
        return ["kan","me\u0301ji\u0300","me\u0301\u0323ta","me\u0301\u0323rin","ma\u0301ru\u0300n-u\u0301n","me\u0301\u0323fa\u0300","me\u0301je","me\u0301\u0323jo\u0323","me\u0301\u0323sa\u0300n-a\u0301n","me\u0301\u0323wa\u0300a\u0301"][num-1];
    } else if (num > 14 && num < 31 && num%5==0) {
        return ["me\u0301\u0323e\u0300\u0323do\u0301gu\u0301n","ogu\u0301n","me\u0301\u0323e\u0300\u0323do\u0301\u0323gbo\u0300\u0323n","o\u0323gbo\u0300\u0323n"][num/5-3];
    } else if (num%10 == 0) {
        return ["a\u0300a\u0301do\u0301","ogo\u0301","a\u0300a\u0301do\u0301\u0323","o\u0323go\u0301\u0323"][2*Math.floor(((num+70)%100)/100+.85)+(1-(num/10)%2)] + ["ji\u0300","ta","rin","ru\u0300n-u\u0301n","fa\u0300","je","jo\u0323","sa\u0300n-a\u0301n","wa\u0300a\u0301"][Math.floor((num+10)/20)-2];
    } else {
        var p_1 = ["mo\u0301\u0323ka\u0300n","me\u0301ji\u0300","me\u0301\u0323ta\u0300","me\u0301\u0323ri\u0300n","ma\u0301ru\u0300n"][4-Math.abs(num%10-5)];
        if (num<15) {
            return p_1 + "la\u0301";
        }
        var p_2 = ["le\u0301l","di\u0301nl"][Math.floor(num%10/4.9)];
        var p_3 = "";
        if (num <= 24) {
            p_3 = "o\u0301gu\u0301n";
        } else if (num <= 34) {
            p_3 = "o\u0301\u0323gbo\u0300\u0323n";
        } else {
            var adjusted = Math.floor((num+5)/10)*10;
            p_3 = ["a\u0301a\u0300do\u0301","o\u0301go\u0301","a\u0301a\u0300do\u0301\u0323","o\u0301\u0323go\u0301\u0323"][2*Math.floor(((adjusted+70)%100)/100+.85)+(1-(adjusted/10)%2)] + ["ji\u0300","ta","rin","ru\u0300n-u\u0301n","fa\u0300","je","jo\u0323","sa\u0300n-a\u0301n","wa\u0300a\u0301"][Math.floor((adjusted+10)/20)-2];
        }
        return p_1 + p_2 + p_3;
    }
}

function isPalindrome(str) {
    return (str==str.split("").reverse().join(""));
}

function setDifference(first, second) {
    let output = new Set(first);
    for (const val of second) {
        output.delete(val);
    }
    return output;
}

</script>
</body>
</html>